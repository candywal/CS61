This is slib.info, produced by makeinfo version 4.1 from slib.texi.

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* SLIB: (slib).         Scheme Library
END-INFO-DIR-ENTRY

  This file documents SLIB, the portable Scheme library.

  Copyright (C) 1993 Todd R. Eigenschink
Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
2002 Aubrey Jaffer

  Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

  Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

  Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the author.


File: slib.info,  Node: Top,  Next: The Library System,  Prev: (dir),  Up: (dir)

"SLIB" is a portable library for the programming language "Scheme".  It
provides a platform independent framework for using "packages" of
Scheme procedures and syntax.  As distributed, SLIB contains useful
packages for all Scheme implementations.  Its catalog can be
transparently extended to accomodate packages specific to a site,
implementation, user, or directory.

* Menu:

* The Library System::          How to use and customize.
* Scheme Syntax Extension Packages::
* Textual Conversion Packages::
* Mathematical Packages::
* Database Packages::
* Other Packages::
* About SLIB::                  Install, etc.
* Index::


File: slib.info,  Node: The Library System,  Next: Scheme Syntax Extension Packages,  Prev: Top,  Up: Top

The Library System
******************

* Menu:

* Feature::                     SLIB names.
* Requesting Features::
* Library Catalogs::
* Catalog Compilation::
* Built-in Support::
* About this manual::


File: slib.info,  Node: Feature,  Next: Requesting Features,  Prev: The Library System,  Up: The Library System

Feature
=======

SLIB denotes "features" by symbols.  SLIB maintains a list of features
supported by the Scheme "session".  The set of features provided by a
session may change over time.  Some features are properties of the
Scheme implementation being used.  The following features detail what
sort of numbers are available from an implementation.

   * 'inexact

   * 'rational

   * 'real

   * 'complex

   * 'bignum

Other features correspond to the presence of sets of Scheme procedures
or syntax (macros).

 - Function: provided? feature
     Returns `#t' if FEATURE is supported by the current Scheme session.

 - Procedure: provide feature
     Informs SLIB that FEATURE is supported.  Henceforth `(provided?
     FEATURE)' will return `#t'.

     (provided? 'foo)    => #f
     (provide 'foo)
     (provided? 'foo)    => #t


File: slib.info,  Node: Requesting Features,  Next: Library Catalogs,  Prev: Feature,  Up: The Library System

Requesting Features
===================

SLIB creates and maintains a "catalog" mapping features to locations of
files introducing procedures and syntax denoted by those features.

At the beginning of each section of this manual, there is a line like
`(require 'FEATURE)'.  The Scheme files comprising SLIB are cataloged
so that these feature names map to the corresponding files.

SLIB provides a form, `require', which loads the files providing the
requested feature.

 - Procedure: require feature
        * If `(provided? FEATURE)' is true, then `require' just returns
          an unspecified value.

        * Otherwise, if FEATURE is found in the catalog, then the
          corresponding files will be loaded and an unspecified value
          returned.

          Subsequently `(provided? FEATURE)' will return `#t'.

        * Otherwise (FEATURE not found in the catalog), an error is
          signaled.

The catalog can also be queried using `require:feature->path'.

 - Function: require:feature->path feature
        * If FEATURE is already provided, then returns `#t'.

        * Otherwise, if FEATURE is in the catalog, the path or list of
          paths associated with FEATURE is returned.

        * Otherwise, returns `#f'.


File: slib.info,  Node: Library Catalogs,  Next: Catalog Compilation,  Prev: Requesting Features,  Up: The Library System

Library Catalogs
================

At the start of a session no catalog is present, but is created with the
first catalog inquiry (such as `(require 'random)').  Several sources
of catalog information are combined to produce the catalog:

   * standard SLIB packages.

   * additional packages of interest to this site.

   * packages specifically for the variety of Scheme which this session
     is running.

   * packages this user wants to always have available.  This catalog
     is the file `homecat' in the user's "HOME" directory.

   * packages germane to working in this (current working) directory.
     This catalog is the file `usercat' in the directory to which it
     applies.  One would typically `cd' to this directory before
     starting the Scheme session.

Catalog files consist of one or more "association list"s.  In the
circumstance where a feature symbol appears in more than one list, the
latter list's association is retrieved.  Here are the supported formats
for elements of catalog lists:

`(FEATURE . <symbol>)'
     Redirects to the feature named <symbol>.

`(FEATURE . "<path>")'
     Loads file <path>.

`(FEATURE source "<path>")'
     `slib:load's the Scheme source file <path>.

`(FEATURE compiled "<path>" ...)'
     `slib:load-compiled's the files <path> ....

`(FEATURE aggregate <symbol> ...)'
     `require:require's the features <symbol> ....

The various macro styles first `require' the named macro package, then
just load <path> or load-and-macro-expand <path> as appropriate for the
implementation.

`(FEATURE defmacro "<path>")'
     `defmacro:load's the Scheme source file <path>.

`(FEATURE macro-by-example "<path>")'
     `defmacro:load's the Scheme source file <path>.

`(FEATURE macro "<path>")'
     `macro:load's the Scheme source file <path>.

`(FEATURE macros-that-work "<path>")'
     `macro:load's the Scheme source file <path>.

`(FEATURE syntax-case "<path>")'
     `macro:load's the Scheme source file <path>.

`(FEATURE syntactic-closures "<path>")'
     `macro:load's the Scheme source file <path>.

Here is an example of a `usercat' catalog.  A Program in this directory
can invoke the `run' feature with `(require 'run)'.

     ;;; "usercat": SLIB catalog additions for SIMSYNCH.     -*-scheme-*-
     
     (
      (simsynch      . "../synch/simsynch.scm")
      (run           . "../synch/run.scm")
      (schlep        . "schlep.scm")
     )


File: slib.info,  Node: Catalog Compilation,  Next: Built-in Support,  Prev: Library Catalogs,  Up: The Library System

Catalog Compilation
===================

SLIB combines the catalog information which doesn't vary per user into
the file `slibcat' in the implementation-vicinity.  Therefore `slibcat'
needs change only when new software is installed or compiled.  Because
the actual pathnames of files can differ from installation to
installation, SLIB builds a separate catalog for each implementation it
is used with.

The definition of `*SLIB-VERSION*' in SLIB file `require.scm' is
checked against the catalog association of `*SLIB-VERSION*' to
ascertain when versions have changed.  I recommend that the definition
of `*SLIB-VERSION*' be changed whenever the library is changed.  If
multiple implementations of Scheme use SLIB, remember that recompiling
one `slibcat' will fix only that implementation's catalog.

The compilation scripts of Scheme implementations which work with SLIB
can automatically trigger catalog compilation by deleting `slibcat' or
by invoking a special form of `require':

 - Procedure: require 'new-catalog
     This will load `mklibcat', which compiles and writes a new
     `slibcat'.

Another special form of `require' erases SLIB's catalog, forcing it to
be reloaded the next time the catalog is queried.

 - Procedure: require #f
     Removes SLIB's catalog information.  This should be done before
     saving an executable image so that, when restored, its catalog
     will be loaded afresh.

Each file in the table below is descibed in terms of its file-system
independent "vicinity" (*note Vicinity::).  The entries of a catalog in
the table override those of catalogs above it in the table.

`implementation-vicinity' `slibcat'
     This file contains the associations for the packages comprising
     SLIB, the `implcat' and the `sitecat's.  The associations in the
     other catalogs override those of the standard catalog.

`library-vicinity' `mklibcat.scm'
     creates `slibcat'.

`library-vicinity' `sitecat'
     This file contains the associations specific to an SLIB
     installation.

`implementation-vicinity' `implcat'
     This file contains the associations specific to an implementation
     of Scheme.  Different implementations of Scheme should have
     different `implementation-vicinity'.

`implementation-vicinity' `mkimpcat.scm'
     if present, creates `implcat'.

`implementation-vicinity' `sitecat'
     This file contains the associations specific to a Scheme
     implementation installation.

`home-vicinity' `homecat'
     This file contains the associations specific to an SLIB user.

`user-vicinity' `usercat'
     This file contains associations effecting only those sessions whose
     "working directory" is `user-vicinity'.


File: slib.info,  Node: Built-in Support,  Next: About this manual,  Prev: Catalog Compilation,  Up: The Library System

Built-in Support
================

The procedures described in these sections are supported by all
implementations as part of the `*.init' files or by `require.scm'.

* Menu:

* Require::                     Module Management
* Vicinity::                    Pathname Management
* Configuration::               Characteristics of Scheme Implementation
* Input/Output::                Things not provided by the Scheme specs.
* System::                      LOADing, EVALing, ERRORing, and EXITing
* Miscellany::


File: slib.info,  Node: Require,  Next: Vicinity,  Prev: Built-in Support,  Up: Built-in Support

Require
-------

 - Variable: *features*
     Is a list of symbols denoting features supported in this
     implementation.  *FEATURES* can grow as modules are `require'd.
     *FEATURES* must be defined by all implementations (*note
     Porting::).

     Here are features which SLIB (`require.scm') adds to *FEATURES*
     when appropriate.

        * 'inexact

        * 'rational

        * 'real

        * 'complex

        * 'bignum

     For each item, `(provided? 'FEATURE)' will return `#t' if that
     feature is available, and `#f' if not.

 - Variable: *modules*
     Is a list of pathnames denoting files which have been loaded.

 - Variable: *catalog*
     Is an association list of features (symbols) and pathnames which
     will supply those features.  The pathname can be either a string
     or a pair.  If pathname is a pair then the first element should be
     a macro feature symbol, `source', or `compiled'.  The cdr of the
     pathname should be either a string or a list.

In the following functions if the argument FEATURE is not a symbol it
is assumed to be a pathname.

 - Function: provided? feature
     Returns `#t' if FEATURE is a member of `*features*' or `*modules*'
     or if FEATURE is supported by a file already loaded and `#f'
     otherwise.

 - Procedure: require feature
     FEATURE is a symbol.  If `(provided? FEATURE)' is true `require'
     returns.  Otherwise, if `(assq FEATURE *catalog*)' is not `#f',
     the associated files will be loaded and `(provided? FEATURE)' will
     henceforth return `#t'.  An unspecified value is returned.  If
     FEATURE is not found in `*catalog*', then an error is signaled.

 - Procedure: require pathname
     PATHNAME is a string.  If PATHNAME has not already been given as
     an argument to `require', PATHNAME is loaded.  An unspecified
     value is returned.

 - Procedure: provide feature
     Assures that FEATURE is contained in `*features*' if FEATURE is a
     symbol and `*modules*' otherwise.

 - Function: require:feature->path feature
     Returns `#t' if FEATURE is a member of `*features*' or `*modules*'
     or if FEATURE is supported by a file already loaded.  Returns a
     path if one was found in `*catalog*' under the feature name, and
     `#f' otherwise.  The path can either be a string suitable as an
     argument to load or a pair as described above for *catalog*.


File: slib.info,  Node: Vicinity,  Next: Configuration,  Prev: Require,  Up: Built-in Support

Vicinity
--------

A vicinity is a descriptor for a place in the file system.  Vicinities
hide from the programmer the concepts of host, volume, directory, and
version.  Vicinities express only the concept of a file environment
where a file name can be resolved to a file in a system independent
manner.  Vicinities can even be used on "flat" file systems (which have
no directory structure) by having the vicinity express constraints on
the file name.  On most systems a vicinity would be a string.  All of
these procedures are file system dependent.

These procedures are provided by all implementations.

 - Function: make-vicinity dirpath                                            |
     Returns DIRPATH as a vicinity for use as first argument to               |
     `in-vicinity'.                                                           |
                                                                              |
 - Function: pathname->vicinity path                                          |
     Returns the vicinity containing PATH.                                    |
          (pathname->vicinity "/usr/local/lib/scm/Link.scm")                  |
                              => "/usr/local/lib/scm/"                        |

 - Function: program-vicinity
     Returns the vicinity of the currently loading Scheme code.  For an
     interpreter this would be the directory containing source code.
     For a compiled system (with multiple files) this would be the
     directory where the object or executable files are.  If no file is
     currently loading it the result is undefined.  *Warning:*
     `program-vicinity' can return incorrect values if your program
     escapes back into a `load'.

 - Function: library-vicinity
     Returns the vicinity of the shared Scheme library.

 - Function: implementation-vicinity
     Returns the vicinity of the underlying Scheme implementation.  This
     vicinity will likely contain startup code and messages and a
     compiler.

 - Function: user-vicinity
     Returns the vicinity of the current directory of the user.  On most
     systems this is `""' (the empty string).

 - Function: home-vicinity
     Returns the vicinity of the user's "HOME" directory, the directory
     which typically contains files which customize a computer
     environment for a user.  If scheme is running without a user (eg.
     a daemon) or if this concept is meaningless for the platform, then
     `home-vicinity' returns `#f'.

 - Function: in-vicinity vicinity filename
     Returns a filename suitable for use by `slib:load',
     `slib:load-source', `slib:load-compiled', `open-input-file',
     `open-output-file', etc.  The returned filename is FILENAME in
     VICINITY.  `in-vicinity' should allow FILENAME to override
     VICINITY when FILENAME is an absolute pathname and VICINITY is
     equal to the value of `(user-vicinity)'.  The behavior of
     `in-vicinity' when FILENAME is absolute and VICINITY is not equal
     to the value of `(user-vicinity)' is unspecified.  For most systems
     `in-vicinity' can be `string-append'.

 - Function: sub-vicinity vicinity name
     Returns the vicinity of VICINITY restricted to NAME.  This is used
     for large systems where names of files in subsystems could
     conflict.  On systems with directory structure `sub-vicinity' will
     return a pathname of the subdirectory NAME of VICINITY.


File: slib.info,  Node: Configuration,  Next: Input/Output,  Prev: Vicinity,  Up: Built-in Support

Configuration
-------------

These constants and procedures describe characteristics of the Scheme
and underlying operating system.  They are provided by all
implementations.

 - Constant: char-code-limit
     An integer 1 larger that the largest value which can be returned by
     `char->integer'.

 - Constant: most-positive-fixnum
     In implementations which support integers of practically unlimited
     size, MOST-POSITIVE-FIXNUM is a large exact integer within the
     range of exact integers that may result from computing the length
     of a list, vector, or string.

     In implementations which do not support integers of practically
     unlimited size, MOST-POSITIVE-FIXNUM is the largest exact integer
     that may result from computing the length of a list, vector, or
     string.

 - Constant: slib:tab
     The tab character.

 - Constant: slib:form-feed
     The form-feed character.

 - Function: software-type
     Returns a symbol denoting the generic operating system type.  For
     instance, `unix', `vms', `macos', `amiga', or `ms-dos'.

 - Function: slib:report-version
     Displays the versions of SLIB and the underlying Scheme
     implementation and the name of the operating system.  An
     unspecified value is returned.

          (slib:report-version) => slib "2d5" on scm "5b1" on unix            |

 - Function: slib:report
     Displays the information of `(slib:report-version)' followed by
     almost all the information neccessary for submitting a problem
     report.  An unspecified value is returned.

 - Function: slib:report #t
     provides a more verbose listing.

 - Function: slib:report filename
     Writes the report to file `filename'.

          (slib:report)
          =>
          slib "2d5" on scm "5b1" on unix                                     |
          (implementation-vicinity) is "/home/jaffer/scm/"
          (library-vicinity) is "/home/jaffer/slib/"
          (scheme-file-suffix) is ".scm"
          loaded *features* :
                  trace alist qp sort
                  common-list-functions macro values getopt
                  compiled
          implementation *features* :
                  bignum complex real rational
                  inexact vicinity ed getenv
                  tmpnam abort transcript with-file
                  ieee-p1178 rev4-report rev4-optional-procedures hash
                  object-hash delay eval dynamic-wind
                  multiarg-apply multiarg/and- logical defmacro
                  string-port source current-time record
                  rev3-procedures rev2-procedures sun-dl string-case
                  array dump char-ready? full-continuation
                  system
          implementation *catalog* :
                  (i/o-extensions compiled "/home/jaffer/scm/ioext.so")
                  ...


File: slib.info,  Node: Input/Output,  Next: System,  Prev: Configuration,  Up: Built-in Support

Input/Output
------------

These procedures are provided by all implementations.

 - Function: file-exists? filename
     Returns `#t' if the specified file exists.  Otherwise, returns
     `#f'.  If the underlying implementation does not support this
     feature then `#f' is always returned.

 - Function: delete-file filename
     Deletes the file specified by FILENAME.  If FILENAME can not be
     deleted, `#f' is returned.  Otherwise, `#t' is returned.

 - Function: open-file filename modes
     FILENAME should be a string naming a file.  `open-file' returns a
     port depending on the symbol MODES:

    r
          an input port capable of delivering characters from the file.

    rb
          a _binary_ input port capable of delivering characters from
          the file.

    w
          an output port capable of writing characters to a new file by
          that name.

    wb
          a _binary_ output port capable of writing characters to a new
          file by that name.

     If an implementation does not distinguish between binary and
     non-binary files, then it must treat rb as r and wb as w.

     If the file cannot be opened, either #f is returned or an error is
     signalled.  For output, if a file with the given name already
     exists, the effect is unspecified.

 - Function: port? obj
     Returns #t if OBJ is an input or output port, otherwise returns #f.

 - Procedure: close-port port
     Closes the file associated with PORT, rendering the PORT incapable
     of delivering or accepting characters.

     `close-file' has no effect if the file has already been closed.
     The value returned is unspecified.

 - Function: call-with-open-ports proc ports ...
 - Function: call-with-open-ports ports ... proc
     PROC should be a procedure that accepts as many arguments as there
     are PORTS passed to `call-with-open-ports'.
     `call-with-open-ports' calls PROC with PORTS ....  If PROC
     returns, then the ports are closed automatically and the value
     yielded by the PROC is returned.  If PROC does not return, then
     the ports will not be closed automatically unless it is possible
     to prove that the ports will never again be used for a read or
     write operation.

 - Function: tmpnam
     Returns a pathname for a file which will likely not be used by any
     other process.  Successive calls to `(tmpnam)' will return
     different pathnames.

 - Function: current-error-port
     Returns the current port to which diagnostic and error output is
     directed.

 - Procedure: force-output
 - Procedure: force-output port
     Forces any pending output on PORT to be delivered to the output
     device and returns an unspecified value.  The PORT argument may be
     omitted, in which case it defaults to the value returned by
     `(current-output-port)'.

 - Function: output-port-width
 - Function: output-port-width port
     Returns the width of PORT, which defaults to
     `(current-output-port)' if absent.  If the width cannot be
     determined 79 is returned.

 - Function: output-port-height
 - Function: output-port-height port
     Returns the height of PORT, which defaults to
     `(current-output-port)' if absent.  If the height cannot be
     determined 24 is returned.


File: slib.info,  Node: System,  Next: Miscellany,  Prev: Input/Output,  Up: Built-in Support

System
------

These procedures are provided by all implementations.

 - Procedure: slib:load-source name
     Loads a file of Scheme source code from NAME with the default
     filename extension used in SLIB.  For instance if the filename
     extension used in SLIB is `.scm' then `(slib:load-source "foo")'
     will load from file `foo.scm'.

 - Procedure: slib:load-compiled name
     On implementations which support separtely loadable compiled
     modules, loads a file of compiled code from NAME with the
     implementation's filename extension for compiled code appended.

 - Procedure: slib:load name
     Loads a file of Scheme source or compiled code from NAME with the
     appropriate suffixes appended.  If both source and compiled code
     are present with the appropriate names then the implementation
     will load just one.  It is up to the implementation to choose
     which one will be loaded.

     If an implementation does not support compiled code then
     `slib:load' will be identical to `slib:load-source'.

 - Procedure: slib:eval obj
     `eval' returns the value of OBJ evaluated in the current top level
     environment.  *Note Eval:: provides a more general evaluation
     facility.

 - Procedure: slib:eval-load filename eval
     FILENAME should be a string.  If filename names an existing file,
     the Scheme source code expressions and definitions are read from
     the file and EVAL called with them sequentially.  The
     `slib:eval-load' procedure does not affect the values returned by
     `current-input-port' and `current-output-port'.

 - Procedure: slib:warn arg1 arg2 ...
     Outputs a warning message containing the arguments.

 - Procedure: slib:error arg1 arg2 ...
     Outputs an error message containing the arguments, aborts
     evaluation of the current form and responds in a system dependent
     way to the error.  Typical responses are to abort the program or
     to enter a read-eval-print loop.

 - Procedure: slib:exit n
 - Procedure: slib:exit
     Exits from the Scheme session returning status N to the system.
     If N is omitted or `#t', a success status is returned to the
     system (if possible).  If N is `#f' a failure is returned to the
     system (if possible).  If N is an integer, then N is returned to
     the system (if possible).  If the Scheme session cannot exit an
     unspecified value is returned from `slib:exit'.

 - Function: browse-url url                                                   |
     Web browsers have become so ubiquitous that programming languagues       |
     should support a uniform interface to them.                              |
                                                                              |
     If a `netscape' browser is running, `browse-url' causes the              |
     browser to display the page specified by string URL and returns #t.      |
                                                                              |
     If the browser is not running, `browse-url' starts a browser             |
     displaying the argument URL.  If the browser starts as a                 |
     background job, `browse-url' returns #t immediately; if the              |
     browser starts as a foreground job, then `browse-url' returns #t         |
     when the browser exits; otherwise it returns #f.                         |
                                                                              |

File: slib.info,  Node: Miscellany,  Prev: System,  Up: Built-in Support

Miscellany
----------

  These procedures are provided by all implementations.

 - Function: identity x
     IDENTITY returns its argument.

     Example:
          (identity 3)
             => 3
          (identity '(foo bar))
             => (foo bar)
          (map identity LST)
             == (copy-list LST)

Mutual Exclusion
................

An "exchanger" is a procedure of one argument regulating mutually
exclusive access to a resource.  When a exchanger is called, its current
content is returned, while being replaced by its argument in an atomic
operation.

 - Function: make-exchanger obj
     Returns a new exchanger with the argument OBJ as its initial
     content.

          (define queue (make-exchanger (list a)))

     A queue implemented as an exchanger holding a list can be
     protected from reentrant execution thus:

          (define (pop queue)
            (let ((lst #f))
              (dynamic-wind
                  (lambda () (set! lst (queue #f)))
                  (lambda () (and lst (not (null? lst))
                                  (let ((ret (car lst)))
                                    (set! lst (cdr lst))
                                    ret)))
                  (lambda () (and lst (queue lst))))))
          
          (pop queue)         => a
          
          (pop queue)         => #f

Legacy
......

The following procedures were present in Scheme until R4RS (*note
Language changes: (r4rs)Notes.).  They are provided by all SLIB
implementations.

 - Constant: t
     Derfined as `#t'.

 - Constant: nil
     Defined as `#f'.

 - Function: last-pair l
     Returns the last pair in the list L.  Example:
          (last-pair (cons 1 2))
             => (1 . 2)
          (last-pair '(1 2))
             => (2)
              == (cons 2 '())


File: slib.info,  Node: About this manual,  Prev: Built-in Support,  Up: The Library System

About this manual
=================

   * Entries that are labeled as Functions are called for their return
     values.  Entries that are labeled as Procedures are called
     primarily for their side effects.

   * Examples in this text were produced using the `scm' Scheme
     implementation.

   * At the beginning of each section, there is a line that looks like
     `(require 'feature)'.  Include this line in your code prior to
     using the package.


File: slib.info,  Node: Scheme Syntax Extension Packages,  Next: Textual Conversion Packages,  Prev: The Library System,  Up: Top

Scheme Syntax Extension Packages
********************************

* Menu:

* Defmacro::                    Supported by all implementations

* R4RS Macros::                 'macro
* Macro by Example::            'macro-by-example
* Macros That Work::            'macros-that-work
* Syntactic Closures::          'syntactic-closures
* Syntax-Case Macros::          'syntax-case

Syntax extensions (macros) included with SLIB.

* Fluid-Let::                   'fluid-let
* Yasos::                       'yasos, 'oop, 'collect


File: slib.info,  Node: Defmacro,  Next: R4RS Macros,  Prev: Scheme Syntax Extension Packages,  Up: Scheme Syntax Extension Packages

Defmacro
========

  Defmacros are supported by all implementations.

 - Function: gentemp
     Returns a new (interned) symbol each time it is called.  The symbol
     names are implementation-dependent
          (gentemp) => scm:G0
          (gentemp) => scm:G1

 - Function: defmacro:eval e
     Returns the `slib:eval' of expanding all defmacros in scheme
     expression E.

 - Function: defmacro:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `defmacro:load' procedure reads Scheme source code expressions
     and definitions from the file and evaluates them sequentially.
     These source code expressions and definitions may contain defmacro
     definitions.  The `macro:load' procedure does not affect the values
     returned by `current-input-port' and `current-output-port'.

 - Function: defmacro? sym
     Returns `#t' if SYM has been defined by `defmacro', `#f' otherwise.

 - Function: macroexpand-1 form
 - Function: macroexpand form
     If FORM is a macro call, `macroexpand-1' will expand the macro
     call once and return it.  A FORM is considered to be a macro call
     only if it is a cons whose `car' is a symbol for which a
     `defmacro' has been defined.

     `macroexpand' is similar to `macroexpand-1', but repeatedly
     expands FORM until it is no longer a macro call.

 - Macro: defmacro name lambda-list form ...
     When encountered by `defmacro:eval', `defmacro:macroexpand*', or
     `defmacro:load' defines a new macro which will henceforth be
     expanded when encountered by `defmacro:eval',
     `defmacro:macroexpand*', or `defmacro:load'.

Defmacroexpand
--------------

  `(require 'defmacroexpand)'

 - Function: defmacro:expand* e
     Returns the result of expanding all defmacros in scheme expression
     E.


File: slib.info,  Node: R4RS Macros,  Next: Macro by Example,  Prev: Defmacro,  Up: Scheme Syntax Extension Packages

R4RS Macros
===========

  `(require 'macro)' is the appropriate call if you want R4RS
high-level macros but don't care about the low level implementation.  If
an SLIB R4RS macro implementation is already loaded it will be used.
Otherwise, one of the R4RS macros implemetations is loaded.

  The SLIB R4RS macro implementations support the following uniform
interface:

 - Function: macro:expand sexpression
     Takes an R4RS expression, macro-expands it, and returns the result
     of the macro expansion.

 - Function: macro:eval sexpression
     Takes an R4RS expression, macro-expands it, evals the result of the
     macro expansion, and returns the result of the evaluation.

 - Procedure: macro:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions and
     definitions from the file and evaluates them sequentially.  These
     source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port' and `current-output-port'.


File: slib.info,  Node: Macro by Example,  Next: Macros That Work,  Prev: R4RS Macros,  Up: Scheme Syntax Extension Packages

Macro by Example
================

  `(require 'macro-by-example)'

  A vanilla implementation of `Macro by Example' (Eugene Kohlbecker,
R4RS) by Dorai Sitaram, (dorai @ cs.rice.edu) using `defmacro'.

   * generating hygienic global `define-syntax' Macro-by-Example macros
     *cheaply*.

   * can define macros which use `...'.

   * needn't worry about a lexical variable in a macro definition
     clashing with a variable from the macro use context

   * don't suffer the overhead of redefining the repl if `defmacro'
     natively supported (most implementations)


Caveat
------

  These macros are not referentially transparent (*note Macros:
(r4rs)Macros.).  Lexically scoped macros (i.e., `let-syntax' and
`letrec-syntax') are not supported.  In any case, the problem of
referential transparency gains poignancy only when `let-syntax' and
`letrec-syntax' are used.  So you will not be courting large-scale
disaster unless you're using system-function names as local variables
with unintuitive bindings that the macro can't use.  However, if you
must have the full `r4rs' macro functionality, look to the more
featureful (but also more expensive) versions of syntax-rules available
in slib *Note Macros That Work::, *Note Syntactic Closures::, and *Note
Syntax-Case Macros::.

 - Macro: define-syntax keyword transformer-spec
     The KEYWORD is an identifier, and the TRANSFORMER-SPEC should be
     an instance of `syntax-rules'.

     The top-level syntactic environment is extended by binding the
     KEYWORD to the specified transformer.

          (define-syntax let*
            (syntax-rules ()
              ((let* () body1 body2 ...)
               (let () body1 body2 ...))
              ((let* ((name1 val1) (name2 val2) ...)
                 body1 body2 ...)
               (let ((name1 val1))
                 (let* (( name2 val2) ...)
                   body1 body2 ...)))))

 - Macro: syntax-rules literals syntax-rule ...
     LITERALS is a list of identifiers, and each SYNTAX-RULE should be
     of the form

     `(PATTERN TEMPLATE)'

     where the PATTERN and  TEMPLATE are as in the grammar above.

     An instance of `syntax-rules' produces a new macro transformer by
     specifying a sequence of hygienic rewrite rules.  A use of a macro
     whose keyword is associated with a transformer specified by
     `syntax-rules' is matched against the patterns contained in the
     SYNTAX-RULEs, beginning with the leftmost SYNTAX-RULE.  When a
     match is found, the macro use is trancribed hygienically according
     to the template.

     Each pattern begins with the keyword for the macro.  This keyword
     is not involved in the matching and is not considered a pattern
     variable or literal identifier.


File: slib.info,  Node: Macros That Work,  Next: Syntactic Closures,  Prev: Macro by Example,  Up: Scheme Syntax Extension Packages

Macros That Work
================

  `(require 'macros-that-work)'

  `Macros That Work' differs from the other R4RS macro implementations
in that it does not expand derived expression types to primitive
expression types.

 - Function: macro:expand expression
 - Function: macwork:expand expression
     Takes an R4RS expression, macro-expands it, and returns the result
     of the macro expansion.

 - Function: macro:eval expression
 - Function: macwork:eval expression
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 - Procedure: macro:load filename
 - Procedure: macwork:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions and
     definitions from the file and evaluates them sequentially.  These
     source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port' and `current-output-port'.

  References:

  The `Revised^4 Report on the Algorithmic Language Scheme' Clinger and
Rees [editors].  To appear in LISP Pointers.  Also available as a
technical report from the University of Oregon, MIT AI Lab, and Cornell.

            Macros That Work.  Clinger and Rees.  POPL '91.
 The supported syntax
differs from the R4RS in that vectors are allowed as patterns and as
templates and are not allowed as pattern or template data.

     transformer spec  ==>  (syntax-rules literals rules)
     
     rules  ==>  ()
              |  (rule . rules)
     
     rule  ==>  (pattern template)
     
     pattern  ==>  pattern_var      ; a symbol not in literals
                |  symbol           ; a symbol in literals
                |  ()
                |  (pattern . pattern)
                |  (ellipsis_pattern)
                |  #(pattern*)                     ; extends R4RS
                |  #(pattern* ellipsis_pattern)    ; extends R4RS
                |  pattern_datum
     
     template  ==>  pattern_var
                 |  symbol
                 |  ()
                 |  (template2 . template2)
                 |  #(template*)                   ; extends R4RS
                 |  pattern_datum
     
     template2  ==>  template
                  |  ellipsis_template
     
     pattern_datum  ==>  string                    ; no vector
                      |  character
                      |  boolean
                      |  number
     
     ellipsis_pattern  ==> pattern ...
     
     ellipsis_template  ==>  template ...
     
     pattern_var  ==>  symbol   ; not in literals
     
     literals  ==>  ()
                 |  (symbol . literals)

Definitions
-----------

Scope of an ellipsis
     Within a pattern or template, the scope of an ellipsis (`...') is
     the pattern or template that appears to its left.

Rank of a pattern variable
     The rank of a pattern variable is the number of ellipses within
     whose scope it appears in the pattern.

Rank of a subtemplate
     The rank of a subtemplate is the number of ellipses within whose
     scope it appears in the template.

Template rank of an occurrence of a pattern variable
     The template rank of an occurrence of a pattern variable within a
     template is the rank of that occurrence, viewed as a subtemplate.

Variables bound by a pattern
     The variables bound by a pattern are the pattern variables that
     appear within it.

Referenced variables of a subtemplate
     The referenced variables of a subtemplate are the pattern
     variables that appear within it.

Variables opened by an ellipsis template
     The variables opened by an ellipsis template are the referenced
     pattern variables whose rank is greater than the rank of the
     ellipsis template.

Restrictions
------------

  No pattern variable appears more than once within a pattern.

  For every occurrence of a pattern variable within a template, the
template rank of the occurrence must be greater than or equal to the
pattern variable's rank.

  Every ellipsis template must open at least one variable.

  For every ellipsis template, the variables opened by an ellipsis
template must all be bound to sequences of the same length.

  The compiled form of a RULE is

     rule  ==>  (pattern template inserted)
     
     pattern  ==>  pattern_var
                |  symbol
                |  ()
                |  (pattern . pattern)
                |  ellipsis_pattern
                |  #(pattern)
                |  pattern_datum
     
     template  ==>  pattern_var
                 |  symbol
                 |  ()
                 |  (template2 . template2)
                 |  #(pattern)
                 |  pattern_datum
     
     template2  ==>  template
                  |  ellipsis_template
     
     pattern_datum  ==>  string
                      |  character
                      |  boolean
                      |  number
     
     pattern_var  ==>  #(V symbol rank)
     
     ellipsis_pattern  ==>  #(E pattern pattern_vars)
     
     ellipsis_template  ==>  #(E template pattern_vars)
     
     inserted  ==>  ()
                 |  (symbol . inserted)
     
     pattern_vars  ==>  ()
                     |  (pattern_var . pattern_vars)
     
     rank  ==>  exact non-negative integer

  where V and E are unforgeable values.

  The pattern variables associated with an ellipsis pattern are the
variables bound by the pattern, and the pattern variables associated
with an ellipsis template are the variables opened by the ellipsis
template.

  If the template contains a big chunk that contains no pattern
variables or inserted identifiers, then the big chunk will be copied
unnecessarily.  That shouldn't matter very often.


File: slib.info,  Node: Syntactic Closures,  Next: Syntax-Case Macros,  Prev: Macros That Work,  Up: Scheme Syntax Extension Packages

Syntactic Closures
==================

  `(require 'syntactic-closures)'

 - Function: macro:expand expression
 - Function: synclo:expand expression
     Returns scheme code with the macros and derived expression types of
     EXPRESSION expanded to primitive expression types.

 - Function: macro:eval expression
 - Function: synclo:eval expression
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 - Procedure: macro:load filename
 - Procedure: synclo:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions and
     definitions from the file and evaluates them sequentially.  These
     source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port' and `current-output-port'.

Syntactic Closure Macro Facility
--------------------------------

                  A Syntactic Closures Macro Facility
                            by Chris Hanson
                            9 November 1991
 This
document describes "syntactic closures", a low-level macro facility for
the Scheme programming language.  The facility is an alternative to the
low-level macro facility described in the `Revised^4 Report on Scheme.'
This document is an addendum to that report.

The syntactic closures facility extends the BNF rule for TRANSFORMER
SPEC to allow a new keyword that introduces a low-level macro
transformer:
     TRANSFORMER SPEC := (transformer EXPRESSION)

  Additionally, the following procedures are added:
     make-syntactic-closure
     capture-syntactic-environment
     identifier?
     identifier=?

  The description of the facility is divided into three parts.  The
first part defines basic terminology.  The second part describes how
macro transformers are defined.  The third part describes the use of
"identifiers", which extend the syntactic closure mechanism to be
compatible with `syntax-rules'.

Terminology
...........

  This section defines the concepts and data types used by the syntactic
closures facility.

   * "Forms" are the syntactic entities out of which programs are
     recursively constructed.  A form is any expression, any
     definition, any syntactic keyword, or any syntactic closure.  The
     variable name that appears in a `set!' special form is also a
     form.  Examples of forms:
          17
          #t
          car
          (+ x 4)
          (lambda (x) x)
          (define pi 3.14159)
          if
          define

   * An "alias" is an alternate name for a given symbol.  It can appear
     anywhere in a form that the symbol could be used, and when quoted
     it is replaced by the symbol; however, it does not satisfy the
     predicate `symbol?'.  Macro transformers rarely distinguish
     symbols from aliases, referring to both as identifiers.

   * A "syntactic" environment maps identifiers to their meanings.
     More precisely, it determines whether an identifier is a syntactic
     keyword or a variable.  If it is a keyword, the meaning is an
     interpretation for the form in which that keyword appears.  If it
     is a variable, the meaning identifies which binding of that
     variable is referenced.  In short, syntactic environments contain
     all of the contextual information necessary for interpreting the
     meaning of a particular form.

   * A "syntactic closure" consists of a form, a syntactic environment,
     and a list of identifiers.  All identifiers in the form take their
     meaning from the syntactic environment, except those in the given
     list.  The identifiers in the list are to have their meanings
     determined later.  A syntactic closure may be used in any context
     in which its form could have been used.  Since a syntactic closure
     is also a form, it may not be used in contexts where a form would
     be illegal.  For example, a form may not appear as a clause in the
     cond special form.  A syntactic closure appearing in a quoted
     structure is replaced by its form.


Transformer Definition
......................

  This section describes the `transformer' special form and the
procedures `make-syntactic-closure' and `capture-syntactic-environment'.

 - Syntax: transformer expression
     Syntax: It is an error if this syntax occurs except as a
     TRANSFORMER SPEC.

     Semantics: The EXPRESSION is evaluated in the standard transformer
     environment to yield a macro transformer as described below.  This
     macro transformer is bound to a macro keyword by the special form
     in which the `transformer' expression appears (for example,
     `let-syntax').

     A "macro transformer" is a procedure that takes two arguments, a
     form and a syntactic environment, and returns a new form.  The
     first argument, the "input form", is the form in which the macro
     keyword occurred.  The second argument, the "usage environment",
     is the syntactic environment in which the input form occurred.
     The result of the transformer, the "output form", is automatically
     closed in the "transformer environment", which is the syntactic
     environment in which the `transformer' expression occurred.

     For example, here is a definition of a push macro using
     `syntax-rules':
          (define-syntax  push
            (syntax-rules ()
              ((push item list)
               (set! list (cons item list)))))

     Here is an equivalent definition using `transformer':
          (define-syntax push
            (transformer
             (lambda (exp env)
               (let ((item
                      (make-syntactic-closure env '() (cadr exp)))
                     (list
                      (make-syntactic-closure env '() (caddr exp))))
                 `(set! ,list (cons ,item ,list))))))

     In this example, the identifiers `set!' and `cons' are closed in
     the transformer environment, and thus will not be affected by the
     meanings of those identifiers in the usage environment `env'.

     Some macros may be non-hygienic by design.  For example, the
     following defines a loop macro that implicitly binds `exit' to an
     escape procedure.  The binding of `exit' is intended to capture
     free references to `exit' in the body of the loop, so `exit' must
     be left free when the body is closed:
          (define-syntax loop
            (transformer
             (lambda (exp env)
               (let ((body (cdr exp)))
                 `(call-with-current-continuation
                   (lambda (exit)
                     (let f ()
                       ,@(map (lambda  (exp)
                                 (make-syntactic-closure env '(exit)
                                                         exp))
                               body)
                       (f))))))))

     To assign meanings to the identifiers in a form, use
     `make-syntactic-closure' to close the form in a syntactic
     environment.

 - Function: make-syntactic-closure environment free-names form
     ENVIRONMENT must be a syntactic environment, FREE-NAMES must be a
     list of identifiers, and FORM must be a form.
     `make-syntactic-closure' constructs and returns a syntactic closure
     of FORM in ENVIRONMENT, which can be used anywhere that FORM could
     have been used.  All the identifiers used in FORM, except those
     explicitly excepted by FREE-NAMES, obtain their meanings from
     ENVIRONMENT.

     Here is an example where FREE-NAMES is something other than the
     empty list.  It is instructive to compare the use of FREE-NAMES in
     this example with its use in the `loop' example above: the examples
     are similar except for the source of the identifier being left
     free.
          (define-syntax let1
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (exp (cadddr exp)))
                 `((lambda (,id)
                     ,(make-syntactic-closure env (list id) exp))
                   ,(make-syntactic-closure env '() init))))))

     `let1' is a simplified version of `let' that only binds a single
     identifier, and whose body consists of a single expression.  When
     the body expression is syntactically closed in its original
     syntactic environment, the identifier that is to be bound by
     `let1' must be left free, so that it can be properly captured by
     the `lambda' in the output form.

     To obtain a syntactic environment other than the usage
     environment, use `capture-syntactic-environment'.

 - Function: capture-syntactic-environment procedure
     `capture-syntactic-environment' returns a form that will, when
     transformed, call PROCEDURE on the current syntactic environment.
     PROCEDURE should compute and return a new form to be transformed,
     in that same syntactic environment, in place of the form.

     An example will make this clear.  Suppose we wanted to define a
     simple `loop-until' keyword equivalent to
          (define-syntax loop-until
            (syntax-rules ()
              ((loop-until id init test return step)
               (letrec ((loop
                         (lambda (id)
                           (if test return (loop step)))))
                 (loop init)))))

     The following attempt at defining `loop-until' has a subtle bug:
          (define-syntax loop-until
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (test (cadddr exp))
                     (return (cadddr (cdr exp)))
                     (step (cadddr (cddr exp)))
                     (close
                      (lambda (exp free)
                        (make-syntactic-closure env free exp))))
                 `(letrec ((loop
                            (lambda (,id)
                              (if ,(close test (list id))
                                  ,(close return (list id))
                                  (loop ,(close step (list id)))))))
                    (loop ,(close init '())))))))

     This definition appears to take all of the proper precautions to
     prevent unintended captures.  It carefully closes the
     subexpressions in their original syntactic environment and it
     leaves the `id' identifier free in the `test', `return', and
     `step' expressions, so that it will be captured by the binding
     introduced by the `lambda' expression.  Unfortunately it uses the
     identifiers `if' and `loop' within that `lambda' expression, so if
     the user of `loop-until' just happens to use, say, `if' for the
     identifier, it will be inadvertently captured.

     The syntactic environment that `if' and `loop' want to be exposed
     to is the one just outside the `lambda' expression: before the
     user's identifier is added to the syntactic environment, but after
     the identifier loop has been added.
     `capture-syntactic-environment' captures exactly that environment
     as follows:
          (define-syntax loop-until
            (transformer
             (lambda (exp env)
               (let ((id (cadr exp))
                     (init (caddr exp))
                     (test (cadddr exp))
                     (return (cadddr (cdr exp)))
                     (step (cadddr (cddr exp)))
                     (close
                      (lambda (exp free)
                        (make-syntactic-closure env free exp))))
                 `(letrec ((loop
                            ,(capture-syntactic-environment
                              (lambda (env)
                                `(lambda (,id)
                                   (,(make-syntactic-closure env '() `if)
                                    ,(close test (list id))
                                    ,(close return (list id))
                                    (,(make-syntactic-closure env '()
                                                              `loop)
                                     ,(close step (list id)))))))))
                    (loop ,(close init '())))))))

     In this case, having captured the desired syntactic environment,
     it is convenient to construct syntactic closures of the
     identifiers `if' and the `loop' and use them in the body of the
     `lambda'.

     A common use of `capture-syntactic-environment' is to get the
     transformer environment of a macro transformer:
          (transformer
           (lambda (exp env)
             (capture-syntactic-environment
              (lambda (transformer-env)
                ...))))

Identifiers
...........

  This section describes the procedures that create and manipulate
identifiers.  Previous syntactic closure proposals did not have an
identifier data type - they just used symbols.  The identifier data
type extends the syntactic closures facility to be compatible with the
high-level `syntax-rules' facility.

  As discussed earlier, an identifier is either a symbol or an "alias".
An alias is implemented as a syntactic closure whose "form" is an
identifier:
     (make-syntactic-closure env '() 'a)
        => an "alias"

  Aliases are implemented as syntactic closures because they behave just
like syntactic closures most of the time.  The difference is that an
alias may be bound to a new value (for example by `lambda' or
`let-syntax'); other syntactic closures may not be used this way.  If
an alias is bound, then within the scope of that binding it is looked
up in the syntactic environment just like any other identifier.

  Aliases are used in the implementation of the high-level facility
`syntax-rules'.  A macro transformer created by `syntax-rules' uses a
template to generate its output form, substituting subforms of the
input form into the template.  In a syntactic closures implementation,
all of the symbols in the template are replaced by aliases closed in
the transformer environment, while the output form itself is closed in
the usage environment.  This guarantees that the macro transformation
is hygienic, without requiring the transformer to know the syntactic
roles of the substituted input subforms.

 - Function: identifier? object
     Returns `#t' if OBJECT is an identifier, otherwise returns `#f'.
     Examples:
          (identifier? 'a)
             => #t
          (identifier? (make-syntactic-closure env '() 'a))
             => #t
          (identifier? "a")
             => #f
          (identifier? #\a)
             => #f
          (identifier? 97)
             => #f
          (identifier? #f)
             => #f
          (identifier? '(a))
             => #f
          (identifier? '#(a))
             => #f

     The predicate `eq?' is used to determine if two identifers are
     "the same".  Thus `eq?' can be used to compare identifiers exactly
     as it would be used to compare symbols.  Often, though, it is
     useful to know whether two identifiers "mean the same thing".  For
     example, the `cond' macro uses the symbol `else' to identify the
     final clause in the conditional.  A macro transformer for `cond'
     cannot just look for the symbol `else', because the `cond' form
     might be the output of another macro transformer that replaced the
     symbol `else' with an alias.  Instead the transformer must look
     for an identifier that "means the same thing" in the usage
     environment as the symbol `else' means in the transformer
     environment.

 - Function: identifier=? environment1 identifier1 environment2
          identifier2
     ENVIRONMENT1 and ENVIRONMENT2 must be syntactic environments, and
     IDENTIFIER1 and IDENTIFIER2 must be identifiers.  `identifier=?'
     returns `#t' if the meaning of IDENTIFIER1 in ENVIRONMENT1 is the
     same as that of IDENTIFIER2 in ENVIRONMENT2, otherwise it returns
     `#f'.  Examples:

          (let-syntax
              ((foo
                (transformer
                 (lambda (form env)
                   (capture-syntactic-environment
                    (lambda (transformer-env)
                      (identifier=? transformer-env 'x env 'x)))))))
            (list (foo)
                  (let ((x 3))
                    (foo))))
             => (#t #f)

          (let-syntax ((bar foo))
            (let-syntax
                ((foo
                  (transformer
                   (lambda (form env)
                     (capture-syntactic-environment
                      (lambda (transformer-env)
                        (identifier=? transformer-env 'foo
                                      env (cadr form))))))))
              (list (foo foo)
                    (foobar))))
             => (#f #t)

Acknowledgements
................

  The syntactic closures facility was invented by Alan Bawden and
Jonathan Rees.  The use of aliases to implement `syntax-rules' was
invented by Alan Bawden (who prefers to call them "synthetic names").
Much of this proposal is derived from an earlier proposal by Alan
Bawden.


File: slib.info,  Node: Syntax-Case Macros,  Next: Fluid-Let,  Prev: Syntactic Closures,  Up: Scheme Syntax Extension Packages

Syntax-Case Macros
==================

  `(require 'syntax-case)'

 - Function: macro:expand expression
 - Function: syncase:expand expression
     Returns scheme code with the macros and derived expression types of
     EXPRESSION expanded to primitive expression types.

 - Function: macro:eval expression
 - Function: syncase:eval expression
     `macro:eval' returns the value of EXPRESSION in the current top
     level environment.  EXPRESSION can contain macro definitions.
     Side effects of EXPRESSION will affect the top level environment.

 - Procedure: macro:load filename
 - Procedure: syncase:load filename
     FILENAME should be a string.  If filename names an existing file,
     the `macro:load' procedure reads Scheme source code expressions and
     definitions from the file and evaluates them sequentially.  These
     source code expressions and definitions may contain macro
     definitions.  The `macro:load' procedure does not affect the
     values returned by `current-input-port' and `current-output-port'.

  This is version 2.1 of `syntax-case', the low-level macro facility
proposed and implemented by Robert Hieb and R. Kent Dybvig.

  This version is further adapted by Harald Hanche-Olsen <hanche @
imf.unit.no> to make it compatible with, and easily usable with, SLIB.
Mainly, these adaptations consisted of:

   * Removing white space from `expand.pp' to save space in the
     distribution.  This file is not meant for human readers anyway...

   * Removed a couple of Chez scheme dependencies.

   * Renamed global variables used to minimize the possibility of name
     conflicts.

   * Adding an SLIB-specific initialization file.

   * Removing a couple extra files, most notably the documentation (but
     see below).

  If you wish, you can see exactly what changes were done by reading the
shell script in the file `syncase.sh'.

  The two PostScript files were omitted in order to not burden the SLIB
distribution with them.  If you do intend to use `syntax-case',
however, you should get these files and print them out on a PostScript
printer.  They are available with the original `syntax-case'
distribution by anonymous FTP in
`cs.indiana.edu:/pub/scheme/syntax-case'.

  In order to use syntax-case from an interactive top level, execute:
     (require 'syntax-case)
     (require 'repl)
     (repl:top-level macro:eval)
  See the section Repl (*note Repl::) for more information.

  To check operation of syntax-case get
`cs.indiana.edu:/pub/scheme/syntax-case', and type
     (require 'syntax-case)
     (syncase:sanity-check)

  Beware that `syntax-case' takes a long time to load - about 20s on a
SPARCstation SLC (with SCM) and about 90s on a Macintosh SE/30 (with
Gambit).

Notes
-----

  All R4RS syntactic forms are defined, including `delay'.  Along with
`delay' are simple definitions for `make-promise' (into which `delay'
expressions expand) and `force'.

  `syntax-rules' and `with-syntax' (described in `TR356') are defined.

  `syntax-case' is actually defined as a macro that expands into calls
to the procedure `syntax-dispatch' and the core form `syntax-lambda';
do not redefine these names.

  Several other top-level bindings not documented in TR356 are created:
   * the "hooks" in `hooks.ss'

   * the `build-' procedures in `output.ss'

   * `expand-syntax' (the expander)

  The syntax of define has been extended to allow `(define ID)', which
assigns ID to some unspecified value.

  We have attempted to maintain R4RS compatibility where possible.  The
incompatibilities should be confined to `hooks.ss'.  Please let us know
if there is some incompatibility that is not flagged as such.

  Send bug reports, comments, suggestions, and questions to Kent Dybvig
(dyb @ iuvax.cs.indiana.edu).

Note from maintainer
--------------------

  Included with the `syntax-case' files was `structure.scm' which
defines a macro `define-structure'.  There is no documentation for this
macro and it is not used by any code in SLIB.


File: slib.info,  Node: Fluid-Let,  Next: Yasos,  Prev: Syntax-Case Macros,  Up: Scheme Syntax Extension Packages

Fluid-Let
=========

  `(require 'fluid-let)'

 - Syntax: fluid-let `(BINDINGS ...)' FORMS...

     (fluid-let ((VARIABLE INIT) ...)
        EXPRESSION EXPRESSION ...)

  The INITs are evaluated in the current environment (in some
unspecified order), the current values of the VARIABLEs are saved, the
results are assigned to the VARIABLEs, the EXPRESSIONs are evaluated
sequentially in the current environment, the VARIABLEs are restored to
their original values, and the value of the last EXPRESSION is returned.

  The syntax of this special form is similar to that of `let', but
`fluid-let' temporarily rebinds existing VARIABLEs.  Unlike `let',
`fluid-let' creates no new bindings; instead it _assigns_ the values of
each INIT to the binding (determined by the rules of lexical scoping)
of its corresponding VARIABLE.


File: slib.info,  Node: Yasos,  Prev: Fluid-Let,  Up: Scheme Syntax Extension Packages

Yasos
=====

  `(require 'oop)' or `(require 'yasos)'

  `Yet Another Scheme Object System' is a simple object system for
Scheme based on the paper by Norman Adams and Jonathan Rees: `Object
Oriented Programming in Scheme', Proceedings of the 1988 ACM Conference
on LISP and Functional Programming, July 1988 [ACM #552880].

  Another reference is:

  Ken Dickey.  Scheming with Objects `AI Expert' Volume 7, Number 10
(October 1992), pp. 24-33.

* Menu:

* Yasos terms::                 Definitions and disclaimer.
* Yasos interface::             The Yasos macros and procedures.
* Setters::                     Dylan-like setters in Yasos.
* Yasos examples::              Usage of Yasos and setters.


File: slib.info,  Node: Yasos terms,  Next: Yasos interface,  Prev: Yasos,  Up: Yasos

Terms
-----

"Object"
     Any Scheme data object.

"Instance"
     An instance of the OO system; an "object".

"Operation"
     A METHOD.

_Notes:_
     The object system supports multiple inheritance.  An instance can
     inherit from 0 or more ancestors.  In the case of multiple
     inherited operations with the same identity, the operation used is
     that from the first ancestor which contains it (in the ancestor
     `let').  An operation may be applied to any Scheme data
     object--not just instances.  As code which creates instances is
     just code, there are no "classes" and no meta-ANYTHING.  Method
     dispatch is by a procedure call a la CLOS rather than by `send'
     syntax a la Smalltalk.

_Disclaimer:_
     There are a number of optimizations which can be made.  This
     implementation is expository (although performance should be quite
     reasonable).  See the L&FP paper for some suggestions.


File: slib.info,  Node: Yasos interface,  Next: Setters,  Prev: Yasos terms,  Up: Yasos

Interface
---------

 - Syntax: define-operation `('opname self arg ...`)' DEFAULT-BODY
     Defines a default behavior for data objects which don't handle the
     operation OPNAME.  The default behavior (for an empty
     DEFAULT-BODY) is to generate an error.

 - Syntax: define-predicate opname?
     Defines a predicate OPNAME?, usually used for determining the
     "type" of an object, such that `(OPNAME? OBJECT)' returns `#t' if
     OBJECT has an operation OPNAME? and `#f' otherwise.

 - Syntax: object `((NAME SELF ARG ...) BODY)' ...
     Returns an object (an instance of the object system) with
     operations.  Invoking `(NAME OBJECT ARG ...' executes the BODY of
     the OBJECT with SELF bound to OBJECT and with argument(s) ARG....

 - Syntax: object-with-ancestors `(('ancestor1 init1`)' ...`)'
          operation ...
     A `let'-like form of `object' for multiple inheritance.  It
     returns an object inheriting the behaviour of ANCESTOR1 etc.  An
     operation will be invoked in an ancestor if the object itself does
     not provide such a method.  In the case of multiple inherited
     operations with the same identity, the operation used is the one
     found in the first ancestor in the ancestor list.

 - Syntax: operate-as component operation self arg ...
     Used in an operation definition (of SELF) to invoke the OPERATION
     in an ancestor COMPONENT but maintain the object's identity.  Also
     known as "send-to-super".

 - Procedure: print obj port
     A default `print' operation is provided which is just `(format
     PORT OBJ)' (*note Format::) for non-instances and prints OBJ
     preceded by `#<INSTANCE>' for instances.

 - Function: size obj
     The default method returns the number of elements in OBJ if it is
     a vector, string or list, `2' for a pair, `1' for a character and
     by default id an error otherwise.  Objects such as collections
     (*note Collections::) may override the default in an obvious way.


File: slib.info,  Node: Setters,  Next: Yasos examples,  Prev: Yasos interface,  Up: Yasos

Setters
-------

  "Setters" implement "generalized locations" for objects associated
with some sort of mutable state.  A "getter" operation retrieves a
value from a generalized location and the corresponding setter
operation stores a value into the location.  Only the getter is named -
the setter is specified by a procedure call as below.  (Dylan uses
special syntax.)  Typically, but not necessarily, getters are access
operations to extract values from Yasos objects (*note Yasos::).
Several setters are predefined, corresponding to getters `car', `cdr',
`string-ref' and `vector-ref' e.g., `(setter car)' is equivalent to
`set-car!'.

  This implementation of setters is similar to that in Dylan(TM)
(`Dylan: An object-oriented dynamic language', Apple Computer Eastern
Research and Technology).  Common LISP provides similar facilities
through `setf'.

 - Function: setter getter
     Returns the setter for the procedure GETTER.  E.g., since
     `string-ref' is the getter corresponding to a setter which is
     actually `string-set!':
          (define foo "foo")
          ((setter string-ref) foo 0 #\F) ; set element 0 of foo
          foo => "Foo"

 - Syntax: set place new-value
     If PLACE is a variable name, `set' is equivalent to `set!'.
     Otherwise, PLACE must have the form of a procedure call, where the
     procedure name refers to a getter and the call indicates an
     accessible generalized location, i.e., the call would return a
     value.  The return value of `set' is usually unspecified unless
     used with a setter whose definition guarantees to return a useful
     value.
          (set (string-ref foo 2) #\O)  ; generalized location with getter
          foo => "FoO"
          (set foo "foo")               ; like set!
          foo => "foo"

 - Procedure: add-setter getter setter
     Add procedures GETTER and SETTER to the (inaccessible) list of
     valid setter/getter pairs.  SETTER implements the store operation
     corresponding to the GETTER access operation for the relevant
     state.  The return value is unspecified.

 - Procedure: remove-setter-for getter
     Removes the setter corresponding to the specified GETTER from the
     list of valid setters.  The return value is unspecified.

 - Syntax: define-access-operation getter-name
     Shorthand for a Yasos `define-operation' defining an operation
     GETTER-NAME that objects may support to return the value of some
     mutable state.  The default operation is to signal an error.  The
     return value is unspecified.


File: slib.info,  Node: Yasos examples,  Prev: Setters,  Up: Yasos

Examples
--------

     ;;; These definitions for PRINT and SIZE are
     ;;; already supplied by
     (require 'yasos)
     
     (define-operation (print obj port)
       (format port
               (if (instance? obj) "#<instance>" "~s")
               obj))
     
     (define-operation (size obj)
       (cond
        ((vector? obj) (vector-length obj))
        ((list?   obj) (length obj))
        ((pair?   obj) 2)
        ((string? obj) (string-length obj))
        ((char?   obj) 1)
        (else
         (error "Operation not supported: size" obj))))
     
     (define-predicate cell?)
     (define-operation (fetch obj))
     (define-operation (store! obj newValue))
     
     (define (make-cell value)
       (object
        ((cell? self) #t)
        ((fetch self) value)
        ((store! self newValue)
         (set! value newValue)
         newValue)
        ((size self) 1)
        ((print self port)
         (format port "#<Cell: ~s>" (fetch self)))))
     
     (define-operation (discard obj value)
       (format #t "Discarding ~s~%" value))
     
     (define (make-filtered-cell value filter)
       (object-with-ancestors
        ((cell (make-cell value)))
        ((store! self newValue)
        (if (filter newValue)
            (store! cell newValue)
            (discard self newValue)))))
     
     (define-predicate array?)
     (define-operation (array-ref array index))
     (define-operation (array-set! array index value))
     
     (define (make-array num-slots)
       (let ((anArray (make-vector num-slots)))
         (object
          ((array? self) #t)
          ((size self) num-slots)
          ((array-ref self index)
           (vector-ref  anArray index))
          ((array-set! self index newValue)
           (vector-set! anArray index newValue))
          ((print self port)
           (format port "#<Array ~s>" (size self))))))
     
     (define-operation (position obj))
     (define-operation (discarded-value obj))
     
     (define (make-cell-with-history value filter size)
       (let ((pos 0) (most-recent-discard #f))
         (object-with-ancestors
          ((cell (make-filtered-call value filter))
           (sequence (make-array size)))
          ((array? self) #f)
          ((position self) pos)
          ((store! self newValue)
           (operate-as cell store! self newValue)
           (array-set! self pos newValue)
           (set! pos (+ pos 1)))
          ((discard self value)
           (set! most-recent-discard value))
          ((discarded-value self) most-recent-discard)
          ((print self port)
           (format port "#<Cell-with-history ~s>"
                   (fetch self))))))
     
     (define-access-operation fetch)
     (add-setter fetch store!)
     (define foo (make-cell 1))
     (print foo #f)
     => "#<Cell: 1>"
     (set (fetch foo) 2)
     =>
     (print foo #f)
     => "#<Cell: 2>"
     (fetch foo)
     => 2


File: slib.info,  Node: Textual Conversion Packages,  Next: Mathematical Packages,  Prev: Scheme Syntax Extension Packages,  Up: Top

Textual Conversion Packages
***************************

* Menu:

* Precedence Parsing::
* Format::                      Common-Lisp Format
* Standard Formatted I/O::      Posix printf and scanf
* Programs and Arguments::
* HTML::                        Generating                                    |
* HTML Tables::                 Databases meet HTML
* HTTP and CGI::                Serve WWW sites
* Parsing HTML::                                                              |
* URI::                         Uniform Resource Identifier
* Printing Scheme::             Nicely
* Time and Date::
* Schmooz::                     Documentation markup for Scheme programs


File: slib.info,  Node: Precedence Parsing,  Next: Format,  Prev: Textual Conversion Packages,  Up: Textual Conversion Packages

Precedence Parsing
==================

  `(require 'precedence-parse)' or `(require 'parse)'

This package implements:

   * a Pratt style precedence parser;

   * a "tokenizer" which congeals tokens according to assigned classes
     of constituent characters;

   * procedures giving direct control of parser rulesets;

   * procedures for higher level specification of rulesets.

* Menu:

* Precedence Parsing Overview::
* Ruleset Definition and Use::
* Token definition::
* Nud and Led Definition::
* Grammar Rule Definition::


File: slib.info,  Node: Precedence Parsing Overview,  Next: Ruleset Definition and Use,  Prev: Precedence Parsing,  Up: Precedence Parsing

Precedence Parsing Overview
---------------------------

This package offers improvements over previous parsers.

   * Common computer language constructs are concisely specified.

   * Grammars can be changed dynamically.  Operators can be assigned
     different meanings within a lexical context.

   * Rulesets don't need compilation.  Grammars can be changed
     incrementally.

   * Operator precedence is specified by integers.

   * All possibilities of bad input are handled (1) and return as much
     structure as was parsed when the error occured; The symbol `?' is
     substituted for missing input.

Here are the higher-level syntax types and an example of each.
Precedence considerations are omitted for clarity.  See *Note Grammar
Rule Definition:: for full details.

 - Grammar: nofix bye exit
          bye
     calls the function `exit' with no arguments.

 - Grammar: prefix - negate
          - 42
     Calls the function `negate' with the argument `42'.

 - Grammar: infix - difference
          x - y
     Calls the function `difference' with arguments `x' and `y'.

 - Grammar: nary + sum
          x + y + z
     Calls the function `sum' with arguments `x', `y', and `y'.

 - Grammar: postfix ! factorial
          5 !
     Calls the function `factorial' with the argument `5'.

 - Grammar: prestfix set set!
          set foo bar
     Calls the function `set!' with the arguments `foo' and `bar'.

 - Grammar: commentfix /* */
          /* almost any text here */
     Ignores the comment delimited by `/*' and `*/'.

 - Grammar: matchfix { list }
          {0, 1, 2}
     Calls the function `list' with the arguments `0', `1', and `2'.

 - Grammar: inmatchfix ( funcall )
          f(x, y)
     Calls the function `funcall' with the arguments `f', `x', and `y'.

 - Grammar: delim ;
          set foo bar;
     delimits the extent of the restfix operator `set'.

  ---------- Footnotes ----------

  (1) How do I know this?  I parsed 250kbyte of random input (an e-mail
file) with a non-trivial grammar utilizing all constructs.


File: slib.info,  Node: Ruleset Definition and Use,  Next: Token definition,  Prev: Precedence Parsing Overview,  Up: Precedence Parsing

Ruleset Definition and Use
--------------------------

 - Variable: *syn-defs*
     A grammar is built by one or more calls to `prec:define-grammar'.
     The rules are appended to *SYN-DEFS*.  The value of *SYN-DEFS* is
     the grammar suitable for passing as an argument to `prec:parse'.

 - Constant: *syn-ignore-whitespace*
     Is a nearly empty grammar with whitespace characters set to group
     0, which means they will not be made into tokens.  Most rulesets
     will want to start with `*syn-ignore-whitespace*'

In order to start defining a grammar, either

     (set! *syn-defs* '())

or

     (set! *syn-defs* *syn-ignore-whitespace*)

 - Function: prec:define-grammar rule1 ...
     Appends RULE1 ... to *SYN-DEFS*.  `prec:define-grammar' is used to
     define both the character classes and rules for tokens.

Once your grammar is defined, save the value of `*syn-defs*' in a
variable (for use when calling `prec:parse').

     (define my-ruleset *syn-defs*)

 - Function: prec:parse ruleset delim
 - Function: prec:parse ruleset delim port
     The RULESET argument must be a list of rules as constructed by
     `prec:define-grammar' and extracted from *SYN-DEFS*.

     The token DELIM may be a character, symbol, or string.  A
     character DELIM argument will match only a character token; i.e. a
     character for which no token-group is assigned.  A symbols or
     string will match only a token string; i.e. a token resulting from
     a token group.

     `prec:parse' reads a RULESET grammar expression delimited by DELIM
     from the given input PORT.  `prec:parse' returns the next object
     parsable from the given input PORT, updating PORT to point to the
     first character past the end of the external representation of the
     object.

     If an end of file is encountered in the input before any
     characters are found that can begin an object, then an end of file
     object is returned.  If a delimiter (such as DELIM) is found
     before any characters are found that can begin an object, then
     `#f' is returned.

     The PORT argument may be omitted, in which case it defaults to the
     value returned by `current-input-port'.  It is an error to parse
     from a closed port.


File: slib.info,  Node: Token definition,  Next: Nud and Led Definition,  Prev: Ruleset Definition and Use,  Up: Precedence Parsing

Token definition
----------------

 - Function: tok:char-group group chars chars-proc
     The argument CHARS may be a single character, a list of
     characters, or a string.  Each character in CHARS is treated as
     though `tok:char-group' was called with that character alone.

     The argument CHARS-PROC must be a procedure of one argument, a
     list of characters.  After `tokenize' has finished accumulating
     the characters for a token, it calls CHARS-PROC with the list of
     characters.  The value returned is the token which `tokenize'
     returns.

     The argument GROUP may be an exact integer or a procedure of one
     character argument.  The following discussion concerns the
     treatment which the tokenizing routine, `tokenize', will accord to
     characters on the basis of their groups.

     When GROUP is a non-zero integer, characters whose group number is
     equal to or exactly one less than GROUP will continue to
     accumulate.  Any other character causes the accumulation to stop
     (until a new token is to be read).

     The GROUP of zero is special.  These characters are ignored when
     parsed pending a token, and stop the accumulation of token
     characters when the accumulation has already begun.  Whitespace
     characters are usually put in group 0.

     If GROUP is a procedure, then, when triggerd by the occurence of
     an initial (no accumulation) CHARS character, this procedure will
     be repeatedly called with each successive character from the input
     stream until the GROUP procedure returns a non-false value.

The following convenient constants are provided for use with
`tok:char-group'.

 - Constant: tok:decimal-digits
     Is the string `"0123456789"'.

 - Constant: tok:upper-case
     Is the string consisting of all upper-case letters
     ("ABCDEFGHIJKLMNOPQRSTUVWXYZ").

 - Constant: tok:lower-case
     Is the string consisting of all lower-case letters
     ("abcdefghijklmnopqrstuvwxyz").

 - Constant: tok:whitespaces
     Is the string consisting of all characters between 0 and 255 for
     which `char-whitespace?' returns true.


File: slib.info,  Node: Nud and Led Definition,  Next: Grammar Rule Definition,  Prev: Token definition,  Up: Precedence Parsing

Nud and Led Definition
----------------------

  This section describes advanced features.  You can skip this section
on first reading.

The "Null Denotation" (or "nud") of a token is the procedure and
arguments applying for that token when "Left", an unclaimed parsed
expression is not extant.

The "Left Denotation" (or "led") of a token is the procedure,
arguments, and lbp applying for that token when there is a "Left", an
unclaimed parsed expression.

In his paper,

     Pratt, V. R.  Top Down Operator Precendence.  `SIGACT/SIGPLAN
     Symposium on Principles of Programming Languages', Boston, 1973,
     pages 41-51

  the "left binding power" (or "lbp") was an independent property of
tokens.  I think this was done in order to allow tokens with NUDs but
not LEDs to also be used as delimiters, which was a problem for
statically defined syntaxes.  It turns out that _dynamically binding_
NUDs and LEDs allows them independence.

For the rule-defining procedures that follow, the variable TK may be a
character, string, or symbol, or a list composed of characters,
strings, and symbols.  Each element of TK is treated as though the
procedure were called for each element.

Character TK arguments will match only character tokens; i.e.
characters for which no token-group is assigned.  Symbols and strings
will both match token strings; i.e. tokens resulting from token groups.

 - Function: prec:make-nud tk sop arg1 ...
     Returns a rule specifying that SOP be called when TK is parsed.
     If SOP is a procedure, it is called with TK and ARG1 ... as its
     arguments; the resulting value is incorporated into the expression
     being built.  Otherwise, `(list SOP ARG1 ...)' is incorporated.

If no NUD has been defined for a token; then if that token is a string,
it is converted to a symbol and returned; if not a string, the token is
returned.

 - Function: prec:make-led tk sop arg1 ...
     Returns a rule specifying that SOP be called when TK is parsed and
     LEFT has an unclaimed parsed expression.  If SOP is a procedure,
     it is called with LEFT, TK, and ARG1 ... as its arguments; the
     resulting value is incorporated into the expression being built.
     Otherwise, LEFT is incorporated.

If no LED has been defined for a token, and LEFT is set, the parser
issues a warning.


File: slib.info,  Node: Grammar Rule Definition,  Prev: Nud and Led Definition,  Up: Precedence Parsing

Grammar Rule Definition
-----------------------

Here are procedures for defining rules for the syntax types introduced
in *Note Precedence Parsing Overview::.

For the rule-defining procedures that follow, the variable TK may be a
character, string, or symbol, or a list composed of characters,
strings, and symbols.  Each element of TK is treated as though the
procedure were called for each element.

For procedures prec:delim, ..., prec:prestfix, if the SOP argument is
`#f', then the token which triggered this rule is converted to a symbol
and returned.  A false SOP argument to the procedures prec:commentfix,
prec:matchfix, or prec:inmatchfix has a different meaning.

Character TK arguments will match only character tokens; i.e.
characters for which no token-group is assigned.  Symbols and strings
will both match token strings; i.e. tokens resulting from token groups.

 - Function: prec:delim tk
     Returns a rule specifying that TK should not be returned from
     parsing; i.e. TK's function is purely syntactic.  The end-of-file
     is always treated as a delimiter.

 - Function: prec:nofix tk sop
     Returns a rule specifying the following actions take place when TK
     is parsed:
        * If SOP is a procedure, it is called with no arguments; the
          resulting value is incorporated into the expression being
          built.  Otherwise, the list of SOP is incorporated.

 - Function: prec:prefix tk sop bp rule1 ...
     Returns a rule specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * `prec:parse1' is called with binding-power BP.

        * If SOP is a procedure, it is called with the expression
          returned from `prec:parse1'; the resulting value is
          incorporated into the expression being built.  Otherwise, the
          list of SOP and the expression returned from `prec:parse1' is
          incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

 - Function: prec:infix tk sop lbp bp rule1 ...
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * One expression is parsed with binding-power LBP.  If instead a
          delimiter is encountered, a warning is issued.

        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expression; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of SOP,
          the LEFT expression, and the parsed expression is
          incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

 - Function: prec:nary tk sop bp
     Returns a rule declaring the left-binding-precedence of the token
     TK is BP and specifying the following actions take place when TK
     is parsed:
        * Expressions are parsed with binding-power BP as far as they
          are interleaved with the token TK.

        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expressions; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of SOP,
          the LEFT expression, and the parsed expressions is
          incorporated.

 - Function: prec:postfix tk sop lbp
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * If SOP is a procedure, it is called with the LEFT expression;
          the resulting value is incorporated into the expression being
          built.  Otherwise, the list of SOP and the LEFT expression is
          incorporated.

 - Function: prec:prestfix tk sop bp rule1 ...
     Returns a rule specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * Expressions are parsed with binding-power BP until a
          delimiter is reached.

        * If SOP is a procedure, it is applied to the list of parsed
          expressions; the resulting value is incorporated into the
          expression being built.  Otherwise, the list of SOP and the
          parsed expressions is incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

 - Function: prec:commentfix tk stp match rule1 ...
     Returns rules specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * Characters are read until and end-of-file or a sequence of
          characters is read which matches the _string_ MATCH.

        * If STP is a procedure, it is called with the string of all
          that was read between the TK and MATCH (exclusive).

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

     Parsing of commentfix syntax differs from the others in several
     ways.  It reads directly from input without tokenizing; It calls
     STP but does not return its value; nay any value.  I added the STP
     argument so that comment text could be echoed.

 - Function: prec:matchfix tk sop sep match rule1 ...
     Returns a rule specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * A rule declaring the token MATCH a delimiter takes effect.

        * Expressions are parsed with binding-power `0' until the token
          MATCH is reached.  If the token SEP does not appear between
          each pair of expressions parsed, a warning is issued.

        * If SOP is a procedure, it is applied to the list of parsed
          expressions; the resulting value is incorporated into the
          expression being built.  Otherwise, the list of SOP and the
          parsed expressions is incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.

 - Function: prec:inmatchfix tk sop sep match lbp rule1 ...
     Returns a rule declaring the left-binding-precedence of the token
     TK is LBP and specifying the following actions take place when TK
     is parsed:
        * The rules RULE1 ... augment and, in case of conflict, override
          rules currently in effect.

        * A rule declaring the token MATCH a delimiter takes effect.

        * Expressions are parsed with binding-power `0' until the token
          MATCH is reached.  If the token SEP does not appear between
          each pair of expressions parsed, a warning is issued.

        * If SOP is a procedure, it is applied to the list of LEFT and
          the parsed expressions; the resulting value is incorporated
          into the expression being built.  Otherwise, the list of SOP,
          the LEFT expression, and the parsed expressions is
          incorporated.

        * The ruleset in effect before TK was parsed is restored; RULE1
          ... are forgotten.


File: slib.info,  Node: Format,  Next: Standard Formatted I/O,  Prev: Precedence Parsing,  Up: Textual Conversion Packages

Format (version 3.0)
====================

  `(require 'format)'

* Menu:

* Format Interface::
* Format Specification::


File: slib.info,  Node: Format Interface,  Next: Format Specification,  Prev: Format,  Up: Format

Format Interface
----------------

 - Function: format destination format-string . arguments
     An almost complete implementation of Common LISP format description
     according to the CL reference book `Common LISP' from Guy L.
     Steele, Digital Press.  Backward compatible to most of the
     available Scheme format implementations.

     Returns `#t', `#f' or a string; has side effect of printing
     according to FORMAT-STRING.  If DESTINATION is `#t', the output is
     to the current output port and `#t' is returned.  If DESTINATION
     is `#f', a formatted string is returned as the result of the call.
     NEW: If DESTINATION is a string, DESTINATION is regarded as the
     format string; FORMAT-STRING is then the first argument and the
     output is returned as a string. If DESTINATION is a number, the
     output is to the current error port if available by the
     implementation. Otherwise DESTINATION must be an output port and
     `#t' is returned.

     FORMAT-STRING must be a string.  In case of a formatting error
     format returns `#f' and prints a message on the current output or
     error port.  Characters are output as if the string were output by
     the `display' function with the exception of those prefixed by a
     tilde (~).  For a detailed description of the FORMAT-STRING syntax
     please consult a Common LISP format reference manual.  For a test
     suite to verify this format implementation load `formatst.scm'.
     Please send bug reports to `lutzeb@cs.tu-berlin.de'.

     Note: `format' is not reentrant, i.e. only one `format'-call may
     be executed at a time.



File: slib.info,  Node: Format Specification,  Prev: Format Interface,  Up: Format

Format Specification (Format version 3.0)
-----------------------------------------

  Please consult a Common LISP format reference manual for a detailed
description of the format string syntax.  For a demonstration of the
implemented directives see `formatst.scm'.

  This implementation supports directive parameters and modifiers (`:'
and `@' characters). Multiple parameters must be separated by a comma
(`,').  Parameters can be numerical parameters (positive or negative),
character parameters (prefixed by a quote character (`''), variable
parameters (`v'), number of rest arguments parameter (`#'), empty and
default parameters.  Directive characters are case independent. The
general form of a directive is:

DIRECTIVE ::= ~{DIRECTIVE-PARAMETER,}[:][@]DIRECTIVE-CHARACTER

DIRECTIVE-PARAMETER ::= [ [-|+]{0-9}+ | 'CHARACTER | v | # ]

Implemented CL Format Control Directives
........................................

  Documentation syntax: Uppercase characters represent the corresponding
control directive characters. Lowercase characters represent control
directive parameter descriptions.

`~A'
     Any (print as `display' does).
    `~@A'
          left pad.

    `~MINCOL,COLINC,MINPAD,PADCHARA'
          full padding.

`~S'
     S-expression (print as `write' does).
    `~@S'
          left pad.

    `~MINCOL,COLINC,MINPAD,PADCHARS'
          full padding.

`~D'
     Decimal.
    `~@D'
          print number sign always.

    `~:D'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARD'
          padding.

`~X'
     Hexadecimal.
    `~@X'
          print number sign always.

    `~:X'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARX'
          padding.

`~O'
     Octal.
    `~@O'
          print number sign always.

    `~:O'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARO'
          padding.

`~B'
     Binary.
    `~@B'
          print number sign always.

    `~:B'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARB'
          padding.

`~NR'
     Radix N.
    `~N,MINCOL,PADCHAR,COMMACHARR'
          padding.

`~@R'
     print a number as a Roman numeral.

`~:@R'
     print a number as an "old fashioned" Roman numeral.

`~:R'
     print a number as an ordinal English number.

`~R'
     print a number as a cardinal English number.

`~P'
     Plural.
    `~@P'
          prints `y' and `ies'.

    `~:P'
          as `~P but jumps 1 argument backward.'

    `~:@P'
          as `~@P but jumps 1 argument backward.'

`~C'
     Character.
    `~@C'
          prints a character as the reader can understand it (i.e. `#\'
          prefixing).

    `~:C'
          prints a character as emacs does (eg. `^C' for ASCII 03).

`~F'
     Fixed-format floating-point (prints a flonum like MMM.NNN).
    `~WIDTH,DIGITS,SCALE,OVERFLOWCHAR,PADCHARF'

    `~@F'
          If the number is positive a plus sign is printed.

`~E'
     Exponential floating-point (prints a flonum like MMM.NNN`E'EE).
    `~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARE'

    `~@E'
          If the number is positive a plus sign is printed.

`~G'
     General floating-point (prints a flonum either fixed or
     exponential).
    `~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARG'

    `~@G'
          If the number is positive a plus sign is printed.

`~$'
     Dollars floating-point (prints a flonum in fixed with signs
     separated).
    `~DIGITS,SCALE,WIDTH,PADCHAR$'

    `~@$'
          If the number is positive a plus sign is printed.

    `~:@$'
          A sign is always printed and appears before the padding.

    `~:$'
          The sign appears before the padding.

`~%'
     Newline.
    `~N%'
          print N newlines.

`~&'
     print newline if not at the beginning of the output line.
    `~N&'
          prints `~&' and then N-1 newlines.

`~|'
     Page Separator.
    `~N|'
          print N page separators.

`~~'
     Tilde.
    `~N~'
          print N tildes.

`~'<newline>
     Continuation Line.
    `~:'<newline>
          newline is ignored, white space left.

    `~@'<newline>
          newline is left, white space ignored.

`~T'
     Tabulation.
    `~@T'
          relative tabulation.

    `~COLNUM,COLINCT'
          full tabulation.

`~?'
     Indirection (expects indirect arguments as a list).
    `~@?'
          extracts indirect arguments from format arguments.

`~(STR~)'
     Case conversion (converts by `string-downcase').
    `~:(STR~)'
          converts by `string-capitalize'.

    `~@(STR~)'
          converts by `string-capitalize-first'.

    `~:@(STR~)'
          converts by `string-upcase'.

`~*'
     Argument Jumping (jumps 1 argument forward).
    `~N*'
          jumps N arguments forward.

    `~:*'
          jumps 1 argument backward.

    `~N:*'
          jumps N arguments backward.

    `~@*'
          jumps to the 0th argument.

    `~N@*'
          jumps to the Nth argument (beginning from 0)

`~[STR0~;STR1~;...~;STRN~]'
     Conditional Expression (numerical clause conditional).
    `~N['
          take argument from N.

    `~@['
          true test conditional.

    `~:['
          if-else-then conditional.

    `~;'
          clause separator.

    `~:;'
          default clause follows.

`~{STR~}'
     Iteration (args come from the next argument (a list)). Iteration
     bounding is controlled by configuration variables
     FORMAT:ITERATION-BOUNDED and FORMAT:MAX-ITERATIONS.  With both
     variables default, a maximum of 100 iterations will be performed.
    `~N{'
          at most N iterations.

    `~:{'
          args from next arg (a list of lists).

    `~@{'
          args from the rest of arguments.

    `~:@{'
          args from the rest args (lists).

`~^'
     Up and out.
    `~N^'
          aborts if N = 0

    `~N,M^'
          aborts if N = M

    `~N,M,K^'
          aborts if N <= M <= K

Not Implemented CL Format Control Directives
............................................

`~:A'
     print `#f' as an empty list (see below).

`~:S'
     print `#f' as an empty list (see below).

`~<~>'
     Justification.

`~:^'
     (sorry I don't understand its semantics completely)

Extended, Replaced and Additional Control Directives
....................................................

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHD'

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHX'

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHO'

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHB'

`~N,MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHR'
     COMMAWIDTH is the number of characters between two comma
     characters.

`~I'
     print a R4RS complex number as `~F~@Fi' with passed parameters for
     `~F'.

`~Y'
     Pretty print formatting of an argument for scheme code lists.

`~K'
     Same as `~?.'

`~!'
     Flushes the output if format DESTINATION is a port.

`~_'
     Print a `#\space' character
    `~N_'
          print N `#\space' characters.

`~/'
     Print a `#\tab' character
    `~N/'
          print N `#\tab' characters.

`~NC'
     Takes N as an integer representation for a character. No arguments
     are consumed. N is converted to a character by `integer->char'.  N
     must be a positive decimal number.

`~:S'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~:A'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~Q'
     Prints information and a copyright notice on the format
     implementation.
    `~:Q'
          prints format version.

`~F, ~E, ~G, ~$'
     may also print number strings, i.e. passing a number as a string
     and format it accordingly.

Configuration Variables
.......................

  Format has some configuration variables at the beginning of
`format.scm' to suit the systems and users needs. There should be no
modification necessary for the configuration that comes with SLIB.  If
modification is desired the variable should be set after the format
code is loaded. Format detects automatically if the running scheme
system implements floating point numbers and complex numbers.

FORMAT:SYMBOL-CASE-CONV
     Symbols are converted by `symbol->string' so the case type of the
     printed symbols is implementation dependent.
     `format:symbol-case-conv' is a one arg closure which is either
     `#f' (no conversion), `string-upcase', `string-downcase' or
     `string-capitalize'. (default `#f')

FORMAT:IOBJ-CASE-CONV
     As FORMAT:SYMBOL-CASE-CONV but applies for the representation of
     implementation internal objects. (default `#f')

FORMAT:EXPCH
     The character prefixing the exponent value in `~E' printing.
     (default `#\E')

FORMAT:ITERATION-BOUNDED
     When `#t', a `~{...~}' control will iterate no more than the
     number of times specified by FORMAT:MAX-ITERATIONS regardless of
     the number of iterations implied by modifiers and arguments.  When
     `#f', a `~{...~}' control will iterate the number of times implied
     by modifiers and arguments, unless termination is forced by
     language or system limitations. (default `#t')

FORMAT:MAX-ITERATIONS
     The maximum number of iterations performed by a `~{...~}' control.
     Has effect only when FORMAT:ITERATION-BOUNDED is `#t'.  (default
     100)

Compatibility With Other Format Implementations
...............................................

SLIB format 2.x:
     See `format.doc'.

SLIB format 1.4:
     Downward compatible except for padding support and `~A', `~S',
     `~P', `~X' uppercase printing.  SLIB format 1.4 uses C-style
     `printf' padding support which is completely replaced by the CL
     `format' padding style.

MIT C-Scheme 7.1:
     Downward compatible except for `~', which is not documented
     (ignores all characters inside the format string up to a newline
     character).  (7.1 implements `~a', `~s', ~NEWLINE, `~~', `~%',
     numerical and variable parameters and `:/@' modifiers in the CL
     sense).

Elk 1.5/2.0:
     Downward compatible except for `~A' and `~S' which print in
     uppercase.  (Elk implements `~a', `~s', `~~', and `~%' (no
     directive parameters or modifiers)).

Scheme->C 01nov91:
     Downward compatible except for an optional destination parameter:
     S2C accepts a format call without a destination which returns a
     formatted string. This is equivalent to a #f destination in S2C.
     (S2C implements `~a', `~s', `~c', `~%', and `~~' (no directive
     parameters or modifiers)).

  This implementation of format is solely useful in the SLIB context
because it requires other components provided by SLIB.


File: slib.info,  Node: Standard Formatted I/O,  Next: Programs and Arguments,  Prev: Format,  Up: Textual Conversion Packages

Standard Formatted I/O
======================

* Menu:

* Standard Formatted Output::   'printf
* Standard Formatted Input::    'scanf

stdio
-----

  `(require 'stdio)'

  `require's `printf' and `scanf' and additionally defines the symbols:

 - Variable: stdin
     Defined to be `(current-input-port)'.

 - Variable: stdout
     Defined to be `(current-output-port)'.

 - Variable: stderr
     Defined to be `(current-error-port)'.


File: slib.info,  Node: Standard Formatted Output,  Next: Standard Formatted Input,  Prev: Standard Formatted I/O,  Up: Standard Formatted I/O

Standard Formatted Output
-------------------------

  `(require 'printf)'

 - Procedure: printf format arg1 ...
 - Procedure: fprintf port format arg1 ...
 - Procedure: sprintf str format arg1 ...
 - Procedure: sprintf #f format arg1 ...
 - Procedure: sprintf k format arg1 ...
     Each function converts, formats, and outputs its ARG1 ...
     arguments according to the control string FORMAT argument and
     returns the number of characters output.

     `printf' sends its output to the port `(current-output-port)'.
     `fprintf' sends its output to the port PORT.  `sprintf'
     `string-set!'s locations of the non-constant string argument STR
     to the output characters.

     Two extensions of `sprintf' return new strings.  If the first
     argument is `#f', then the returned string's length is as many
     characters as specified by the FORMAT and data; if the first
     argument is a non-negative integer K, then the length of the
     returned string is also bounded by K.

     The string FORMAT contains plain characters which are copied to
     the output stream, and conversion specifications, each of which
     results in fetching zero or more of the arguments ARG1 ....  The
     results are undefined if there are an insufficient number of
     arguments for the format.  If FORMAT is exhausted while some of the
     ARG1 ... arguments remain unused, the excess ARG1 ... arguments
     are ignored.

     The conversion specifications in a format string have the form:

          % [ FLAGS ] [ WIDTH ] [ . PRECISION ] [ TYPE ] CONVERSION

     An output conversion specifications consist of an initial `%'
     character followed in sequence by:

        * Zero or more "flag characters" that modify the normal
          behavior of the conversion specification.

         `-'
               Left-justify the result in the field.  Normally the
               result is right-justified.

         `+'
               For the signed `%d' and `%i' conversions and all inexact
               conversions, prefix a plus sign if the value is positive.

         ` '
               For the signed `%d' and `%i' conversions, if the result
               doesn't start with a plus or minus sign, prefix it with
               a space character instead.  Since the `+' flag ensures
               that the result includes a sign, this flag is ignored if
               both are specified.

         `#'
               For inexact conversions, `#' specifies that the result
               should always include a decimal point, even if no digits
               follow it.  For the `%g' and `%G' conversions, this also
               forces trailing zeros after the decimal point to be
               printed where they would otherwise be elided.

               For the `%o' conversion, force the leading digit to be
               `0', as if by increasing the precision.  For `%x' or
               `%X', prefix a leading `0x' or `0X' (respectively) to
               the result.  This doesn't do anything useful for the
               `%d', `%i', or `%u' conversions.  Using this flag
               produces output which can be parsed by the `scanf'
               functions with the `%i' conversion (*note Standard
               Formatted Input::).

         `0'
               Pad the field with zeros instead of spaces.  The zeros
               are placed after any indication of sign or base.  This
               flag is ignored if the `-' flag is also specified, or if
               a precision is specified for an exact converson.

        * An optional decimal integer specifying the "minimum field
          width".  If the normal conversion produces fewer characters
          than this, the field is padded (with spaces or zeros per the
          `0' flag) to the specified width.  This is a _minimum_ width;
          if the normal conversion produces more characters than this,
          the field is _not_ truncated.

          Alternatively, if the field width is `*', the next argument
          in the argument list (before the actual value to be printed)
          is used as the field width.  The width value must be an
          integer.  If the value is negative it is as though the `-'
          flag is set (see above) and the absolute value is used as the
          field width.

        * An optional "precision" to specify the number of digits to be
          written for numeric conversions and the maximum field width
          for string conversions.  The precision is specified by a
          period (`.') followed optionally by a decimal integer (which
          defaults to zero if omitted).

          Alternatively, if the precision is `.*', the next argument in
          the argument list (before the actual value to be printed) is
          used as the precision.  The value must be an integer, and is
          ignored if negative.  If you specify `*' for both the field
          width and precision, the field width argument precedes the
          precision argument.  The `.*' precision is an enhancement.  C
          library versions may not accept this syntax.

          For the `%f', `%e', and `%E' conversions, the precision
          specifies how many digits follow the decimal-point character.
          The default precision is `6'.  If the precision is
          explicitly `0', the decimal point character is suppressed.

          For the `%g' and `%G' conversions, the precision specifies how
          many significant digits to print.  Significant digits are the
          first digit before the decimal point, and all the digits
          after it.  If the precision is `0' or not specified for `%g'
          or `%G', it is treated like a value of `1'.  If the value
          being printed cannot be expressed accurately in the specified
          number of digits, the value is rounded to the nearest number
          that fits.

          For exact conversions, if a precision is supplied it
          specifies the minimum number of digits to appear; leading
          zeros are produced if necessary.  If a precision is not
          supplied, the number is printed with as many digits as
          necessary.  Converting an exact `0' with an explicit
          precision of zero produces no characters.

        * An optional one of `l', `h' or `L', which is ignored for
          numeric conversions.  It is an error to specify these
          modifiers for non-numeric conversions.

        * A character that specifies the conversion to be applied.

Exact Conversions
.................

    `b', `B'
          Print an integer as an unsigned binary number.

          _Note:_ `%b' and `%B' are SLIB extensions.

    `d', `i'
          Print an integer as a signed decimal number.  `%d' and `%i'
          are synonymous for output, but are different when used with
          `scanf' for input (*note Standard Formatted Input::).

    `o'
          Print an integer as an unsigned octal number.

    `u'
          Print an integer as an unsigned decimal number.

    `x', `X'
          Print an integer as an unsigned hexadecimal number.  `%x'
          prints using the digits `0123456789abcdef'.  `%X' prints
          using the digits `0123456789ABCDEF'.

Inexact Conversions
...................

    `f'
          Print a floating-point number in fixed-point notation.

    `e', `E'
          Print a floating-point number in exponential notation.  `%e'
          prints `e' between mantissa and exponont.  `%E' prints `E'
          between mantissa and exponont.

    `g', `G'
          Print a floating-point number in either fixed or exponential
          notation, whichever is more appropriate for its magnitude.
          Unless an `#' flag has been supplied, trailing zeros after a
          decimal point will be stripped off.  `%g' prints `e' between
          mantissa and exponont.  `%G' prints `E' between mantissa and
          exponent.

    `k', `K'
          Print a number like `%g', except that an SI prefix is output
          after the number, which is scaled accordingly.  `%K' outputs
          a space between number and prefix, `%k' does not.

Other Conversions
.................

    `c'
          Print a single character.  The `-' flag is the only one which
          can be specified.  It is an error to specify a precision.

    `s'
          Print a string.  The `-' flag is the only one which can be
          specified.  A precision specifies the maximum number of
          characters to output; otherwise all characters in the string
          are output.

    `a', `A'
          Print a scheme expression.  The `-' flag left-justifies the
          output.  The `#' flag specifies that strings and characters
          should be quoted as by `write' (which can be read using
          `read'); otherwise, output is as `display' prints.  A
          precision specifies the maximum number of characters to
          output; otherwise as many characters as needed are output.

          _Note:_ `%a' and `%A' are SLIB extensions.

    `%'
          Print a literal `%' character.  No argument is consumed.  It
          is an error to specify flags, field width, precision, or type
          modifiers with `%%'.


File: slib.info,  Node: Standard Formatted Input,  Prev: Standard Formatted Output,  Up: Standard Formatted I/O

Standard Formatted Input
------------------------

  `(require 'scanf)'

 - Function: scanf-read-list format
 - Function: scanf-read-list format port
 - Function: scanf-read-list format string

 - Macro: scanf format arg1 ...
 - Macro: fscanf port format arg1 ...
 - Macro: sscanf str format arg1 ...
     Each function reads characters, interpreting them according to the
     control string FORMAT argument.

     `scanf-read-list' returns a list of the items specified as far as
     the input matches FORMAT.  `scanf', `fscanf', and `sscanf' return
     the number of items successfully matched and stored.  `scanf',
     `fscanf', and `sscanf' also set the location corresponding to ARG1
     ... using the methods:

    symbol
          `set!'

    car expression
          `set-car!'

    cdr expression
          `set-cdr!'

    vector-ref expression
          `vector-set!'

    substring expression
          `substring-move-left!'

     The argument to a `substring' expression in ARG1 ... must be a
     non-constant string.  Characters will be stored starting at the
     position specified by the second argument to `substring'.  The
     number of characters stored will be limited by either the position
     specified by the third argument to `substring' or the length of the
     matched string, whichever is less.

     The control string, FORMAT, contains conversion specifications and
     other characters used to direct interpretation of input sequences.
     The control string contains:

        * White-space characters (blanks, tabs, newlines, or formfeeds)
          that cause input to be read (and discarded) up to the next
          non-white-space character.

        * An ordinary character (not `%') that must match the next
          character of the input stream.

        * Conversion specifications, consisting of the character `%', an
          optional assignment suppressing character `*', an optional
          numerical maximum-field width, an optional `l', `h' or `L'
          which is ignored, and a conversion code.


     Unless the specification contains the `n' conversion character
     (described below), a conversion specification directs the
     conversion of the next input field.  The result of a conversion
     specification is returned in the position of the corresponding
     argument points, unless `*' indicates assignment suppression.
     Assignment suppression provides a way to describe an input field
     to be skipped.  An input field is defined as a string of
     characters; it extends to the next inappropriate character or
     until the field width, if specified, is exhausted.

          _Note:_ This specification of format strings differs from the
          `ANSI C' and `POSIX' specifications.  In SLIB, white space
          before an input field is not skipped unless white space
          appears before the conversion specification in the format
          string.  In order to write format strings which work
          identically with `ANSI C' and SLIB, prepend whitespace to all
          conversion specifications except `[' and `c'.

     The conversion code indicates the interpretation of the input
     field; For a suppressed field, no value is returned.  The
     following conversion codes are legal:

    `%'
          A single % is expected in the input at this point; no value
          is returned.

    `d', `D'
          A decimal integer is expected.

    `u', `U'
          An unsigned decimal integer is expected.

    `o', `O'
          An octal integer is expected.

    `x', `X'
          A hexadecimal integer is expected.

    `i'
          An integer is expected.  Returns the value of the next input
          item, interpreted according to C conventions; a leading `0'
          implies octal, a leading `0x' implies hexadecimal; otherwise,
          decimal is assumed.

    `n'
          Returns the total number of bytes (including white space)
          read by `scanf'.  No input is consumed by `%n'.

    `f', `F', `e', `E', `g', `G'
          A floating-point number is expected.  The input format for
          floating-point numbers is an optionally signed string of
          digits, possibly containing a radix character `.', followed
          by an optional exponent field consisting of an `E' or an `e',
          followed by an optional `+', `-', or space, followed by an
          integer.

    `c', `C'
          WIDTH characters are expected.  The normal
          skip-over-white-space is suppressed in this case; to read the
          next non-space character, use `%1s'.  If a field width is
          given, a string is returned; up to the indicated number of
          characters is read.

    `s', `S'
          A character string is expected The input field is terminated
          by a white-space character.  `scanf' cannot read a null
          string.

    `['
          Indicates string data and the normal
          skip-over-leading-white-space is suppressed.  The left
          bracket is followed by a set of characters, called the
          scanset, and a right bracket; the input field is the maximal
          sequence of input characters consisting entirely of
          characters in the scanset.  `^', when it appears as the first
          character in the scanset, serves as a complement operator and
          redefines the scanset as the set of all characters not
          contained in the remainder of the scanset string.
          Construction of the scanset follows certain conventions.  A
          range of characters may be represented by the construct
          first-last, enabling `[0123456789]' to be expressed `[0-9]'.
          Using this convention, first must be lexically less than or
          equal to last; otherwise, the dash stands for itself.  The
          dash also stands for itself when it is the first or the last
          character in the scanset.  To include the right square
          bracket as an element of the scanset, it must appear as the
          first character (possibly preceded by a `^') of the scanset,
          in which case it will not be interpreted syntactically as the
          closing bracket.  At least one character must match for this
          conversion to succeed.

     The `scanf' functions terminate their conversions at end-of-file,
     at the end of the control string, or when an input character
     conflicts with the control string.  In the latter case, the
     offending character is left unread in the input stream.


File: slib.info,  Node: Programs and Arguments,  Next: HTML,  Prev: Standard Formatted I/O,  Up: Textual Conversion Packages

Program and Arguments
=====================

* Menu:

* Getopt::                      Command Line option parsing
* Command Line::                A command line reader for Scheme shells
* Parameter lists::             'parameters
* Getopt Parameter lists::      'getopt-parameters
* Filenames::                   'glob or 'filename
* Batch::                       'batch


File: slib.info,  Node: Getopt,  Next: Command Line,  Prev: Programs and Arguments,  Up: Programs and Arguments

Getopt
------

  `(require 'getopt)'

  This routine implements Posix command line argument parsing.  Notice
that returning values through global variables means that `getopt' is
_not_ reentrant.

 - Variable: *optind*
     Is the index of the current element of the command line.  It is
     initially one.  In order to parse a new command line or reparse an
     old one, *OPTING* must be reset.

 - Variable: *optarg*
     Is set by getopt to the (string) option-argument of the current
     option.

 - Procedure: getopt argc argv optstring
     Returns the next option letter in ARGV (starting from `(vector-ref
     argv *optind*)') that matches a letter in OPTSTRING.  ARGV is a
     vector or list of strings, the 0th of which getopt usually
     ignores. ARGC is the argument count, usually the length of ARGV.
     OPTSTRING is a string of recognized option characters; if a
     character is followed by a colon, the option takes an argument
     which may be immediately following it in the string or in the next
     element of ARGV.

     *OPTIND* is the index of the next element of the ARGV vector to be
     processed.  It is initialized to 1 by `getopt.scm', and `getopt'
     updates it when it finishes with each element of ARGV.

     `getopt' returns the next option character from ARGV that matches
     a character in OPTSTRING, if there is one that matches.  If the
     option takes an argument, `getopt' sets the variable *OPTARG* to
     the option-argument as follows:

        * If the option was the last character in the string pointed to
          by an element of ARGV, then *OPTARG* contains the next
          element of ARGV, and *OPTIND* is incremented by 2.  If the
          resulting value of *OPTIND* is greater than or equal to ARGC,
          this indicates a missing option argument, and `getopt'
          returns an error indication.

        * Otherwise, *OPTARG* is set to the string following the option
          character in that element of ARGV, and *OPTIND* is
          incremented by 1.

     If, when `getopt' is called, the string `(vector-ref argv
     *optind*)' either does not begin with the character `#\-' or is
     just `"-"', `getopt' returns `#f' without changing *OPTIND*.  If
     `(vector-ref argv *optind*)' is the string `"--"', `getopt'
     returns `#f' after incrementing *OPTIND*.

     If `getopt' encounters an option character that is not contained in
     OPTSTRING, it returns the question-mark `#\?' character.  If it
     detects a missing option argument, it returns the colon character
     `#\:' if the first character of OPTSTRING was a colon, or a
     question-mark character otherwise.  In either case, `getopt' sets
     the variable GETOPT:OPT to the option character that caused the
     error.

     The special option `"--"' can be used to delimit the end of the
     options; `#f' is returned, and `"--"' is skipped.

     RETURN VALUE

     `getopt' returns the next option character specified on the command
     line.  A colon `#\:' is returned if `getopt' detects a missing
     argument and the first character of OPTSTRING was a colon `#\:'.

     A question-mark `#\?' is returned if `getopt' encounters an option
     character not in OPTSTRING or detects a missing argument and the
     first character of OPTSTRING was not a colon `#\:'.

     Otherwise, `getopt' returns `#f' when all command line options
     have been parsed.

     Example:
          #! /usr/local/bin/scm
          ;;;This code is SCM specific.
          (define argv (program-arguments))
          (require 'getopt)
          
          (define opts ":a:b:cd")
          (let loop ((opt (getopt (length argv) argv opts)))
            (case opt
              ((#\a) (print "option a: " *optarg*))
              ((#\b) (print "option b: " *optarg*))
              ((#\c) (print "option c"))
              ((#\d) (print "option d"))
              ((#\?) (print "error" getopt:opt))
              ((#\:) (print "missing arg" getopt:opt))
              ((#f) (if (< *optind* (length argv))
                        (print "argv[" *optind* "]="
                               (list-ref argv *optind*)))
                    (set! *optind* (+ *optind* 1))))
            (if (< *optind* (length argv))
                (loop (getopt (length argv) argv opts))))
          
          (slib:exit)

Getopt-
-------

 - Function: getopt- argc argv optstring
     The procedure `getopt--' is an extended version of `getopt' which
     parses "long option names" of the form `--hold-the-onions' and
     `--verbosity-level=extreme'.  `Getopt--' behaves as `getopt'
     except for non-empty options beginning with `--'.

     Options beginning with `--' are returned as strings rather than
     characters.  If a value is assigned (using `=') to a long option,
     `*optarg*' is set to the value.  The `=' and value are not
     returned as part of the option string.

     No information is passed to `getopt--' concerning which long
     options should be accepted or whether such options can take
     arguments.  If a long option did not have an argument, `*optarg'
     will be set to `#f'.  The caller is responsible for detecting and
     reporting errors.

          (define opts ":-:b:")
          (define argc 5)
          (define argv '("foo" "-b9" "--f1" "--2=" "--g3=35234.342" "--"))
          (define *optind* 1)
          (define *optarg* #f)
          (require 'qp)
          (do ((i 5 (+ -1 i)))
              ((zero? i))
            (define opt (getopt-- argc argv opts))
            (print *optind* opt *optarg*)))
          -|
          2 #\b "9"
          3 "f1" #f
          4 "2" ""
          5 "g3" "35234.342"
          5 #f "35234.342"


File: slib.info,  Node: Command Line,  Next: Parameter lists,  Prev: Getopt,  Up: Programs and Arguments

Command Line
------------

  `(require 'read-command)'

 - Function: read-command port
 - Function: read-command
     `read-command' converts a "command line" into a list of strings
     suitable for parsing by `getopt'.  The syntax of command lines
     supported resembles that of popular "shell"s.  `read-command'
     updates PORT to point to the first character past the command
     delimiter.

     If an end of file is encountered in the input before any
     characters are found that can begin an object or comment, then an
     end of file object is returned.

     The PORT argument may be omitted, in which case it defaults to the
     value returned by `current-input-port'.

     The fields into which the command line is split are delimited by
     whitespace as defined by `char-whitespace?'.  The end of a command
     is delimited by end-of-file or unescaped semicolon (<;>) or
     <newline>.  Any character can be literally included in a field by
     escaping it with a backslach (<\>).

     The initial character and types of fields recognized are:
    `\'
          The next character has is taken literally and not interpreted
          as a field delimiter.  If <\> is the last character before a
          <newline>, that <newline> is just ignored.  Processing
          continues from the characters after the <newline> as though
          the backslash and <newline> were not there.

    `"'
          The characters up to the next unescaped <"> are taken
          literally, according to [R4RS] rules for literal strings
          (*note Strings: (r4rs)Strings.).

    `(', `%''
          One scheme expression is `read' starting with this character.
          The `read' expression is evaluated, converted to a string
          (using `display'), and replaces the expression in the returned
          field.

    `;'
          Semicolon delimits a command.  Using semicolons more than one
          command can appear on a line.  Escaped semicolons and
          semicolons inside strings do not delimit commands.

     The comment field differs from the previous fields in that it must
     be the first character of a command or appear after whitespace in
     order to be recognized.  <#> can be part of fields if these
     conditions are not met.  For instance, `ab#c' is just the field
     ab#c.

    `#'
          Introduces a comment.  The comment continues to the end of
          the line on which the semicolon appears.  Comments are
          treated as whitespace by `read-dommand-line' and backslashes
          before <newline>s in comments are also ignored.

 - Function: read-options-file filename
     `read-options-file' converts an "options file" into a list of
     strings suitable for parsing by `getopt'.  The syntax of options
     files is the same as the syntax for command lines, except that
     <newline>s do not terminate reading (only <;> or end of file).

     If an end of file is encountered before any characters are found
     that can begin an object or comment, then an end of file object is
     returned.


File: slib.info,  Node: Parameter lists,  Next: Getopt Parameter lists,  Prev: Command Line,  Up: Programs and Arguments

Parameter lists
---------------

  `(require 'parameters)'

Arguments to procedures in scheme are distinguished from each other by
their position in the procedure call.  This can be confusing when a
procedure takes many arguments, many of which are not often used.

A "parameter-list" is a way of passing named information to a
procedure.  Procedures are also defined to set unused parameters to
default values, check parameters, and combine parameter lists.

A PARAMETER has the form `(parameter-name value1 ...)'.  This format
allows for more than one value per parameter-name.

A PARAMETER-LIST is a list of PARAMETERs, each with a different
PARAMETER-NAME.

 - Function: make-parameter-list parameter-names
     Returns an empty parameter-list with slots for PARAMETER-NAMES.

 - Function: parameter-list-ref parameter-list parameter-name
     PARAMETER-NAME must name a valid slot of PARAMETER-LIST.
     `parameter-list-ref' returns the value of parameter PARAMETER-NAME
     of PARAMETER-LIST.

 - Function: remove-parameter parameter-name parameter-list
     Removes the parameter PARAMETER-NAME from PARAMETER-LIST.
     `remove-parameter' does not alter the argument PARAMETER-LIST.

     If there are more than one PARAMETER-NAME parameters, an error is
     signaled.

 - Procedure: adjoin-parameters! parameter-list parameter1 ...
     Returns PARAMETER-LIST with PARAMETER1 ... merged in.

 - Procedure: parameter-list-expand expanders parameter-list
     EXPANDERS is a list of procedures whose order matches the order of
     the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.  For each non-false element of EXPANDERS
     that procedure is mapped over the corresponding parameter value
     and the returned parameter lists are merged into PARAMETER-LIST.

     This process is repeated until PARAMETER-LIST stops growing.  The
     value returned from `parameter-list-expand' is unspecified.

 - Function: fill-empty-parameters defaulters parameter-list
     DEFAULTERS is a list of procedures whose order matches the order
     of the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.  `fill-empty-parameters' returns a new
     parameter-list with each empty parameter replaced with the list
     returned by calling the corresponding DEFAULTER with
     PARAMETER-LIST as its argument.

 - Function: check-parameters checks parameter-list
     CHECKS is a list of procedures whose order matches the order of
     the PARAMETER-NAMEs in the call to `make-parameter-list' which
     created PARAMETER-LIST.

     `check-parameters' returns PARAMETER-LIST if each CHECK of the
     corresponding PARAMETER-LIST returns non-false.  If some CHECK
     returns `#f' a warning is signaled.

In the following procedures ARITIES is a list of symbols.  The elements
of `arities' can be:

`single'
     Requires a single parameter.

`optional'
     A single parameter or no parameter is acceptable.

`boolean'
     A single boolean parameter or zero parameters is acceptable.

`nary'
     Any number of parameters are acceptable.

`nary1'
     One or more of parameters are acceptable.

 - Function: parameter-list->arglist positions arities parameter-list
     Returns PARAMETER-LIST converted to an argument list.  Parameters
     of ARITY type `single' and `boolean' are converted to the single
     value associated with them.  The other ARITY types are converted
     to lists of the value(s).

     POSITIONS is a list of positive integers whose order matches the
     order of the PARAMETER-NAMEs in the call to `make-parameter-list'
     which created PARAMETER-LIST.  The integers specify in which
     argument position the corresponding parameter should appear.


File: slib.info,  Node: Getopt Parameter lists,  Next: Filenames,  Prev: Parameter lists,  Up: Programs and Arguments

Getopt Parameter lists
----------------------

  `(require 'getopt-parameters)'

 - Function: getopt->parameter-list argc argv optnames arities types
          aliases desc ...
     Returns ARGV converted to a parameter-list.  OPTNAMES are the
     parameter-names.  ARITIES and TYPES are lists of symbols
     corresponding to OPTNAMES.

     ALIASES is a list of lists of strings or integers paired with
     elements of OPTNAMES.  Each one-character string will be treated
     as a single `-' option by `getopt'.  Longer strings will be
     treated as long-named options (*note getopt-: Getopt.).

     If the ALIASES association list has only strings as its `car's,
     then all the option-arguments after an option (and before the next
     option) are adjoined to that option.

     If the ALIASES association list has integers, then each (string)
     option will take at most one option-argument.  Unoptioned
     arguments are collected in a list.  A `-1' alias will take the
     last argument in this list; `+1' will take the first argument in
     the list.  The aliases -2 then +2; -3 then +3; ... are tried so
     long as a positive or negative consecutive alias is found and
     arguments remain in the list.  Finally a `0' alias, if found,
     absorbs any remaining arguments.

     In all cases, if unclaimed arguments remain after processing, a
     warning is signaled and #f is returned.

 - Function: getopt->arglist argc argv optnames positions arities types
          defaulters checks aliases desc ...
     Like `getopt->parameter-list', but converts ARGV to an
     argument-list as specified by OPTNAMES, POSITIONS, ARITIES, TYPES,
     DEFAULTERS, CHECKS, and ALIASES.  If the options supplied violate
     the ARITIES or CHECKS constraints, then a warning is signaled and
     #f is returned.

These `getopt' functions can be used with SLIB relational databases.
For an example, *Note make-command-server: Using Databases.

If errors are encountered while processing options, directions for using
the options (and argument strings DESC ...) are printed to
`current-error-port'.

     (begin
       (set! *optind* 1)
       (getopt->parameter-list
        2
        '("cmd" "-?")
        '(flag number symbols symbols string flag2 flag3 num2 num3)
        '(boolean optional nary1 nary single boolean boolean nary nary)
        '(boolean integer symbol symbol string boolean boolean integer integer)
        '(("flag" flag)
          ("f" flag)
          ("Flag" flag2)
          ("B" flag3)
          ("optional" number)
          ("o" number)
          ("nary1" symbols)
          ("N" symbols)
          ("nary" symbols)
          ("n" symbols)
          ("single" string)
          ("s" string)
          ("a" num2)
          ("Abs" num3))))
     -|
     Usage: cmd [OPTION ARGUMENT ...] ...
     
       -f, --flag
       -o, --optional=<number>
       -n, --nary=<symbols> ...
       -N, --nary1=<symbols> ...
       -s, --single=<string>
           --Flag
       -B
       -a        <num2> ...
           --Abs=<num3> ...
     
     ERROR: getopt->parameter-list "unrecognized option" "-?"


File: slib.info,  Node: Filenames,  Next: Batch,  Prev: Getopt Parameter lists,  Up: Programs and Arguments

Filenames
---------

  `(require 'filename)' or `(require 'glob)'

 - Function: filename:match?? pattern
 - Function: filename:match-ci?? pattern
     Returns a predicate which returns a non-false value if its string
     argument matches (the string) PATTERN, false otherwise.  Filename
     matching is like "glob" expansion described the bash manpage,
     except that names beginning with `.' are matched and `/'
     characters are not treated specially.

     These functions interpret the following characters specially in
     PATTERN strings:
    `*'
          Matches any string, including the null string.

    `?'
          Matches any single character.

    `[...]'
          Matches any one of the enclosed characters.  A pair of
          characters separated by a minus sign (-) denotes a range; any
          character lexically between those two characters, inclusive,
          is matched.  If the first character following the `[' is a
          `!' or a `^' then any character not enclosed is matched.  A
          `-' or `]' may be matched by including it as the first or
          last character in the set.


 - Function: filename:substitute?? pattern template
 - Function: filename:substitute-ci?? pattern template
     Returns a function transforming a single string argument according
     to glob patterns PATTERN and TEMPLATE.  PATTERN and TEMPLATE must
     have the same number of wildcard specifications, which need not be
     identical.  PATTERN and TEMPLATE may have a different number of
     literal sections. If an argument to the function matches PATTERN
     in the sense of `filename:match??' then it returns a copy of
     TEMPLATE in which each wildcard specification is replaced by the
     part of the argument matched by the corresponding wildcard
     specification in PATTERN.  A `*' wildcard matches the longest
     leftmost string possible.  If the argument does not match PATTERN
     then false is returned.

     TEMPLATE may be a function accepting the same number of string
     arguments as there are wildcard specifications in PATTERN.  In the
     case of a match the result of applying TEMPLATE to a list of the
     substrings matched by wildcard specifications will be returned,
     otherwise TEMPLATE will not be called and `#f' will be returned.

          ((filename:substitute?? "scm_[0-9]*.html" "scm5c4_??.htm")
           "scm_10.html")
          => "scm5c4_10.htm"
          ((filename:substitute?? "??" "beg?mid?end") "AZ")
          => "begAmidZend"
          ((filename:substitute?? "*na*" "?NA?") "banana")
          => "banaNA"
          ((filename:substitute?? "?*?" (lambda (s1 s2 s3) (string-append s3 s1))) "ABZ")
          => "ZA"

 - Function: replace-suffix str old new
     STR can be a string or a list of strings.  Returns a new string
     (or strings) similar to `str' but with the suffix string OLD
     removed and the suffix string NEW appended.  If the end of STR
     does not match OLD, an error is signaled.

          (replace-suffix "/usr/local/lib/slib/batch.scm" ".scm" ".c")
          => "/usr/local/lib/slib/batch.c"


File: slib.info,  Node: Batch,  Prev: Filenames,  Up: Programs and Arguments

Batch
-----

  `(require 'batch)'

The batch procedures provide a way to write and execute portable scripts
for a variety of operating systems.  Each `batch:' procedure takes as
its first argument a parameter-list (*note Parameter lists::).  This
parameter-list argument PARMS contains named associations.  Batch
currently uses 2 of these:

`batch-port'
     The port on which to write lines of the batch file.

`batch-dialect'
     The syntax of batch file to generate.  Currently supported are:
        * unix

        * dos

        * vms

        * amigaos

        * system

        * *unknown*

`batch.scm' uses 2 enhanced relational tables (*note Using Databases::)
to store information linking the names of `operating-system's to
`batch-dialect'es.

 - Function: batch:initialize! database
     Defines `operating-system' and `batch-dialect' tables and adds the
     domain `operating-system' to the enhanced relational database
     DATABASE.

 - Variable: *operating-system*
     Is batch's best guess as to which operating-system it is running
     under.  `*operating-system*' is set to `(software-type)' (*note
     Configuration::) unless `(software-type)' is `unix', in which case
     finer distinctions are made.

 - Function: batch:call-with-output-script parms file proc
     PROC should be a procedure of one argument.  If FILE is an
     output-port, `batch:call-with-output-script' writes an appropriate
     header to FILE and then calls PROC with FILE as the only argument.
     If FILE is a string, `batch:call-with-output-script' opens a
     output-file of name FILE, writes an appropriate header to FILE,
     and then calls PROC with the newly opened port as the only
     argument.  Otherwise, `batch:call-with-output-script' acts as if
     it was called with the result of `(current-output-port)' as its
     third argument.

The rest of the `batch:' procedures write (or execute if
`batch-dialect' is `system') commands to the batch port which has been
added to PARMS or `(copy-tree PARMS)' by the code:

     (adjoin-parameters! PARMS (list 'batch-port PORT))

 - Function: batch:command parms string1 string2 ...
     Calls `batch:try-command' (below) with arguments, but signals an
     error if `batch:try-command' returns `#f'.

These functions return a non-false value if the command was successfully
translated into the batch dialect and `#f' if not.  In the case of the
`system' dialect, the value is non-false if the operation suceeded.

 - Function: batch:try-command parms string1 string2 ...
     Writes a command to the `batch-port' in PARMS which executes the
     program named STRING1 with arguments STRING2 ....

 - Function: batch:try-chopped-command parms arg1 arg2 ... list
     breaks the last argument LIST into chunks small enough so that the
     command:

          ARG1 ARG2 ... CHUNK

     fits withing the platform's maximum command-line length.

     `batch:try-chopped-command' calls `batch:try-command' with the
     command and returns non-false only if the commands all fit and
     `batch:try-command' of each command line returned non-false.

 - Function: batch:run-script parms string1 string2 ...
     Writes a command to the `batch-port' in PARMS which executes the
     batch script named STRING1 with arguments STRING2 ....

     _Note:_ `batch:run-script' and `batch:try-command' are not the
     same for some operating systems (VMS).

 - Function: batch:comment parms line1 ...
     Writes comment lines LINE1 ... to the `batch-port' in PARMS.

 - Function: batch:lines->file parms file line1 ...
     Writes commands to the `batch-port' in PARMS which create a file
     named FILE with contents LINE1 ....

 - Function: batch:delete-file parms file
     Writes a command to the `batch-port' in PARMS which deletes the
     file named FILE.

 - Function: batch:rename-file parms old-name new-name
     Writes a command to the `batch-port' in PARMS which renames the
     file OLD-NAME to NEW-NAME.

In addition, batch provides some small utilities very useful for writing
scripts:

 - Function: truncate-up-to path char
 - Function: truncate-up-to path string
 - Function: truncate-up-to path charlist
     PATH can be a string or a list of strings.  Returns PATH sans any
     prefixes ending with a character of the second argument.  This can
     be used to derive a filename moved locally from elsewhere.

          (truncate-up-to "/usr/local/lib/slib/batch.scm" "/")
          => "batch.scm"

 - Function: string-join joiner string1 ...
     Returns a new string consisting of all the strings STRING1 ...  in
     order appended together with the string JOINER between each
     adjacent pair.

 - Function: must-be-first list1 list2
     Returns a new list consisting of the elements of LIST2 ordered so
     that if some elements of LIST1 are `equal?' to elements of LIST2,
     then those elements will appear first and in the order of LIST1.

 - Function: must-be-last list1 list2
     Returns a new list consisting of the elements of LIST1 ordered so
     that if some elements of LIST2 are `equal?' to elements of LIST1,
     then those elements will appear last and in the order of LIST2.

 - Function: os->batch-dialect osname
     Returns its best guess for the `batch-dialect' to be used for the
     operating-system named OSNAME.  `os->batch-dialect' uses the
     tables added to DATABASE by `batch:initialize!'.

Here is an example of the use of most of batch's procedures:

     (require 'databases)
     (require 'parameters)
     (require 'batch)
     (require 'glob)
     
     (define batch (create-database #f 'alist-table))
     (batch:initialize! batch)
     
     (define my-parameters
       (list (list 'batch-dialect (os->batch-dialect *operating-system*))
             (list 'operating-system *operating-system*)
             (list 'batch-port (current-output-port)))) ;gets filled in later
     
     (batch:call-with-output-script
      my-parameters
      "my-batch"
      (lambda (batch-port)
        (adjoin-parameters! my-parameters (list 'batch-port batch-port))
        (and
         (batch:comment my-parameters
                        "================ Write file with C program.")
         (batch:rename-file my-parameters "hello.c" "hello.c~")
         (batch:lines->file my-parameters "hello.c"
                            "#include <stdio.h>"
                            "int main(int argc, char **argv)"
                            "{"
                            "  printf(\"hello world\\n\");"
                            "  return 0;"
                            "}" )
         (batch:command my-parameters "cc" "-c" "hello.c")
         (batch:command my-parameters "cc" "-o" "hello"
                       (replace-suffix "hello.c" ".c" ".o"))
         (batch:command my-parameters "hello")
         (batch:delete-file my-parameters "hello")
         (batch:delete-file my-parameters "hello.c")
         (batch:delete-file my-parameters "hello.o")
         (batch:delete-file my-parameters "my-batch")
         )))

Produces the file `my-batch':

     #! /bin/sh
     # "my-batch" script created by SLIB/batch Sun Oct 31 18:24:10 1999
     # ================ Write file with C program.
     mv -f hello.c hello.c~
     rm -f hello.c
     echo '#include <stdio.h>'>>hello.c
     echo 'int main(int argc, char **argv)'>>hello.c
     echo '{'>>hello.c
     echo '  printf("hello world\n");'>>hello.c
     echo '  return 0;'>>hello.c
     echo '}'>>hello.c
     cc -c hello.c
     cc -o hello hello.o
     hello
     rm -f hello
     rm -f hello.c
     rm -f hello.o
     rm -f my-batch

When run, `my-batch' prints:

     bash$ my-batch
     mv: hello.c: No such file or directory
     hello world


File: slib.info,  Node: HTML,  Next: HTML Tables,  Prev: Programs and Arguments,  Up: Textual Conversion Packages

HTML
====

  `(require 'html-form)'

 - Function: html:atval txt
     Returns a string with character substitutions appropriate to send
     TXT as an "attribute-value".

 - Function: html:plain txt
     Returns a string with character substitutions appropriate to send
     TXT as an "plain-text".

 - Function: html:meta name content
     Returns a tag of meta-information suitable for passing as the
     third argument to `html:head'.  The tag produced is `<META
     NAME="NAME" CONTENT="CONTENT">'.  The string or symbol NAME can be
     `author', `copyright', `keywords', `description', `date',
     `robots', ....

 - Function: html:http-equiv name content
     Returns a tag of HTTP information suitable for passing as the
     third argument to `html:head'.  The tag produced is `<META
     HTTP-EQUIV="NAME" CONTENT="CONTENT">'.  The string or symbol NAME
     can be `Expires', `PICS-Label', `Content-Type', `Refresh', ....

 - Function: html:meta-refresh delay uri
 - Function: html:meta-refresh delay
     Returns a tag suitable for passing as the third argument to
     `html:head'.  If URI argument is supplied, then DELAY seconds after
     displaying the page with this tag, Netscape or IE browsers will
     fetch and display URI.  Otherwise, DELAY seconds after displaying
     the page with this tag, Netscape or IE browsers will fetch and
     redisplay this page.

 - Function: html:head title backlink tags ...
 - Function: html:head title backlink
 - Function: html:head title
     Returns header string for an HTML page named TITLE.  If BACKLINK
     is a string, it is used verbatim between the `H1' tags; otherwise
     TITLE is used.  If string arguments TAGS ... are supplied, then
     they are included verbatim within the <HEAD> section.

 - Function: html:body body ...
     Returns HTML string to end a page.

 - Function: html:pre line1 line ...
     Returns the strings LINE1, LINES as "PRE"formmated plain text
     (rendered in fixed-width font).  Newlines are inserted between
     LINE1, LINES.  HTML tags (`<tag>') within LINES will be visible
     verbatim.

 - Function: html:comment line1 line ...
     Returns the strings LINE1 as HTML comments.

HTML Forms
==========

 - Function: html:form method action body ...
     The symbol METHOD is either `get', `head', `post', `put', or
     `delete'.  The strings BODY form the body of the form.
     `html:form' returns the HTML "form".

 - Function: html:hidden name value
     Returns HTML string which will cause NAME=VALUE in form.

 - Function: html:checkbox pname default
     Returns HTML string for check box.

 - Function: html:text pname default size ...
     Returns HTML string for one-line text box.

 - Function: html:text-area pname default-list
     Returns HTML string for multi-line text box.

 - Function: html:select pname arity default-list foreign-values
     Returns HTML string for pull-down menu selector.

 - Function: html:buttons pname arity default-list foreign-values
     Returns HTML string for any-of selector.

 - Function: form:submit submit-label command
 - Function: form:submit submit-label
     The string or symbol SUBMIT-LABEL appears on the button which
     submits the form.  If the optional second argument COMMAND is
     given, then `*command*=COMMAND' and `*button*=SUBMIT-LABEL' are
     set in the query.  Otherwise, `*command*=SUBMIT-LABEL' is set in
     the query.

 - Function: form:image submit-label image-src
     The IMAGE-SRC appears on the button which submits the form.

 - Function: form:reset
     Returns a string which generates a "reset" button.

 - Function: form:element pname arity default-list foreign-values
     Returns a string which generates an INPUT element for the field
     named PNAME.  The element appears in the created form with its
     representation determined by its ARITY and domain.  For domains
     which are foreign-keys:

    `single'
          select menu

    `optional'
          select menu

    `nary'
          check boxes

    `nary1'
          check boxes

     If the foreign-key table has a field named `visible-name', then
     the contents of that field are the names visible to the user for
     those choices.  Otherwise, the foreign-key itself is visible.

     For other types of domains:

    `single'
          text area

    `optional'
          text area

    `boolean'
          check box

    `nary'
          text area

    `nary1'
          text area

 - Function: form:delimited pname doc aliat arity default-list
          foreign-values
     Returns a HTML string for a form element embedded in a line of a
     delimited list.  Apply map `form:delimited' to the list returned by
     `command->p-specs'.

 - Function: command->p-specs rdb command-table command
     The symbol COMMAND-TABLE names a command table in the RDB
     relational database.  The symbol COMMAND names a key in
     COMMAND-TABLE.

     `command->p-specs' returns a list of lists of PNAME, DOC, ALIAT,
     ARITY, DEFAULT-LIST, and FOREIGN-VALUES.  The returned list has
     one element for each parameter of command COMMAND.

     This example demonstrates how to create a HTML-form for the `build'
     command.

          (require (in-vicinity (implementation-vicinity) "build.scm"))
          (call-with-output-file "buildscm.html"
            (lambda (port)
              (display
               (string-append
                (html:head 'commands)
                (html:body
                 (sprintf #f "<H2>%s:</H2><BLOCKQUOTE>%s</BLOCKQUOTE>\\n"
          		(html:plain 'build)
          		(html:plain ((comtab 'get 'documentation) 'build)))
                 (html:form
          	'post
          	(or "http://localhost:8081/buildscm" "/cgi-bin/build.cgi")
          	(apply html:delimited-list
          	       (apply map form:delimited
          		      (command->p-specs build '*commands* 'build)))
          	(form:submit 'build)
          	(form:reset))))
               port)))


File: slib.info,  Node: HTML Tables,  Next: HTTP and CGI,  Prev: HTML,  Up: Textual Conversion Packages

HTML Tables
===========

  `(require 'db->html)'

 - Function: html:table options row ...

 - Function: html:caption caption align
 - Function: html:caption caption
     ALIGN can be `top' or `bottom'.

 - Function: html:heading columns
     Outputs a heading row for the currently-started table.

 - Function: html:href-heading columns uris
     Outputs a heading row with column-names COLUMNS linked to URIs
     URIS.

 - Function: html:linked-row-converter k foreigns
     The positive integer K is the primary-key-limit (number of
     primary-keys) of the table.  FOREIGNS is a list of the filenames of
     foreign-key field pages and #f for non foreign-key fields.

     `html:linked-row-converter' returns a procedure taking a row for
     its single argument.  This returned procedure returns the html
     string for that table row.

 - Function: table-name->filename table-name
     Returns the symbol TABLE-NAME converted to a filename.

 - Function: table->linked-html caption db table-name match-key1 ...
     Returns HTML string for DB table TABLE-NAME.  Every foreign-key
     value is linked to the page (of the table) defining that key.

     The optional MATCH-KEY1 ... arguments restrict actions to a subset
     of the table.  *Note match-key: Table Operations.

 - Function: table->linked-page db table-name index-filename arg ...
     Returns a complete HTML page.  The string INDEX-FILENAME names the
     page which refers to this one.

     The optional ARGS ... arguments restrict actions to a subset of
     the table.  *Note match-key: Table Operations.

 - Function: catalog->html db caption arg ...
     Returns HTML string for the catalog table of DB.

HTML editing tables
-------------------

A client can modify one row of an editable table at a time.  For any
change submitted, these routines check if that row has been modified
during the time the user has been editing the form.  If so, an error
page results.

The behavior of edited rows is:

   * If no fields are changed, then no change is made to the table.

   * If the primary keys equal null-keys (parameter defaults), and no
     other user has modified that row, then that row is deleted.

   * If only primary keys are changed, there are non-key fields, and no
     row with the new keys is in the table, then the old row is deleted
     and one with the new keys is inserted.

   * If only non-key fields are changed, and that row has not been
     modified by another user, then the row is changed to reflect the
     fields.

   * If both keys and non-key fields are changed, and no row with the
     new keys is in the table, then a row is created with the new keys
     and fields.

   * If fields are changed, all fields are primary keys, and no row with
     the new keys is in the table, then a row is created with the new
     keys.

After any change to the table, a `sync-database' of the database is
performed.

 - Function: command:modify-table table-name null-keys update delete
          retrieve
 - Function: command:modify-table table-name null-keys update delete
 - Function: command:modify-table table-name null-keys update
 - Function: command:modify-table table-name null-keys
     Returns procedure (of DB) which returns procedure to modify row of
     TABLE-NAME.  NULL-KEYS is the list of "null" keys which indicate
     that the row is to be deleted.  Optional arguments UPDATE, DELETE,
     and RETRIEVE default to the `row:update', `row:delete', and
     `row:retrieve' of TABLE-NAME in DB.

 - Function: command:make-editable-table rdb table-name arg ...
     Given TABLE-NAME in RDB, creates parameter and `*command*' tables
     for editing one row of TABLE-NAME at a time.
     `command:make-editable-table' returns a procedure taking a row
     argument which returns the HTML string for editing that row.

     Optional ARGS are expressions (lists) added to the call to
     `command:modify-table'.

     The domain name of a column determines the expected arity of the
     data stored in that column.  Domain names ending in:

    `*'
          have arity `nary';

    `+'
          have arity `nary1'.

 - Function: html:editable-row-converter k names edit-point
          edit-converter
     The positive integer K is the primary-key-limit (number of
     primary-keys) of the table.  NAMES is a list of the field-names.
     EDIT-POINT is the list of primary-keys denoting the row to edit
     (or #f).  EDIT-CONVERTER is the procedure called with K, NAMES,
     and the row to edit.

     `html:editable-row-converter' returns a procedure taking a row for
     its single argument.  This returned procedure returns the html
     string for that table row.

     Each HTML table constructed using `html:editable-row-converter'
     has first K fields (typically the primary key fields) of each row
     linked to a text encoding of these fields (the result of calling
     `row->anchor').  The page so referenced typically allows the user
     to edit fields of that row.

HTML databases
--------------

 - Function: db->html-files db dir index-filename caption
     DB must be a relational database.  DIR must be #f or a non-empty
     string naming an existing sub-directory of the current directory.

     `db->html-files' creates an html page for each table in the
     database DB in the sub-directory named DIR, or the current
     directory if DIR is #f.  The top level page with the catalog of
     tables (captioned CAPTION) is written to a file named
     INDEX-FILENAME.

 - Function: db->html-directory db dir index-filename
 - Function: db->html-directory db dir
     DB must be a relational database.  DIR must be a non-empty string
     naming an existing sub-directory of the current directory or one
     to be created.  The optional string INDEX-FILENAME names the
     filename of the top page, which defaults to `index.html'.

     `db->html-directory' creates sub-directory DIR if neccessary, and
     calls `(db->html-files DB DIR INDEX-FILENAME DIR)'.  The `file:'
     URI of INDEX-FILENAME is returned.

 - Function: db->netscape db dir index-filename
 - Function: db->netscape db dir
     `db->netscape' is just like `db->html-directory', but calls
     `browse-url' with the uri for the top page after the pages are           |
     created.                                                                 |


File: slib.info,  Node: HTTP and CGI,  Next: Parsing HTML,  Prev: HTML Tables,  Up: Textual Conversion Packages
                                                                              |
HTTP and CGI
============

  `(require 'http)' or `(require 'cgi)'

 - Function: http:header alist
     Returns a string containing lines for each element of ALIST; the
     `car' of which is followed by `: ', then the `cdr'.

 - Function: http:content alist body ...
     Returns the concatenation of strings BODY with the `(http:header
     ALIST)' and the `Content-Length' prepended.

 - Variable: *http:byline*
     String appearing at the bottom of error pages.

 - Function: http:error-page status-code reason-phrase html-string ...
     STATUS-CODE and REASON-PHRASE should be an integer and string as
     specified in `RFC 2068'.  The returned page (string) will show the
     STATUS-CODE and REASON-PHRASE and any additional HTML-STRINGS ...;
     with *HTTP:BYLINE* or SLIB's default at the bottom.

 - Function: http:forwarding-page title delay uri html-string ...
     The string or symbol TITLE is the page title.  DELAY is a
     non-negative integer.  The HTML-STRINGS ... are typically used to
     explain to the user why this page is being forwarded.

     `http:forwarding-page' returns an HTML string for a page which
     automatically forwards to URI after DELAY seconds.  The returned
     page (string) contains any HTML-STRINGS ... followed by a manual
     link to URI, in case the browser does not forward automatically.

 - Function: http:serve-query serve-proc input-port output-port
     reads the "URI" and "query-string" from INPUT-PORT.  If the query
     is a valid `"POST"' or `"GET"' query, then `http:serve-query' calls
     SERVE-PROC with three arguments, the REQUEST-LINE, QUERY-STRING,
     and HEADER-ALIST.  Otherwise, `http:serve-query' calls SERVE-PROC
     with the REQUEST-LINE, #f, and HEADER-ALIST.

     If SERVE-PROC returns a string, it is sent to OUTPUT-PORT.  If
     SERVE-PROC returns a list, then an error page with number 525 and
     strings from the list.  If SERVE-PROC returns #f, then a `Bad
     Request' (400) page is sent to OUTPUT-PORT.

     Otherwise, `http:serve-query' replies (to OUTPUT-PORT) with
     appropriate HTML describing the problem.

  This example services HTTP queries from PORT-NUMBER:

     (define socket (make-stream-socket AF_INET 0))
     (and (socket:bind socket port-number) ; AF_INET INADDR_ANY
          (socket:listen socket 10)        ; Queue up to 10 requests.
          (dynamic-wind
              (lambda () #f)
              (lambda ()
                (do ((port (socket:accept socket) (socket:accept socket)))
                    (#f)
                  (let ((iport (duplicate-port port "r"))
                        (oport (duplicate-port port "w")))
                    (http:serve-query build:serve iport oport)
                    (close-port iport)
                    (close-port oport))
                  (close-port port)))
              (lambda () (close-port socket))))

 - Function: cgi:serve-query serve-proc
     reads the "URI" and "query-string" from `(current-input-port)'.
     If the query is a valid `"POST"' or `"GET"' query, then
     `cgi:serve-query' calls SERVE-PROC with three arguments, the
     REQUEST-LINE, QUERY-STRING, and HEADER-ALIST.  Otherwise,
     `cgi:serve-query' calls SERVE-PROC with the REQUEST-LINE, #f, and
     HEADER-ALIST.

     If SERVE-PROC returns a string, it is sent to
     `(current-input-port)'.  If SERVE-PROC returns a list, then an
     error page with number 525 and strings from the list.  If
     SERVE-PROC returns #f, then a `Bad Request' (400) page is sent to
     `(current-input-port)'.

     Otherwise, `cgi:serve-query' replies (to `(current-input-port)')
     with appropriate HTML describing the problem.

 - Function: make-query-alist-command-server rdb command-table
 - Function: make-query-alist-command-server rdb command-table #t
     Returns a procedure of one argument.  When that procedure is called
     with a QUERY-ALIST (as returned by `uri:decode-query', the value
     of the `*command*' association will be the command invoked in
     COMMAND-TABLE.  If `*command*' is not in the QUERY-ALIST then the
     value of `*suggest*' is tried.  If neither name is in the
     QUERY-ALIST, then the literal value `*default*' is tried in
     COMMAND-TABLE.

     If optional third argument is non-false, then the command is called
     with just the parameter-list; otherwise, command is called with the
     arguments described in its table.


File: slib.info,  Node: Parsing HTML,  Next: URI,  Prev: HTTP and CGI,  Up: Textual Conversion Packages
                                                                              |
Parsing HTML                                                                  |
============                                                                  |
                                                                              |
 - Function: html-for-each file word-proc tag-proc white-proc                 |
          newline-proc                                                        |
     FILE is a string naming an existing file containing HTML text.           |
     WORD-PROC is a procedure of one argument or #f.  TAG-PROC is a           |
     procedure of one argument or #f.  WHITE-PROC is a procedure of one       |
     argument or #f.  NEWLINE-PROC is a procedure of no arguments or #f.      |
                                                                              |
     `html-for-each' opens and reads characters from the file named by        |
     FILE.  Sequential groups of characters are assembled into strings        |
     which are either                                                         |
                                                                              |
        * enclosed by `<' and `>' (hypertext markups);                        |
                                                                              |
        * end-of-line;                                                        |
                                                                              |
        * whitespace; or                                                      |
                                                                              |
        * none of the above (words).                                          |
                                                                              |
     Procedures are called according to these distinctions in order of        |
     the string's occurrence in FILE.                                         |
                                                                              |
     NEWLINE-PROC is called with no arguments for end-of-line _not            |
     within a hypertext markup_.                                              |
                                                                              |
     WHITE-PROC is called with strings of non-newline whitespace.             |
                                                                              |
     TAG-PROC is called with hypertext markup strings (including `<' and      |
     `>').                                                                    |
                                                                              |
     WORD-PROC is called with the remaining strings.                          |
                                                                              |
     `html-for-each' returns an unspecified value.                            |
                                                                              |

File: slib.info,  Node: URI,  Next: Printing Scheme,  Prev: Parsing HTML,  Up: Textual Conversion Packages
                                                                              |
URI
===

  `(require 'uri)'

Implements "Uniform Resource Identifiers" (URI) as described in RFC
2396.

 - Function: make-uri
 - Function: make-uri fragment
 - Function: make-uri query fragment
 - Function: make-uri path query fragment
 - Function: make-uri authority path query fragment
 - Function: make-uri scheme authority path query fragment
     Returns a Uniform Resource Identifier string from component
     arguments.

 - Function: html:anchor name
     Returns a string which defines this location in the (HTML) file as
     NAME.  The hypertext `<A HREF="#NAME">' will link to this point.

          (html:anchor "(section 7)")
          =>
          "<A NAME=\"(section%207)\"></A>"

 - Function: html:link uri highlighted
     Returns a string which links the HIGHLIGHTED text to URI.

          (html:link (make-uri "(section 7)") "section 7")
          =>
          "<A HREF=\"#(section%207)\">section 7</A>"

 - Function: html:base uri
     Returns a string specifying the "base" URI of a document, for
     inclusion in the HEAD of the document (*note head: HTML.).

 - Function: html:isindex prompt
     Returns a string specifying the search PROMPT of a document, for
     inclusion in the HEAD of the document (*note head: HTML.).

 - Function: uri->tree uri-reference base-tree ...
     Returns a list of 5 elements corresponding to the parts (SCHEME
     AUTHORITY PATH QUERY FRAGMENT) of string URI-REFERENCE.  Elements
     corresponding to absent parts are #f.

     The PATH is a list of strings.  If the first string is empty, then
     the path is absolute; otherwise relative.

     If the AUTHORITY component is a "Server-based Naming Authority",
     then it is a list of the USERINFO, HOST, and PORT strings (or #f).
     For other types of AUTHORITY components the AUTHORITY will be a
     string.

          (uri->tree "http://www.ics.uci.edu/pub/ietf/uri/#Related")
          =>
          (http "www.ics.uci.edu" ("" "pub" "ietf" "uri" "") #f "Related")

`uric:' prefixes indicate procedures dealing with URI-components.

 - Function: uric:encode uri-component allows
     Returns a copy of the string URI-COMPONENT in which all "unsafe"
     octets (as defined in RFC 2396) have been `%' "escaped".
     `uric:decode' decodes strings encoded by `uric:encode'.

 - Function: uric:decode uri-component
     Returns a copy of the string URI-COMPONENT in which each `%'
     escaped characters in URI-COMPONENT is replaced with the character
     it encodes.  This routine is useful for showing URI contents on
     error pages.

File-system Locators and Predicates                                           |
-----------------------------------                                           |
                                                                              |
 - Function: path->uri path                                                   |
     Returns a URI-string for PATH on the local host.                         |
                                                                              |
 - Function: absolute-path? file-name                                         |
     Returns #t if FILE-NAME is a fully specified pathname (does not          |
     depend on the current working directory); otherwise returns #f.          |
                                                                              |
 - Function: null-directory? str                                              |
     Returns #t if changing directory to STR would leave the current          |
     directory unchanged; otherwise returns #f.                               |
                                                                              |
 - Function: glob-pattern? str                                                |
     Returns #t if the string STR contains characters used for                |
     specifying glob patterns, namely `*', `?', or `['.                       |
                                                                              |
Before RFC 2396, the "File Transfer Protocol" (FTP) served a similar          |
purpose.                                                                      |
                                                                              |
 - Function: parse-ftp-address uri                                            |
     Returns a list of the decoded FTP URI; or #f if indecipherable.          |
     FTP "Uniform Resource Locator", "ange-ftp", and "getit" formats          |
     are handled.  The returned list has four elements which are              |
     strings or #f:                                                           |
                                                                              |
       0. username                                                            |
                                                                              |
       1. password                                                            |
                                                                              |
       2. remote-site                                                         |
                                                                              |
       3. remote-directory                                                    |
                                                                              |

File: slib.info,  Node: Printing Scheme,  Next: Time and Date,  Prev: URI,  Up: Textual Conversion Packages

Printing Scheme
===============

* Menu:

* Generic-Write::               'generic-write
* Object-To-String::            'object->string
* Pretty-Print::                'pretty-print, 'pprint-file


File: slib.info,  Node: Generic-Write,  Next: Object-To-String,  Prev: Printing Scheme,  Up: Printing Scheme

Generic-Write
-------------

  `(require 'generic-write)'

  `generic-write' is a procedure that transforms a Scheme data value
(or Scheme program expression) into its textual representation and
prints it.  The interface to the procedure is sufficiently general to
easily implement other useful formatting procedures such as pretty
printing, output to a string and truncated output.

 - Procedure: generic-write obj display? width output
    OBJ
          Scheme data value to transform.

    DISPLAY?
          Boolean, controls whether characters and strings are quoted.

    WIDTH
          Extended boolean, selects format:
         #f
               single line format

         integer > 0
               pretty-print (value = max nb of chars per line)

    OUTPUT
          Procedure of 1 argument of string type, called repeatedly with
          successive substrings of the textual representation.  This
          procedure can return `#f' to stop the transformation.

     The value returned by `generic-write' is undefined.

     Examples:
          (write obj) == (generic-write obj #f #f DISPLAY-STRING)
          (display obj) == (generic-write obj #t #f DISPLAY-STRING)

     where
          DISPLAY-STRING ==
          (lambda (s) (for-each write-char (string->list s)) #t)


File: slib.info,  Node: Object-To-String,  Next: Pretty-Print,  Prev: Generic-Write,  Up: Printing Scheme

Object-To-String
----------------

  `(require 'object->string)'

 - Function: object->string obj
     Returns the textual representation of OBJ as a string.

 - Function: object->limited-string obj limit
     Returns the textual representation of OBJ as a string of length at
     most LIMIT.


File: slib.info,  Node: Pretty-Print,  Prev: Object-To-String,  Up: Printing Scheme

Pretty-Print
------------

  `(require 'pretty-print)'

 - Procedure: pretty-print obj
 - Procedure: pretty-print obj port
     `pretty-print's OBJ on PORT.  If PORT is not specified,
     `current-output-port' is used.

     Example:
          (pretty-print '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                          (16 17 18 19 20) (21 22 23 24 25)))
             -| ((1 2 3 4 5)
             -|  (6 7 8 9 10)
             -|  (11 12 13 14 15)
             -|  (16 17 18 19 20)
             -|  (21 22 23 24 25))

 - Procedure: pretty-print->string obj
 - Procedure: pretty-print->string obj width
     Returns the string of OBJ `pretty-print'ed in WIDTH columns.  If
     WIDTH is not specified, `(output-port-width)' is used.

     Example:
          (pretty-print->string '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                                  (16 17 18 19 20) (21 22 23 24 25)))
          =>
          "((1 2 3 4 5)
           (6 7 8 9 10)
           (11 12 13 14 15)
           (16 17 18 19 20)
           (21 22 23 24 25))
          "
          (pretty-print->string '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)
                                  (16 17 18 19 20) (21 22 23 24 25))
                                16)
          =>
          "((1 2 3 4 5)
           (6 7 8 9 10)
           (11
            12
            13
            14
            15)
           (16
            17
            18
            19
            20)
           (21
            22
            23
            24
            25))
          "

  `(require 'pprint-file)'

 - Procedure: pprint-file infile
 - Procedure: pprint-file infile outfile
     Pretty-prints all the code in INFILE.  If OUTFILE is specified,
     the output goes to OUTFILE, otherwise it goes to
     `(current-output-port)'.

 - Function: pprint-filter-file infile proc outfile
 - Function: pprint-filter-file infile proc
     INFILE is a port or a string naming an existing file.  Scheme
     source code expressions and definitions are read from the port (or
     file) and PROC is applied to them sequentially.

     OUTFILE is a port or a string.  If no OUTFILE is specified then
     `current-output-port' is assumed.  These expanded expressions are
     then `pretty-print'ed to this port.

     Whitepsace and comments (introduced by `;') which are not part of
     scheme expressions are reproduced in the output.  This procedure
     does not affect the values returned by `current-input-port' and
     `current-output-port'.

  `pprint-filter-file' can be used to pre-compile macro-expansion and
thus can reduce loading time.  The following will write into
`exp-code.scm' the result of expanding all defmacros in `code.scm'.
     (require 'pprint-file)
     (require 'defmacroexpand)
     (defmacro:load "my-macros.scm")
     (pprint-filter-file "code.scm" defmacro:expand* "exp-code.scm")


File: slib.info,  Node: Time and Date,  Next: Schmooz,  Prev: Printing Scheme,  Up: Textual Conversion Packages

Time and Date
=============

* Menu:

* Time Zone::
* Posix Time::                  'posix-time
* Common-Lisp Time::            'common-lisp-time

If `(provided? 'current-time)':

The procedures `current-time', `difftime', and `offset-time' deal with
a "calendar time" datatype which may or may not be disjoint from other
Scheme datatypes.

 - Function: current-time
     Returns the time since 00:00:00 GMT, January 1, 1970, measured in
     seconds.  Note that the reference time is different from the
     reference time for `get-universal-time' in *Note Common-Lisp
     Time::.

 - Function: difftime caltime1 caltime0
     Returns the difference (number of seconds) between twe calendar
     times: CALTIME1 - CALTIME0.  CALTIME0 may also be a number.

 - Function: offset-time caltime offset
     Returns the calendar time of CALTIME offset by OFFSET number of
     seconds `(+ caltime offset)'.


File: slib.info,  Node: Time Zone,  Next: Posix Time,  Prev: Time and Date,  Up: Time and Date

Time Zone
---------

  (require 'time-zone)

 - Data Format: TZ-string
     POSIX standards specify several formats for encoding time-zone
     rules.

    :<pathname>
          If the first character of <pathname> is `/', then <pathname>
          specifies the absolute pathname of a tzfile(5) format
          time-zone file.  Otherwise, <pathname> is interpreted as a
          pathname within TZFILE:VICINITY (/usr/lib/zoneinfo/) naming a
          tzfile(5) format time-zone file.

    <std><offset>
          The string <std> consists of 3 or more alphabetic characters.
          <offset> specifies the time difference from GMT.  The <offset>
          is positive if the local time zone is west of the Prime
          Meridian and negative if it is east.  <offset> can be the
          number of hours or hours and minutes (and optionally seconds)
          separated by `:'.  For example, `-4:30'.

    <std><offset><dst>
          <dst> is the at least 3 alphabetic characters naming the local
          daylight-savings-time.

    <std><offset><dst><doffset>
          <doffset> specifies the offset from the Prime Meridian when
          daylight-savings-time is in effect.

     The non-tzfile formats can optionally be followed by transition
     times specifying the day and time when a zone changes from
     standard to daylight-savings and back again.

    ,<date>/<time>,<date>/<time>
          The <time>s are specified like the <offset>s above, except
          that leading `+' and `-' are not allowed.

          Each <date> has one of the formats:

         J<day>
               specifies the Julian day with <day> between 1 and 365.
               February 29 is never counted and cannot be referenced.

         <day>
               This specifies the Julian day with n between 0 and 365.
               February 29 is counted in leap years and can be
               specified.

         M<month>.<week>.<day>
               This specifies day <day> (0 <= <day> <= 6) of week
               <week> (1 <= <week> <= 5) of month <month> (1 <= <month>
               <= 12).  Week 1 is the first week in which day d occurs
               and week 5 is the last week in which day <day> occurs.
               Day 0 is a Sunday.


 - Data Type: time-zone
     is a datatype encoding how many hours from Greenwich Mean Time the
     local time is, and the "Daylight Savings Time" rules for changing
     it.

 - Function: time-zone TZ-string
     Creates and returns a time-zone object specified by the string
     TZ-STRING.  If `time-zone' cannot interpret TZ-STRING, `#f' is
     returned.

 - Function: tz:params caltime tz
     TZ is a time-zone object.  `tz:params' returns a list of three
     items:
       0. An integer.  0 if standard time is in effect for timezone TZ
          at CALTIME; 1 if daylight savings time is in effect for
          timezone TZ at CALTIME.

       1. The number of seconds west of the Prime Meridian timezone TZ
          is at CALTIME.

       2. The name for timezone TZ at CALTIME.

     `tz:params' is unaffected by the default timezone; inquiries can be
     made of any timezone at any calendar time.


The rest of these procedures and variables are provided for POSIX
compatability.  Because of shared state they are not thread-safe.

 - Function: tzset
     Returns the default time-zone.

 - Function: tzset tz
     Sets (and returns) the default time-zone to TZ.

 - Function: tzset TZ-string
     Sets (and returns) the default time-zone to that specified by
     TZ-STRING.

     `tzset' also sets the variables *TIMEZONE*, DAYLIGHT?, and TZNAME.
     This function is automatically called by the time conversion
     procedures which depend on the time zone (*note Time and Date::).

 - Variable: *timezone*
     Contains the difference, in seconds, between Greenwich Mean Time
     and local standard time (for example, in the U.S.  Eastern time
     zone (EST), timezone is 5*60*60).  `*timezone*' is initialized by
     `tzset'.

 - Variable: daylight?
     is `#t' if the default timezone has rules for "Daylight Savings
     Time".  _Note:_ DAYLIGHT? does not tell you when Daylight Savings
     Time is in effect, just that the default zone sometimes has
     Daylight Savings Time.

 - Variable: tzname
     is a vector of strings.  Index 0 has the abbreviation for the
     standard timezone; If DAYLIGHT?, then index 1 has the abbreviation
     for the Daylight Savings timezone.


File: slib.info,  Node: Posix Time,  Next: Common-Lisp Time,  Prev: Time Zone,  Up: Time and Date

Posix Time
----------

     (require 'posix-time)

 - Data Type: Calendar-Time
     is a datatype encapsulating time.

 - Data Type: Coordinated Universal Time
     (abbreviated "UTC") is a vector of integers representing time:

       0.  seconds (0 - 61)

       1.  minutes (0 - 59)

       2.  hours since midnight (0 - 23)

       3.  day of month (1 - 31)

       4.  month (0 - 11).  Note difference from
          `decode-universal-time'.

       5.  the number of years since 1900.  Note difference from
          `decode-universal-time'.

       6.  day of week (0 - 6)

       7.  day of year (0 - 365)

       8.  1 for daylight savings, 0 for regular time

 - Function: gmtime caltime
     Converts the calendar time CALTIME to UTC and returns it.

 - Function: localtime caltime tz
     Returns CALTIME converted to UTC relative to timezone TZ.

 - Function: localtime caltime
     converts the calendar time CALTIME to a vector of integers
     expressed relative to the user's time zone.  `localtime' sets the
     variable *TIMEZONE* with the difference between Coordinated
     Universal Time (UTC) and local standard time in seconds (*note
     tzset: Time Zone.).


 - Function: gmktime univtime
     Converts a vector of integers in GMT Coordinated Universal Time
     (UTC) format to a calendar time.

 - Function: mktime univtime
     Converts a vector of integers in local Coordinated Universal Time
     (UTC) format to a calendar time.

 - Function: mktime univtime tz
     Converts a vector of integers in Coordinated Universal Time (UTC)
     format (relative to time-zone TZ) to calendar time.

 - Function: asctime univtime
     Converts the vector of integers CALTIME in Coordinated Universal
     Time (UTC) format into a string of the form `"Wed Jun 30 21:49:08
     1993"'.

 - Function: gtime caltime
 - Function: ctime caltime
 - Function: ctime caltime tz
     Equivalent to `(asctime (gmtime CALTIME))', `(asctime (localtime
     CALTIME))', and `(asctime (localtime CALTIME TZ))', respectively.


File: slib.info,  Node: Common-Lisp Time,  Prev: Posix Time,  Up: Time and Date

Common-Lisp Time
----------------

 - Function: get-decoded-time
     Equivalent to `(decode-universal-time (get-universal-time))'.

 - Function: get-universal-time
     Returns the current time as "Universal Time", number of seconds
     since 00:00:00 Jan 1, 1900 GMT.  Note that the reference time is
     different from `current-time'.

 - Function: decode-universal-time univtime
     Converts UNIVTIME to "Decoded Time" format.  Nine values are
     returned:
       0.  seconds (0 - 61)

       1.  minutes (0 - 59)

       2.  hours since midnight

       3.  day of month

       4.  month (1 - 12).  Note difference from `gmtime' and
          `localtime'.

       5.  year (A.D.).  Note difference from `gmtime' and `localtime'.

       6.  day of week (0 - 6)

       7.  #t for daylight savings, #f otherwise

       8.  hours west of GMT (-24 - +24)

     Notice that the values returned by `decode-universal-time' do not
     match the arguments to `encode-universal-time'.

 - Function: encode-universal-time second minute hour date month year
 - Function: encode-universal-time second minute hour date month year
          time-zone
     Converts the arguments in Decoded Time format to Universal Time
     format.  If TIME-ZONE is not specified, the returned time is
     adjusted for daylight saving time.  Otherwise, no adjustment is
     performed.

     Notice that the values returned by `decode-universal-time' do not
     match the arguments to `encode-universal-time'.


File: slib.info,  Node: Schmooz,  Prev: Time and Date,  Up: Textual Conversion Packages

Schmooz
=======

  "Schmooz" is a simple, lightweight markup language for interspersing
Texinfo documentation with Scheme source code.  Schmooz does not create
the top level Texinfo file; it creates `txi' files which can be
imported into the documentation using the Texinfo command `@include'.

  `(require 'schmooz)' defines the function `schmooz', which is used to
process files.  Files containing schmooz documentation should not
contain `(require 'schmooz)'.

 - Procedure: schmooz filename.scm ...
     FILENAME.scm should be a string ending with `.scm' naming an
     existing file containing Scheme source code.  `schmooz' extracts
     top-level comments containing schmooz commands from FILENAME.scm
     and writes the converted Texinfo source to a file named
     FILENAME.txi.

 - Procedure: schmooz filename.texi ...
 - Procedure: schmooz filename.tex ...
 - Procedure: schmooz filename.txi ...
     FILENAME should be a string naming an existing file containing
     Texinfo source code.  For every occurrence of the string `@include
     FILENAME.txi' within that file, `schmooz' calls itself with the
     argument `FILENAME.scm'.

  Schmooz comments are distinguished (from non-schmooz comments) by
their first line, which must start with an at-sign (@) preceded by one
or more semicolons (;).  A schmooz comment ends at the first subsequent
line which does _not_ start with a semicolon.  Currently schmooz
comments are recognized only at top level.

  Schmooz comments are copied to the Texinfo output file with the
leading contiguous semicolons removed.  Certain character sequences
starting with at-sign are treated specially.  Others are copied
unchanged.

  A schmooz comment starting with `@body' must be followed by a Scheme
definition.  All comments between the `@body' line and the definition
will be included in a Texinfo definition, either a `@defun' or a
`@defvar', depending on whether a procedure or a variable is being
defined.

  Within the text of that schmooz comment, at-sign followed by `0' will
be replaced by `@code{procedure-name}' if the following definition is
of a procedure; or `@var{variable}' if defining a variable.

  An at-sign followed by a non-zero digit will expand to the variable
citation of that numbered argument: `@var{argument-name}'.

  If more than one definition follows a `@body' comment line without an
intervening blank or comment line, then those definitions will be
included in the same Texinfo definition using `@defvarx' or `@defunx',
depending on whether the first definition is of a variable or of a
procedure.

  Schmooz can figure out whether a definition is of a procedure if it
is of the form:

  `(define (<identifier> <arg> ...) <expression>)'

or if the left hand side of the definition is some form ending in a
lambda expression.  Obviously, it can be fooled.  In order to force
recognition of a procedure definition, start the documentation with
`@args' instead of `@body'.  `@args' should be followed by the argument
list of the function being defined, which may be enclosed in
parentheses and delimited by whitespace, (as in Scheme), enclosed in
braces and separated by commas, (as in Texinfo), or consist of the
remainder of the line, separated by whitespace.

  For example:

     ;;@args arg1 args ...
     ;;@0 takes argument @1 and any number of @2
     (define myfun (some-function-returning-magic))

  Will result in:

     @defun myfun arg1 args @dots{}
     
     @code{myfun} takes argument @var{arg1} and any number of @var{args}
     @end defun

  `@args' may also be useful for indicating optional arguments by name.
If `@args' occurs inside a schmooz comment section, rather than at the
beginning, then it will generate a `@defunx' line with the arguments
supplied.

  If the first at-sign in a schmooz comment is immediately followed by
whitespace, then the comment will be expanded to whatever follows that
whitespace.  If the at-sign is followed by a non-whitespace character
then the at-sign will be included as the first character of the
expansion.  This feature is intended to make it easy to include Texinfo
directives in schmooz comments.


File: slib.info,  Node: Mathematical Packages,  Next: Database Packages,  Prev: Textual Conversion Packages,  Up: Top

Mathematical Packages
*********************

* Menu:

* Bit-Twiddling::               'logical
* Modular Arithmetic::          'modular
* Prime Numbers::               'factor
* Random Numbers::              'random
* Fast Fourier Transform::      'fft
* Cyclic Checksum::             'crc                                          |
* Plotting::                    'charplot
* Solid Modeling::              VRML97
* Color::
* Root Finding::                'root
* Minimizing::                  'minimize
* Commutative Rings::           'commutative-ring
* Matrix Algebra::              'determinant


File: slib.info,  Node: Bit-Twiddling,  Next: Modular Arithmetic,  Prev: Mathematical Packages,  Up: Mathematical Packages

Bit-Twiddling
=============

  `(require 'logical)'

The bit-twiddling functions are made available through the use of the
`logical' package.  `logical' is loaded by inserting `(require
'logical)' before the code that uses these functions.  These functions
behave as though operating on integers in two's-complement
representation.

Bitwise Operations
------------------

 - Function: logand n1 n1
     Returns the integer which is the bit-wise AND of the two integer
     arguments.

     Example:
          (number->string (logand #b1100 #b1010) 2)
             => "1000"

 - Function: logior n1 n2
     Returns the integer which is the bit-wise OR of the two integer
     arguments.

     Example:
          (number->string (logior #b1100 #b1010) 2)
             => "1110"

 - Function: logxor n1 n2
     Returns the integer which is the bit-wise XOR of the two integer
     arguments.

     Example:
          (number->string (logxor #b1100 #b1010) 2)
             => "110"

 - Function: lognot n
     Returns the integer which is the 2s-complement of the integer
     argument.

     Example:
          (number->string (lognot #b10000000) 2)
             => "-10000001"
          (number->string (lognot #b0) 2)
             => "-1"

 - Function: bitwise-if mask n0 n1
     Returns an integer composed of some bits from integer N0 and some
     from integer N1.  A bit of the result is taken from N0 if the
     corresponding bit of integer MASK is 1 and from N1 if that bit of
     MASK is 0.

 - Function: logtest j k
          (logtest j k) == (not (zero? (logand j k)))
          
          (logtest #b0100 #b1011) => #f
          (logtest #b0100 #b0111) => #t

 - Function: logcount n
     Returns the number of bits in integer N.  If integer is positive,
     the 1-bits in its binary representation are counted.  If negative,
     the 0-bits in its two's-complement binary representation are
     counted.  If 0, 0 is returned.

     Example:
          (logcount #b10101010)
             => 4
          (logcount 0)
             => 0
          (logcount -2)
             => 1

Bit Within Word
---------------

 - Function: logbit? index j
          (logbit? index j) == (logtest (integer-expt 2 index) j)
          
          (logbit? 0 #b1101) => #t
          (logbit? 1 #b1101) => #f
          (logbit? 2 #b1101) => #t
          (logbit? 3 #b1101) => #t
          (logbit? 4 #b1101) => #f

 - Function: copy-bit index from bit
     Returns an integer the same as FROM except in the INDEXth bit,
     which is 1 if BIT is `#t' and 0 if BIT is `#f'.

     Example:
          (number->string (copy-bit 0 0 #t) 2)       => "1"
          (number->string (copy-bit 2 0 #t) 2)       => "100"
          (number->string (copy-bit 2 #b1111 #f) 2)  => "1011"

Fields of Bits
--------------

 - Function: bit-field n start end
     Returns the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in
     the result.

     This function was called `bit-extract' in previous versions of
     SLIB.

     Example:
          (number->string (bit-field #b1101101010 0 4) 2)
             => "1010"
          (number->string (bit-field #b1101101010 4 9) 2)
             => "10110"

 - Function: copy-bit-field to start end from
     Returns an integer the same as TO except possibly in the START
     (inclusive) through END (exclusive) bits, which are the same as
     those of FROM.  The 0-th bit of FROM becomes the STARTth bit of
     the result.

     Example:
          (number->string (copy-bit-field #b1101101010 0 4 0) 2)
                  => "1101100000"
          (number->string (copy-bit-field #b1101101010 0 4 -1) 2)
                  => "1101101111"

 - Function: ash n count                                                      |
     Returns an integer equivalent to `(inexact->exact (floor (* N            |
     (expt 2 COUNT))))'.

     Example:
          (number->string (ash #b1 3) 2)
             => "1000"
          (number->string (ash #b1010 -1) 2)
             => "101"

 - Function: integer-length n
     Returns the number of bits neccessary to represent N.

     Example:
          (integer-length #b10101010)
             => 8
          (integer-length 0)
             => 0
          (integer-length #b1111)
             => 4

 - Function: integer-expt n k
     Returns N raised to the non-negative integer exponent K.

     Example:
          (integer-expt 2 5)
             => 32
          (integer-expt -3 3)
             => -27

Bit order and Lamination
------------------------

 - Function: logical:rotate k count len                                       |
     Returns the low-order LEN bits of K cyclically permuted COUNT bits       |
     towards high-order.                                                      |
                                                                              |
     Example:                                                                 |
          (number->string (logical:rotate #b0100 3 4) 2)                      |
          => "10"                                                             |
          (number->string (logical:rotate #b0100 -1 4) 2)                     |
          => "10"                                                             |
                                                                              |
 - Function: bit-reverse k n
     Returns the low-order K bits of N with the bit order reversed.
     The low-order bit of N is the high order bit of the returned value.

          (number->string (bit-reverse 8 #xa7) 16)
            => "e5"

 - Function: integer->list k len
 - Function: integer->list k
     `integer->list' returns a list of LEN booleans corresponding to
     each bit of the given integer.  #t is coded for each 1; #f for 0.
     The LEN argument defaults to `(integer-length K)'.

 - Function: list->integer list
     `list->integer' returns an integer formed from the booleans in the
     list LIST, which must be a list of booleans.  A 1 bit is coded for
     each #t; a 0 bit for #f.

     `integer->list' and `list->integer' are inverses so far as
     `equal?' is concerned.

 - Function: booleans->integer bool1 ...
     Returns the integer coded by the BOOL1 ... arguments.

 - Function: bitwise:laminate k1 ...
     Returns an integer composed of the bits of K1 ... interlaced in
     argument order.  Given K1, ... KN, the n low-order bits of the
     returned value will be the lowest-order bit of each argument.

 - Function: bitwise:delaminate count k
     Returns a list of COUNT integers comprised of every COUNTh bit of
     the integer K.

     For any non-negative integers K and COUNT:
          (eqv? k (bitwise:laminate (bitwise:delaminate count k)))

Gray code
---------

A "Gray code" is an ordering of non-negative integers in which exactly
one bit differs between each pair of successive elements.  There are
multiple Gray codings.  An n-bit Gray code corresponds to a Hamiltonian
cycle on an n-dimensional hypercube.

Gray codes find use communicating incrementally changing values between
asynchronous agents.  De-laminated Gray codes comprise the coordinates
of Hilbert's space-filling curves.

 - Function: integer->gray-code k
     Converts K to a Gray code of the same `integer-length' as K.

 - Function: gray-code->integer k
     Converts the Gray code K to an integer of the same
     `integer-length' as K.

     For any non-negative integer K,
          (eqv? k (gray-code->integer (integer->gray-code k)))

 - Function: = k1 k2
 - Function: gray-code<? k1 k2
 - Function: gray-code>? k1 k2
 - Function: gray-code<=? k1 k2
 - Function: gray-code>=? k1 k2
     These procedures return #t if their Gray code arguments are
     (respectively): equal, monotonically increasing, monotonically
     decreasing, monotonically nondecreasing, or monotonically
     nonincreasing.

     For any non-negative integers K1 and K2, the Gray code predicate
     of `(integer->gray-code k1)' and `(integer->gray-code k2)' will
     return the same value as the corresponding predicate of K1 and K2.


File: slib.info,  Node: Modular Arithmetic,  Next: Prime Numbers,  Prev: Bit-Twiddling,  Up: Mathematical Packages

Modular Arithmetic
==================

  `(require 'modular)'

 - Function: mod x1 x2
 - Function: rem x1 x2
     These procedures implement the Common-Lisp functions of the same
     names.  The real number X2 must be non-zero.  `mod' returns `(- X1
     (* X2 (floor (/ X1 X2))))'.  `rem' returns `(- X1 (* X2 (truncate
     (/ X1 X2))))'.

     If X1 and X2 are integers, then `mod' behaves like `modulo' and
     `rem' behaves like `remainder'.

     (mod -90 360)                          => 270
     (rem -90 180)                          => -90
     
     (mod 540 360)                          => 180
     (rem 540 360)                          => 180
     
     (mod (* 5/2 pi) (* 2 pi))              => 1.5707963267948965
     (rem (* -5/2 pi) (* 2 pi))             => -1.5707963267948965

 - Function: extended-euclid n1 n2
     Returns a list of 3 integers `(d x y)' such that d = gcd(N1, N2) =
     N1 * x + N2 * y.

 - Function: symmetric:modulus n
     Returns `(quotient (+ -1 n) -2)' for positive odd integer N.

 - Function: modulus->integer modulus
     Returns the non-negative integer characteristic of the ring formed
     when MODULUS is used with `modular:' procedures.

 - Function: modular:normalize modulus n
     Returns the integer `(modulo N (modulus->integer MODULUS))' in the
     representation specified by MODULUS.

The rest of these functions assume normalized arguments; That is, the
arguments are constrained by the following table:

For all of these functions, if the first argument (MODULUS) is:
`positive?'
     Work as before.  The result is between 0 and MODULUS.

`zero?'
     The arguments are treated as integers.  An integer is returned.

`negative?'
     The arguments and result are treated as members of the integers
     modulo `(+ 1 (* -2 MODULUS))', but with "symmetric"
     representation; i.e. `(<= (- MODULUS) N MODULUS)'.

If all the arguments are fixnums the computation will use only fixnums.

 - Function: modular:invertable? modulus k
     Returns `#t' if there exists an integer n such that K * n == 1 mod
     MODULUS, and `#f' otherwise.

 - Function: modular:invert modulus n2
     Returns an integer n such that 1 = (n * N2) mod MODULUS.  If N2
     has no inverse mod MODULUS an error is signaled.

 - Function: modular:negate modulus n2
     Returns (-N2) mod MODULUS.

 - Function: modular:+ modulus n2 n3
     Returns (N2 + N3) mod MODULUS.

 - Function: modular:- modulus n2 n3
     Returns (N2 - N3) mod MODULUS.

 - Function: modular:* modulus n2 n3
     Returns (N2 * N3) mod MODULUS.

     The Scheme code for `modular:*' with negative MODULUS is not
     completed for fixnum-only implementations.

 - Function: modular:expt modulus n2 n3
     Returns (N2 ^ N3) mod MODULUS.


File: slib.info,  Node: Prime Numbers,  Next: Random Numbers,  Prev: Modular Arithmetic,  Up: Mathematical Packages

Prime Numbers
=============

  `(require 'factor)'

 - Variable: prime:prngs
     PRIME:PRNGS is the random-state (*note Random Numbers::) used by
     these procedures.  If you call these procedures from more than one
     thread (or from interrupt), `random' may complain about reentrant
     calls.
  _Note:_ The prime test and generation procedures implement (or use)
the Solovay-Strassen primality test. See

   * Robert Solovay and Volker Strassen, `A Fast Monte-Carlo Test for
     Primality', SIAM Journal on Computing, 1977, pp 84-85.

 - Function: jacobi-symbol p q
     Returns the value (+1, -1, or 0) of the Jacobi-Symbol of exact
     non-negative integer P and exact positive odd integer Q.

 - Variable: prime:trials
     PRIME:TRIALS the maxinum number of iterations of Solovay-Strassen
     that will be done to test a number for primality.

 - Function: prime? n
     Returns `#f' if N is composite; `#t' if N is prime.  There is a
     slight chance `(expt 2 (- prime:trials))' that a composite will
     return `#t'.

 - Function: primes< start count
     Returns a list of the first COUNT prime numbers less than START.
     If there are fewer than COUNT prime numbers less than START, then
     the returned list will have fewer than START elements.

 - Function: primes> start count
     Returns a list of the first COUNT prime numbers greater than START.

 - Function: factor k
     Returns a list of the prime factors of K.  The order of the
     factors is unspecified.  In order to obtain a sorted list do
     `(sort! (factor K) <)'.


File: slib.info,  Node: Random Numbers,  Next: Fast Fourier Transform,  Prev: Prime Numbers,  Up: Mathematical Packages

Random Numbers
==============

  `(require 'random)'

  A pseudo-random number generator is only as good as the tests it
passes.  George Marsaglia of Florida State University developed a
battery of tests named "DIEHARD"
(<http://stat.fsu.edu/~geo/diehard.html>).  `diehard.c' has a bug which
the patch
<http://swissnet.ai.mit.edu/ftpdir/users/jaffer/diehard.c.pat> corrects.

  SLIB's new PRNG generates 8 bits at a time.  With the degenerate seed
`0', the numbers generated pass DIEHARD; but when bits are combined
from sequential bytes, tests fail.  With the seed
`http://swissnet.ai.mit.edu/~jaffer/SLIB.html', all of those tests pass.

 - Function: random n
 - Function: random n state
     Accepts a positive integer or real N and returns a number of the
     same type between zero (inclusive) and N (exclusive).  The values
     returned by `random' are uniformly distributed from 0 to N.

     The optional argument STATE must be of the type returned by
     `(seed->random-state)' or `(make-random-state)'.  It defaults to
     the value of the variable `*random-state*'.  This object is used
     to maintain the state of the pseudo-random-number generator and is
     altered as a side effect of calls to `random'.

 - Variable: *random-state*
     Holds a data structure that encodes the internal state of the
     random-number generator that `random' uses by default.  The nature
     of this data structure is implementation-dependent.  It may be
     printed out and successfully read back in, but may or may not
     function correctly as a random-number state object in another
     implementation.

 - Function: copy-random-state state
     Returns a new copy of argument STATE.

 - Function: copy-random-state
     Returns a new copy of `*random-state*'.

 - Function: seed->random-state seed
     Returns a new object of type suitable for use as the value of the
     variable `*random-state*' or as a second argument to `random'.
     The number or string SEED is used to initialize the state.  If
     `seed->random-state' is called twice with arguments which are
     `equal?', then the returned data structures will be `equal?'.
     Calling `seed->random-state' with unequal arguments will nearly
     always return unequal states.

 - Function: make-random-state
 - Function: make-random-state obj
     Returns a new object of type suitable for use as the value of the
     variable `*random-state*' or as a second argument to `random'.  If
     the optional argument OBJ is given, it should be a printable
     Scheme object; the first 50 characters of its printed
     representation will be used as the seed.  Otherwise the value of
     `*random-state*' is used as the seed.

  If inexact numbers are supported by the Scheme implementation,
`randinex.scm' will be loaded as well.  `randinex.scm' contains
procedures for generating inexact distributions.

 - Function: random:uniform
 - Function: random:uniform state
     Returns an uniformly distributed inexact real random number in the
     range between 0 and 1.

 - Function: random:exp
 - Function: random:exp state
     Returns an inexact real in an exponential distribution with mean
     1.  For an exponential distribution with mean U use
     `(* U (random:exp))'.

 - Function: random:normal
 - Function: random:normal state
     Returns an inexact real in a normal distribution with mean 0 and
     standard deviation 1.  For a normal distribution with mean M and
     standard deviation D use `(+ M (* D (random:normal)))'.

 - Function: random:normal-vector! vect
 - Function: random:normal-vector! vect state
     Fills VECT with inexact real random numbers which are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

 - Function: random:hollow-sphere! vect
 - Function: random:hollow-sphere! vect state
     Fills VECT with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of VECT as coordinates in space
     of dimension n = `(vector-length VECT)', the coordinates are
     uniformly distributed over the surface of the unit n-shere.

 - Function: random:solid-sphere! vect
 - Function: random:solid-sphere! vect state
     Fills VECT with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of VECT as coordinates in
     space of dimension N = `(vector-length VECT)', the coordinates are
     uniformly distributed within the unit N-shere.  The sum of the
     squares of the numbers is returned.


File: slib.info,  Node: Fast Fourier Transform,  Next: Cyclic Checksum,  Prev: Random Numbers,  Up: Mathematical Packages

Fast Fourier Transform
======================

  `(require 'fft)'

 - Function: fft array
     ARRAY is an array of `(expt 2 n)' numbers.  `fft' returns an array
     of complex numbers comprising the "Discrete Fourier Transform" of
     ARRAY.

 - Function: fft-1 array
     `fft-1' returns an array of complex numbers comprising the inverse
     Discrete Fourier Transform of ARRAY.

  `(fft-1 (fft ARRAY))' will return an array of values close to ARRAY.

     (fft '#(1 0+i -1 0-i 1 0+i -1 0-i)) =>
     
     #(0.0 0.0 0.0+628.0783185208527e-18i 0.0
       0.0 0.0 8.0-628.0783185208527e-18i 0.0)
     
     (fft-1 '#(0 0 0 0 0 0 8 0)) =>
     
     #(1.0 -61.23031769111886e-18+1.0i -1.0 61.23031769111886e-18-1.0i
       1.0 -61.23031769111886e-18+1.0i -1.0 61.23031769111886e-18-1.0i)


File: slib.info,  Node: Cyclic Checksum,  Next: Plotting,  Prev: Fast Fourier Transform,  Up: Mathematical Packages

Cyclic Checksum
===============

  `(require 'crc)'                                                            |

Cyclic Redundancy Checks using Galois field GF(2) polynomial arithmetic       |
are used for error detection in many data transmission and storage            |
applications.                                                                 |

The generator polynomials for various CRC protocols are availble from         |
many sources.  But the polynomial is just one of many parameters which        |
must match in order for a CRC implementation to interoperate with             |
existing systems:                                                             |

   * the byte-order and bit-order of the data stream;                         |

   * whether the CRC or its inverse is being calculated;                      |

   * the initial CRC value; and                                               |

   * whether and where the CRC value is appended (inverted or                 |
     non-inverted) to the data stream.                                        |
                                                                              |

There is even some controversy over the polynomials themselves.               |

 - Constant: crc-32-polynomial                                                |
     For CRC-32, http://www2.sis.pitt.edu/~jkabara/tele-2100/lect08.html      |
     gives x^32+x^26+x^23+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+1.      |
                                                                              |
     But                                                                      |
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,    |
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,    |
     http://spinroot.com/spin/Doc/Book91_PDF/ch3.pdf,                         |
     http://www.erg.abdn.ac.uk/users/gorry/course/dl-pages/crc.html,          |
     http://www.rad.com/networks/1994/err_con/crc_most.htm, and               |
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html,                          |
     http://www.nobugconsulting.ro/crc.php give                               |
     x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.         |
                                                                              |
     Although these differ in bit 22, they calculate the identical sums.      |

                                                                              |
 - Constant: crc-ccitt-polynomial                                             |
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,    |
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,    |
     http://www2.sis.pitt.edu/~jkabara/tele-2100/lect08.html, and             |
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html give CRC-CCITT:           |
     x^16+x^12+x^5+1.                                                         |
                                                                              |
 - Constant: crc-16-polynomial                                                |
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,    |
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,    |
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html, and                      |
     http://www.usb.org/developers/data/crcdes.pdf give CRC-16:               |
     x^16+x^15+x^2+1.                                                         |
                                                                              |
 - Constant: crc-12-polynomial                                                |
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,    |
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html, and             |
     http://spinroot.com/spin/Doc/Book91_PDF/ch3.pdf give CRC-12:             |
     x^12+x^11+x^3+x^2+1.                                                     |
                                                                              |
     But                                                                      |
     http://www.ffldusoe.edu/Faculty/Denenberg/Topics/Networks/Error_Detection_Correction/crc.html,
     http://duchon.umuc.edu/Web_Pages/duchon/99_f_cm435/ShiftRegister.htm,    |
     http://www.eng.uwi.tt/depts/elec/staff/kimal/errorcc.html,               |
     http://www.ee.uwa.edu.au/~roberto/teach/itc314/java/CRC/,                |
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html, and                      |
     http://www.efg2.com/Lab/Mathematics/CRC.htm give CRC-12:                 |
     x^12+x^11+x^3+x^2+x+1.                                                   |
                                                                              |
     These differ in bit 1 and calculations using them return different       |
     values.  With citations evenly split, it is hard to know which is        |
     correct.                                                                 |
                                                                              |
 - Constant: crc-10-polynomial                                                |
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html
     gives CRC-10: x^10+x^9+x^5+x^4+1; but                                    |
     http://cell-relay.indiana.edu/cell-relay/publications/software/CRC/crc10.html,
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html,                 |
     http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html,                          |
     http://www.techfest.com/networking/atm/atm.htm,                          |
     http://www.protocols.com/pbook/atmcell2.htm, and                         |
     http://www.nobugconsulting.ro/crc.php give CRC-10:                       |
     x^10+x^9+x^5+x^4+x+1.                                                    |
                                                                              |
 - Constant: crc-08-polynomial                                                |
     http://www.math.grin.edu/~rebelsky/Courses/CS364/2000S/Outlines/outline.12.html,
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html,    |
     http://www.it.iitb.ac.in/it605/lectures/link/node4.html, and             |
     http://www.nobugconsulting.ro/crc.php give CRC-8: x^8+x^2+x^1+1          |
                                                                              |
 - Constant: atm-hec-polynomial                                               |
     http://cell-relay.indiana.edu/cell-relay/publications/software/CRC/32bitCRC.tutorial.html
     and http://www.gpfn.sk.ca/~rhg/csc8550s02/crc.html give ATM HEC:         |
     x^8+x^2+x+1.                                                             |
                                                                              |
 - Constant: dowcrc-polynomial                                                |
     http://www.cs.ncl.ac.uk/people/harry.whitfield/home.formal/CRCs.html     |
     gives DOWCRC: x^8+x^5+x^4+1.                                             |
                                                                              |
 - Constant: usb-token-polynomial                                             |
     http://www.usb.org/developers/data/crcdes.pdf and                        |
     http://www.nobugconsulting.ro/crc.php give USB-token: x^5+x^2+1.         |
                                                                              |
Each of these polynomial constants is a string of `1's and `0's, the          |
exponent of each power of X in descending order.                              |
                                                                              |
 - Function: crc:make-table poly                                              |
     POLY must be string of `1's and `0's beginning with `1' and having       |
     length greater than 8.  `crc:make-table' returns a vector of 256         |
     integers, such that:                                                     |
                                                                              |
          (set! CRC                                                           |
                (logxor (ash (logand (+ -1 (ash 1 (- DEG 8))) CRC) 8)         |
                        (vector-ref CRC-TABLE                                 |
                                    (logxor (ash CRC (- 8 DEG)) BYTE))))      |
                                                                              |
     will compute the CRC with the 8 additional bits in BYTE; where CRC       |
     is the previous accumulated CRC value, DEG is the degree of POLY,        |
     and CRC-TABLE is the vector returned by `crc:make-table'.                |
                                                                              |
     If the implementation does not support DEG-bit integers, then            |
     `crc:make-table' returns #f.                                             |
                                                                              |
                                                                              |
 - Function: cksum file                                                       |
     Computes the P1003.2/D11.2 (POSIX.2) 32-bit checksum of FILE.            |
                                                                              |
          (require 'crc)                                                      |
          (cksum (in-vicinity (library-vicinity) "ratize.scm"))               |
          => 157103930

 - Function: cksum port                                                       |
     Computes the checksum of the bytes read from PORT until the              |
     end-of-file.                                                             |
                                                                              |
                                                                              |
 - Function: cksum-string str                                                 |
     Returns the P1003.2/D11.2 (POSIX.2) 32-bit checksum of the bytes in      |
     STR.                                                                     |
                                                                              |
                                                                              |
 - Function: crc16 file                                                       |
     Computes the USB data-packet (16-bit) CRC of FILE.                       |
                                                                              |
 - Function: crc16 port                                                       |
     Computes the USB data-packet (16-bit) CRC of the bytes read from         |
     PORT until the end-of-file.                                              |
                                                                              |
     `crc16' calculates the same values as the crc16.pl program given         |
     in http://www.usb.org/developers/data/crcdes.pdf.                        |
                                                                              |
                                                                              |
 - Function: crc5 file                                                        |
     Computes the USB token (5-bit) CRC of FILE.                              |
                                                                              |
 - Function: crc5 port                                                        |
     Computes the USB token (5-bit) CRC of the bytes read from PORT           |
     until the end-of-file.                                                   |
                                                                              |
     `crc5' calculates the same values as the crc5.pl program given in        |
     http://www.usb.org/developers/data/crcdes.pdf.                           |
                                                                              |
                                                                              |

File: slib.info,  Node: Plotting,  Next: Solid Modeling,  Prev: Cyclic Checksum,  Up: Mathematical Packages

Plotting
========

  `(require 'charplot)'

 - Variable: charplot:dimensions
     A list of the maximum height (number of lines) and maximum width
     (number of columns) for the graph, its scales, and labels.

     The default value for CHARPLOT:DIMENSIONS is the
     `output-port-height' and `output-port-width' of
     `current-output-port'.

 - Procedure: plot coords x-label y-label
     COORDS is a list or vector of coordinates, lists of x and y
     coordinates.  X-LABEL and Y-LABEL are strings with which to label
     the x and y axes.

     Example:
          (require 'charplot)
          (set! charplot:dimensions '(19 45))
          
          (define (make-points n)
            (if (zero? n)
                '()
                (cons (cons (/ n 6) (sin (/ n 6))) (make-points (1- n)))))
          
          (plot (make-points 37) "x" "Sin(x)")
          -|
            Sin(x)   ____________________________________________
                1.25|-                                           |
                    |                                            |
                   1|-       ****                                |
                    |      **    **                              |
                0.75|-    *        *                             |
                    |    *          *                            |
                 0.5|-  *            *                           |
                    |  *                                         |
                0.25|-                *                          |
                    | *                *                         |
                   0|-------------------*------------------------|
                    |                                     *      |
               -0.25|-                   *               *       |
                    |                     *             *        |
                -0.5|-                     *                     |
                    |                       *          *         |
               -0.75|-                       *        *          |
                    |                         **    **           |
                  -1|-                          ****             |
                    |:_____._____:_____._____:_____._____:_____._|
               x                 2           4           6

 - Procedure: plot func x1 x2
 - Procedure: plot func x1 x2 npts
     Plots the function of one argument FUNC over the range X1 to X2.
     If the optional integer argument NPTS is supplied, it specifies
     the number of points to evaluate FUNC at.

          (plot sin 0 (* 2 pi))
          -|
                     ____________________________________________
                1.25|-:                                          |
                    | :                                          |
                   1|-:       ****                               |
                    | :     **    **                             |
                0.75|-:    *        *                            |
                    | :   *          *                           |
                 0.5|-:  **          **                          |
                    | : *             *                          |
                0.25|-:**              **                        |
                    | :*                *                        |
                   0|-*------------------*-----------------------|
                    | :                  *                 *     |
               -0.25|-:                   **              **     |
                    | :                    *             *       |
                -0.5|-:                     *           **       |
                    | :                      *          *        |
               -0.75|-:                       *       **         |
                    | :                        **    **          |
                  -1|-:                          ****            |
                    |_:_____._____:_____._____:_____._____:_____.|
                      0           2           4           6

 - Procedure: histograph data label
     Creates and displays a histogram of the numerical values contained
     in vector or list DATA

          (require 'random)
          (histograph (do ((idx 99 (+ -1 idx))
                           (lst '() (cons (* .02 (random:normal)) lst)))
                          ((negative? idx) lst))
                      "normal")
          -|
                     ____________________________________________
                   9|-                  :                        |
                    |                   :                        |
                   8|-               I  :                        |
                    |                I  :                        |
                   7|-             III II I                      |
                    |              III II I                      |
                   6|-             III II I   I                  |
                    |              III II I   I                  |
                   5|-             III II I  III                 |
                    |              III II I  III                 |
                   4|-            IIII IIIII III                 |
                    |             IIII IIIII III                 |
                   3|-            IIII IIIIIIIII                 |
                    |             IIII IIIIIIIII                 |
                   2|-         IIIIIII IIIIIIIII     I I I       |
                    |          IIIIIII IIIIIIIII     I I I       |
                   1|-II I III IIIIIII IIIIIIIIIII IIIIIII       |
                    | II I III IIIIIII IIIIIIIIIII IIIIIII       |
                   0|-IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII-------|
                    |____.____:____.____:____.____:____.____:____|
            normal          -0.025      0       0.025      0.05


File: slib.info,  Node: Solid Modeling,  Next: Color,  Prev: Plotting,  Up: Mathematical Packages

Solid Modeling
==============

  `(require 'solid)'

`http://swissnet.ai.mit.edu/~jaffer/Solid/#Example' gives an example
use of this package.

 - Function: vrml node ...
     Returns the VRML97 string (including header) of the concatenation
     of strings NODES, ....

 - Function: vrml-append node1 node2 ...
     Returns the concatenation with interdigitated newlines of strings
     NODE1, NODE2, ....

 - Function: vrml-to-file file node ...
     Writes to file named FILE the VRML97 string (including header) of
     the concatenation of strings NODES, ....

 - Function: world:info title info ...
     Returns a VRML97 string setting the title of the file in which it
     appears to TITLE.  Additional strings INFO, ... are comments.

VRML97 strings passed to `vrml' and `vrml-to-file' as arguments will
appear in the resulting VRML code.  This string turns off the headlight
at the viewpoint:
     " NavigationInfo {headlight FALSE}"

 - Function: scene:panorama front right back left top bottom
     Specifies the distant images on the inside faces of the cube
     enclosing the virtual world.

 - Function: scene:sphere colors angles
     COLORS is a list of color objects.  Each may be of type *Note
     color: Color Data-Type, a 24-bit sRGB integer, or a list of 3
     numbers between 0.0 and 1.0.

     ANGLES is a list of non-increasing angles the same length as
     COLORS.  Each angle is between 90 and -90 degrees.  If 90 or -90
     are not elements of ANGLES, then the color at the zenith and nadir
     are taken from the colors paired with the angles nearest them.

     `scene:sphere' fills horizontal bands with interpolated colors on
     the backgroud sphere encasing the world.

 - Function: scene:sky-and-dirt
     Returns a blue and brown backgroud sphere encasing the world.

 - Function: scene:sky-and-grass
     Returns a blue and green backgroud sphere encasing the world.

 - Function: scene:sun latitude julian-day hour turbidity strength
 - Function: scene:sun latitude julian-day hour turbidity
     LATITUDE is the virtual place's latitude in degrees.  JULIAN-DAY
     is an integer from 0 to 366, the day of the year.  HOUR is a real
     number from 0 to 24 for the time of day; 12 is noon.  TURBIDITY is
     the degree of fogginess described in *Note turbidity: Daylight.

     `scene:sun' returns a bright yellow, distant sphere where the sun
     would be at HOUR on JULIAN-DAY at LATITUDE.  If STRENGTH is
     positive, included is a light source of STRENGTH (default 1).

 - Function: scene:overcast latitude julian-day hour turbidity strength
 - Function: scene:overcast latitude julian-day hour turbidity
     LATITUDE is the virtual place's latitude in degrees.  JULIAN-DAY
     is an integer from 0 to 366, the day of the year.  HOUR is a real
     number from 0 to 24 for the time of day; 12 is noon.  TURBIDITY is
     the degree of cloudiness described in *Note turbidity: Daylight.

     `scene:overcast' returns an overcast sky as it might look at HOUR
     on JULIAN-DAY at LATITUDE.  If STRENGTH is positive, included is
     an ambient light source of STRENGTH (default 1).

Viewpoints are objects in the virtual world, and can be transformed
individually or with solid objects.

 - Function: scene:viewpoint name distance compass pitch
 - Function: scene:viewpoint name distance compass
     Returns a viewpoint named NAME facing the origin and placed
     DISTANCE from it.  COMPASS is a number from 0 to 360 giving the
     compass heading.  PITCH is a number from -90 to 90, defaulting to
     0, specifying the angle from the horizontal.

 - Function: scene:viewpoints proximity
     Returns 6 viewpoints, one at the center of each face of a cube
     with sides 2 * PROXIMITY, centered on the origin.

Light Sources
-------------

In VRML97, lights shine only on objects within the same children node
and descendants of that node.  Although it would have been convenient
to let light direction be rotated by `solid:rotation', this restricts a
rotated light's visibility to objects rotated with it.

To workaround this limitation, these directional light source
procedures accept either Cartesian or spherical coordinates for
direction.  A spherical coordinate is a list `(THETA AZIMUTH)'; where
THETA is the angle in degrees from the zenith, and AZIMUTH is the angle
in degrees due west of south.

It is sometimes useful for light sources to be brighter than `1'.  When
INTENSITY arguments are greater than 1, these functions gang multiple
sources to reach the desired strength.

 - Function: light:ambient color intensity
 - Function: light:ambient color
     Ambient light shines on all surfaces with which it is grouped.

     COLOR is a an object of type *Note color: Color Data-Type, a
     24-bit sRGB integer, or a list of 3 numbers between 0.0 and 1.0.
     If COLOR is #f, then the default color will be used.  INTENSITY is
     a real non-negative number defaulting to `1'.

     `light:ambient' returns a light source or sources of COLOR with
     total strength of INTENSITY (or 1 if omitted).

 - Function: light:directional color direction intensity
 - Function: light:directional color direction
 - Function: light:directional color
     Directional light shines parallel rays with uniform intensity on
     all objects with which it is grouped.

     COLOR is a an object of type *Note color: Color Data-Type, a
     24-bit sRGB integer, or a list of 3 numbers between 0.0 and 1.0.
     If COLOR is #f, then the default color will be used.

     DIRECTION must be a list or vector of 2 or 3 numbers specifying
     the direction to this light.  If DIRECTION has 2 numbers, then
     these numbers are the angle from zenith and the azimuth in
     degrees; if DIRECTION has 3 numbers, then these are taken as a
     Cartesian vector specifying the direction to the light source.
     The default direction is upwards; thus its light will shine down.

     INTENSITY is a real non-negative number defaulting to `1'.

     `light:directional' returns a light source or sources of COLOR
     with total strength of INTENSITY, shining from DIRECTION.

 - Function: light:beam attenuation radius aperture peak
 - Function: light:beam attenuation radius aperture
 - Function: light:beam attenuation radius
 - Function: light:beam attenuation
     ATTENUATION is a list or vector of three nonnegative real numbers
     specifying the reduction of intensity, the reduction of intensity
     with distance, and the reduction of intensity as the square of
     distance.  RADIUS is the distance beyond which the light does not
     shine.  RADIUS defaults to `100'.

     APERTURE is a real number between 0 and 180, the angle centered on
     the light's axis through which it sheds some light.  PEAK is a
     real number between 0 and 90, the angle of greatest illumination.

 - Function: light:point location color intensity beam
 - Function: light:point location color intensity
 - Function: light:point location color
 - Function: light:point location
     Point light radiates from LOCATION, intensity decreasing with
     distance, towards all objects with which it is grouped.

     COLOR is a an object of type *Note color: Color Data-Type, a
     24-bit sRGB integer, or a list of 3 numbers between 0.0 and 1.0.
     If COLOR is #f, then the default color will be used.  INTENSITY is
     a real non-negative number defaulting to `1'.  BEAM is a structure
     returned by `light:beam' or #f.

     `light:point' returns a light source or sources at LOCATION of
     COLOR with total strength INTENSITY and BEAM properties.  Note
     that the pointlight itself is not visible.  To make it so, place
     an object with emissive appearance at LOCATION.

 - Function: light:spot location direction color intensity beam
 - Function: light:spot location direction color intensity
 - Function: light:spot location direction color
 - Function: light:spot location direction
 - Function: light:spot location
     Spot light radiates from LOCATION towards DIRECTION, intensity
     decreasing with distance, illuminating objects with which it is
     grouped.

     DIRECTION must be a list or vector of 2 or 3 numbers specifying
     the direction to this light.  If DIRECTION has 2 numbers, then
     these numbers are the angle from zenith and the azimuth in
     degrees; if DIRECTION has 3 numbers, then these are taken as a
     Cartesian vector specifying the direction to the light source.
     The default direction is upwards; thus its light will shine down.

     COLOR is a an object of type *Note color: Color Data-Type, a
     24-bit sRGB integer, or a list of 3 numbers between 0.0 and 1.0.
     If COLOR is #f, then the default color will be used.

     INTENSITY is a real non-negative number defaulting to `1'.

     `light:spot' returns a light source or sources at LOCATION of
     DIRECTION with total strength COLOR.  Note that the spotlight
     itself is not visible.  To make it so, place an object with
     emissive appearance at LOCATION.

Object Primitives
-----------------

 - Function: solid:box geometry appearance
 - Function: solid:box geometry
     GEOMETRY must be a number or a list or vector of three numbers.
     If GEOMETRY is a number, the `solid:box' returns a cube with sides
     of length GEOMETRY centered on the origin.  Otherwise, `solid:box'
     returns a rectangular box with dimensions GEOMETRY centered on the
     origin.  APPEARANCE determines the surface properties of the
     returned object.

 - Function: solid:cylinder radius height appearance
 - Function: solid:cylinder radius height
     Returns a right cylinder with dimensions RADIUS and `(abs HEIGHT)'
     centered on the origin.  If HEIGHT is positive, then the cylinder
     ends will be capped.  APPEARANCE determines the surface properties
     of the returned object.

 - Function: solid:disk radius thickness appearance
 - Function: solid:disk radius thickness
     THICKNESS must be a positive real number.  `solid:disk' returns a
     circular disk with dimensions RADIUS and THICKNESS centered on the
     origin.  APPEARANCE determines the surface properties of the
     returned object.

 - Function: solid:cone radius height appearance
 - Function: solid:cone radius height
     Returns an isosceles cone with dimensions RADIUS and HEIGHT
     centered on the origin.  APPEARANCE determines the surface
     properties of the returned object.

 - Function: solid:pyramid side height appearance
 - Function: solid:pyramid side height
     Returns an isosceles pyramid with dimensions SIDE and HEIGHT
     centered on the origin.  APPEARANCE determines the surface
     properties of the returned object.

 - Function: solid:sphere radius appearance
 - Function: solid:sphere radius
     Returns a sphere of radius RADIUS centered on the origin.
     APPEARANCE determines the surface properties of the returned
     object.

 - Function: solid:ellipsoid geometry appearance
 - Function: solid:ellipsoid geometry
     GEOMETRY must be a number or a list or vector of three numbers.
     If GEOMETRY is a number, the `solid:ellipsoid' returns a sphere of
     diameter GEOMETRY centered on the origin.  Otherwise,
     `solid:ellipsoid' returns an ellipsoid with diameters GEOMETRY
     centered on the origin.  APPEARANCE determines the surface
     properties of the returned object.

Surface Attributes
------------------

 - Function: solid:color diffuseColor ambientIntensity specularColor
          shininess emissiveColor transparency
 - Function: solid:color diffuseColor ambientIntensity specularColor
          shininess emissiveColor
 - Function: solid:color diffuseColor ambientIntensity specularColor
          shininess
 - Function: solid:color diffuseColor ambientIntensity specularColor
 - Function: solid:color diffuseColor ambientIntensity
 - Function: solid:color diffuseColor
     Returns an "appearance", the optical properties of the objects
     with which it is associated.  AMBIENTINTENSITY, SHININESS, and
     TRANSPARENCY must be numbers between 0 and 1.  DIFFUSECOLOR,
     SPECULARCOLOR, and EMISSIVECOLOR are objects of type *Note color:
     Color Data-Type, 24-bit sRGB integers or lists of 3 numbers
     between 0.0 and 1.0.  If a color argument is omitted or #f, then
     the default color will be used.

 - Function: solid:texture image color scale rotation center translation
 - Function: solid:texture image color scale rotation center
 - Function: solid:texture image color scale rotation
 - Function: solid:texture image color scale
 - Function: solid:texture image color
 - Function: solid:texture image
     Returns an "appearance", the optical properties of the objects
     with which it is associated.  IMAGE is a string naming a JPEG or
     PNG image resource.  COLOR is #f, a color, or the string returned
     by `solid:color'.  The rest of the optional arguments specify
     2-dimensional transforms applying to the IMAGE.

     SCALE must be #f, a number, or list or vector of 2 numbers
     specifying the scale to apply to IMAGE.  ROTATION must be #f or
     the number of degrees to rotate IMAGE.  CENTER must be #f or a
     list or vector of 2 numbers specifying the center of IMAGE
     relative to the IMAGE dimensions.  TRANSLATION must be #f or a
     list or vector of 2 numbers specifying the translation to apply to
     IMAGE.

Aggregating Objects
-------------------

 - Function: solid:center-row-of number solid spacing
     Returns a row of NUMBER SOLID objects spaced evenly SPACING apart.

 - Function: solid:center-array-of number-a number-b solid spacing-a
          spacing-b
     Returns NUMBER-B rows, SPACING-B apart, of NUMBER-A SOLID objects
     SPACING-A apart.

 - Function: solid:center-pile-of number-a number-b number-c solid
          spacing-a spacing-b spacing-c
     Returns NUMBER-C planes, SPACING-C apart, of NUMBER-B rows,
     SPACING-B apart, of NUMBER-A SOLID objects SPACING-A apart.

 - Function: solid:arrow center
     CENTER must be a list or vector of three numbers.  Returns an
     upward pointing metallic arrow centered at CENTER.

 - Function: solid:arrow
     Returns an upward pointing metallic arrow centered at the origin.

Spatial Transformations
-----------------------

 - Function: solid:translation center solid ...
     CENTER must be a list or vector of three numbers.
     `solid:translation' Returns an aggregate of SOLIDS, ... with their
     origin moved to CENTER.

 - Function: solid:scale scale solid ...
     SCALE must be a number or a list or vector of three numbers.
     `solid:scale' Returns an aggregate of SOLIDS, ... scaled per SCALE.

 - Function: solid:rotation axis angle solid ...
     AXIS must be a list or vector of three numbers.  `solid:rotation'
     Returns an aggregate of SOLIDS, ... rotated ANGLE degrees around
     the axis AXIS.


File: slib.info,  Node: Color,  Next: Root Finding,  Prev: Solid Modeling,  Up: Mathematical Packages

Color
=====

  `http://swissnet.ai.mit.edu/~jaffer/Color'

The goals of this package are to provide methods to specify, compute,
and transform colors in a core set of additive color spaces.  The color
spaces supported should be sufficient for working with the color data
encountered in practice and the literature.

* Menu:

* Color Data-Type::             'color
* Color Spaces::                XYZ, L*a*b*, L*u*v*, L*C*h, RGB709, sRGB
* Spectra::                     Color Temperatures and CIEXYZ(1931)
* Color Difference Metrics::    Society of Dyers and Colorists
* Color Conversions::           Low-level
* Color Names::                 in relational databases
* Daylight::                    Sunlight and sky colors


File: slib.info,  Node: Color Data-Type,  Next: Color Spaces,  Prev: Color,  Up: Color

Color Data-Type
---------------

  `(require 'color)'

 - Function: color? obj
     Returns #t if OBJ is a color.

 - Function: color? obj typ
     Returns #t if OBJ is a color of color-space TYP.  The symbol TYP
     must be one of:

        * CIEXYZ

        * RGB709

        * L*a*b*

        * L*u*v*

        * sRGB

        * e-sRGB

        * L*C*h

 - Function: make-color space arg ...
     Returns a color of type SPACE.

 - Function: color-space color
     Returns the symbol for the color-space in which COLOR is embedded.

 - Function: color-precision color
     For colors in digital color-spaces, `color-precision' returns the
     number of bits used for each of the R, G, and B channels of the
     encoding.  Otherwise, `color-precision' returns #f

 - Function: color-white-point color
     Returns the white-point of COLOR in all color-spaces except CIEXYZ.

 - Function: convert-color color space white-point
 - Function: convert-color color space
 - Function: convert-color color e-sRGB precision
     Converts COLOR into SPACE at optional WHITE-POINT.

External Representation
.......................

Each color encoding has an external, case-insensitive representation.
To ensure portability, the white-point for all color strings is D65.
(1)

Color Space              External Representation
CIEXYZ                   CIEXYZ:<X>/<Y>/<Z>
RGB709                   RGBi:<R>/<G>/<B>
L*a*b*                   CIELAB:<L>/<a>/<b>
L*u*v*                   CIELuv:<L>/<u>/<v>
L*C*h                    CIELCh:<L>/<C>/<h>

The X, Y, Z, L, A, B, U, V, C, H, R, G, and B fields are (Scheme) real
numbers within the appropriate ranges.

Color Space              External Representation
sRGB                     sRGB:<R>/<G>/<B>
e-sRGB10                 e-sRGB10:<R>/<G>/<B>
e-sRGB12                 e-sRGB12:<R>/<G>/<B>
e-sRGB16                 e-sRGB16:<R>/<G>/<B>

The R, G, and B, fields are non-negative exact decimal integers within
the appropriate ranges.

Several additional syntaxes are supported by `string->color':

Color Space              External Representation
sRGB                     sRGB:<RRGGBB>
sRGB                     #<RRGGBB>
sRGB                     0x<RRGGBB>
sRGB                     #x<RRGGBB>

  Where RRGGBB is a non-negative six-digit hexadecimal number.

 - Function: color->string color
     Returns a string representation of COLOR.

 - Function: string->color string
     Returns the color represented by STRING.  If STRING is not a
     syntactically valid notation for a color, then `string->color'
     returns #f.

White
.....

We experience color relative to the illumination around us.  CIEXYZ
coordinates, although subject to uniform scaling, are objective.  Thus
other color spaces are specified relative to a "white point" in CIEXYZ
coordinates.

The white point for digital color spaces is set to D65.  For the other
spaces a WHITE-POINT argument can be specified.  The default if none is
specified is the white-point with which the color was created or last
converted; and D65 if none has been specified.

 - Constant: D65
     Is the color of 6500.K (blackbody) illumination.  D65 is close to
     the average color of daylight.

 - Constant: D50
     Is the color of 5000.K (blackbody) illumination.  D50 is the color
     of indoor lighting by incandescent bulbs, whose filaments have
     temperatures around 5000.K.

  ---------- Footnotes ----------

  (1) Readers may recognize these color string formats from Xlib.
X11's color management system was doomed by its fiction that CRT
monitors' (and X11 default) color-spaces were linear RGBi.  Unable to
shed this legacy, the only practical way to view pictures on X is to
ignore its color management system and use an sRGB monitor.  In this
implementation the device-independent RGB709 and sRGB spaces replace the
device-dependent RGBi and RGB spaces of Xlib.


File: slib.info,  Node: Color Spaces,  Next: Spectra,  Prev: Color Data-Type,  Up: Color

Color Spaces
------------

Measurement-based Color Spaces
..............................

The "tristimulus" color spaces are those whose component values are
proportional measurements of light intensity.  The CIEXYZ(1931) system
provides 3 sets of spectra to convolve with a spectrum of interest.
The result of those convolutions is coordinates in CIEXYZ space.  All
tristimuls color spaces are related to CIEXYZ by linear transforms,
namely matrix multiplication.  Of the color spaces listed here, CIEXYZ
and RGB709 are tristimulus spaces.

 - Color Space: CIEXYZ
     The CIEXYZ color space covers the full "gamut".  It is the basis
     for color-space conversions.

     CIEXYZ is a list of three inexact numbers between 0 and 1.1.  '(0.
     0. 0.) is black; '(1. 1. 1.) is white.

 - Function: ciexyz->color xyz
     XYZ must be a list of 3 numbers.  If XYZ is valid CIEXYZ
     coordinates, then `ciexyz->color' returns the color specified by
     XYZ; otherwise returns #f.

 - Function: color:ciexyz x y z
     Returns the CIEXYZ color composed of X, Y, Z.  If the coordinates
     do not encode a valid CIEXYZ color, then an error is signaled.

 - Function: color->ciexyz color
     Returns the list of 3 numbers encoding COLOR in CIEXYZ.

 - Color Space: RGB709
     BT.709-4 (03/00) `Parameter values for the HDTV standards for
     production and international programme exchange' specifies
     parameter values for chromaticity, sampling, signal format, frame
     rates, etc., of high definition television signals.

     An RGB709 color is represented by a list of three inexact numbers
     between 0 and 1.  '(0. 0. 0.) is black '(1. 1. 1.) is white.

 - Function: rgb709->color rgb
     RGB must be a list of 3 numbers.  If RGB is valid RGB709
     coordinates, then `rgb709->color' returns the color specified by
     RGB; otherwise returns #f.

 - Function: color:rgb709 r g b
     Returns the RGB709 color composed of R, G, B.  If the coordinates
     do not encode a valid RGB709 color, then an error is signaled.

 - Function: color->rgb709 color
     Returns the list of 3 numbers encoding COLOR in RGB709.

Perceptual Uniformity
.....................

Although properly encoding the chromaticity, tristimulus spaces do not
match the logarithmic response of human visual systems to intensity.
Minimum detectable differences between colors correspond to a smaller
range of distances (6:1) in the L*a*b* and L*u*v* spaces than in
tristimulus spaces (80:1).  For this reason, color distances are
computed in L*a*b* (or L*C*h).

 - Color Space: L*a*b*
     Is a CIE color space which better matches the human visual system's
     perception of color.  It is a list of three numbers:

        * 0 <= L* <= 100 (CIE "Lightness")

        * -500 <= a* <= 500

        * -200 <= b* <= 200

 - Function: l*a*b*->color L*a*b* white-point
     L*A*B* must be a list of 3 numbers.  If L*A*B* is valid L*a*b*
     coordinates, then `l*a*b*->color' returns the color specified by
     L*A*B*; otherwise returns #f.

 - Function: color:l*a*b* L* a* b* white-point
     Returns the L*a*b* color composed of L*, A*, B* with WHITE-POINT.

 - Function: color:l*a*b* L* a* b*
     Returns the L*a*b* color composed of L*, A*, B*.  If the
     coordinates do not encode a valid L*a*b* color, then an error is
     signaled.

 - Function: color->l*a*b* color white-point
     Returns the list of 3 numbers encoding COLOR in L*a*b* with
     WHITE-POINT.

 - Function: color->l*a*b* color
     Returns the list of 3 numbers encoding COLOR in L*a*b*.

 - Color Space: L*u*v*
     Is another CIE encoding designed to better match the human visual
     system's perception of color.

 - Function: l*u*v*->color L*u*v* white-point
     L*U*V* must be a list of 3 numbers.  If L*U*V* is valid L*u*v*
     coordinates, then `l*u*v*->color' returns the color specified by
     L*U*V*; otherwise returns #f.

 - Function: color:l*u*v* L* u* v* white-point
     Returns the L*u*v* color composed of L*, U*, V* with WHITE-POINT.

 - Function: color:l*u*v* L* u* v*
     Returns the L*u*v* color composed of L*, U*, V*.  If the
     coordinates do not encode a valid L*u*v* color, then an error is
     signaled.

 - Function: color->l*u*v* color white-point
     Returns the list of 3 numbers encoding COLOR in L*u*v* with
     WHITE-POINT.

 - Function: color->l*u*v* color
     Returns the list of 3 numbers encoding COLOR in L*u*v*.

Cylindrical Coordinates
.......................

HSL (Hue Saturation Lightness), HSV (Hue Saturation Value), HSI (Hue
Saturation Intensity) and HCI (Hue Chroma Intensity) are cylindrical
color spaces (with angle hue).  But these spaces are all defined in
terms device-dependent RGB spaces.

One might wonder if there is some fundamental reason why intuitive
specification of color must be device-dependent.  But take heart!  A
cylindrical system can be based on L*a*b* and is used for predicting how
close colors seem to observers.

 - Color Space: L*C*h
     Expresses the *a and b* of L*a*b* in polar coordinates.  It is a
     list of three numbers:

        * 0 <= L* <= 100 (CIE "Lightness")

        * C* (CIE "Chroma") is the distance from the neutral (gray)
          axis.

        * 0 <= h <= 360 (CIE "Hue") is the angle.

     The colors by quadrant of h are:

     0             red, orange, yellow                      90
     90            yellow, yellow-green, green              180
     180           green, cyan (blue-green), blue           270
     270           blue, purple, magenta                    360


 - Function: l*c*h->color L*C*h white-point
     L*C*H must be a list of 3 numbers.  If L*C*H is valid L*C*h
     coordinates, then `l*c*h->color' returns the color specified by
     L*C*H; otherwise returns #f.

 - Function: color:l*c*h L* C* h white-point
     Returns the L*C*h color composed of L*, C*, H with WHITE-POINT.

 - Function: color:l*c*h L* C* h
     Returns the L*C*h color composed of L*, C*, H.  If the coordinates
     do not encode a valid L*C*h color, then an error is signaled.

 - Function: color->l*c*h color white-point
     Returns the list of 3 numbers encoding COLOR in L*C*h with
     WHITE-POINT.

 - Function: color->l*c*h color
     Returns the list of 3 numbers encoding COLOR in L*C*h.

Digital Color Spaces
....................

The color spaces discussed so far are impractical for image data because
of numerical precision and computational requirements.  In 1998 the IEC
adopted `A Standard Default Color Space for the Internet - sRGB'
(<http://www.w3.org/Graphics/Color/sRGB>).  sRGB was cleverly designed
to employ the 24-bit (256x256x256) color encoding already in widespread
use; and the 2.2 gamma intrinsic to CRT monitors.

Conversion from CIEXYZ to digital (sRGB) color spaces is accomplished by
conversion first to a RGB709 tristimulus space with D65 white-point;
then each coordinate is individually subjected to the same non-linear
mapping.  Inverse operations in the reverse order create the inverse
transform.

 - Color Space: sRGB
     Is "A Standard Default Color Space for the Internet".  Most display
     monitors will work fairly well with sRGB directly.  Systems using
     ICC profiles (1) should work very well with sRGB.


 - Function: srgb->color rgb
     RGB must be a list of 3 numbers.  If RGB is valid sRGB coordinates,
     then `srgb->color' returns the color specified by RGB; otherwise
     returns #f.

 - Function: color:srgb r g b
     Returns the sRGB color composed of R, G, B.  If the coordinates do
     not encode a valid sRGB color, then an error is signaled.

 - Color Space: xRGB
     Represents the equivalent sRGB color with a single 24-bit integer.
     The most significant 8 bits encode red, the middle 8 bits blue,
     and the least significant 8 bits green.

 - Function: color->srgb color
     Returns the list of 3 integers encoding COLOR in sRGB.

 - Function: color->xrgb color
     Returns the 24-bit integer encoding COLOR in sRGB.

 - Function: xrgb->color k
     Returns the sRGB color composed of the 24-bit integer K.

 - Color Space: e-sRGB
     Is "Photography - Electronic still picture imaging - Extended sRGB
     color encoding" (PIMA 7667:2001).  It extends the gamut of sRGB;
     and its higher precision numbers provide a larger dynamic range.

     A triplet of integers represent e-sRGB colors.  Three precisions
     are supported:

    e-sRGB10
          0 to 1023

    e-sRGB12
          0 to 4095

    e-sRGB16
          0 to 65535

 - Function: e-srgb->color precision rgb
     PRECISION must be the integer 10, 12, or 16.  RGB must be a list
     of 3 numbers.  If RGB is valid e-sRGB coordinates, then
     `e-srgb->color' returns the color specified by RGB; otherwise
     returns #f.

 - Function: color:e-srgb 10 r g b
     Returns the e-sRGB10 color composed of integers R, G, B.

 - Function: color:e-srgb 12 r g b
     Returns the e-sRGB12 color composed of integers R, G, B.

 - Function: color:e-srgb 16 r g b
     Returns the e-sRGB16 color composed of integers R, G, B.  If the
     coordinates do not encode a valid e-sRGB color, then an error is
     signaled.

 - Function: color->e-srgb precision color
     PRECISION must be the integer 10, 12, or 16.  `color->e-srgb'
     returns the list of 3 integers encoding COLOR in sRGB10, sRGB12,
     or sRGB16.

  ---------- Footnotes ----------

  (1)

A comprehensive encoding of transforms between CIEXYZ and device color
spaces is the International Color Consortium profile format,
ICC.1:1998-09:

     The intent of this format is to provide a cross-platform device
     profile format.  Such device profiles can be used to translate
     color data created on one device into another device's native
     color space.


File: slib.info,  Node: Spectra,  Next: Color Difference Metrics,  Prev: Color Spaces,  Up: Color

Spectra
-------

The following functions compute colors from spectra, scale color
luminance, and extract chromaticity.  XYZ is used in the names of
procedures for unnormalized colors; the coordinates of CIEXYZ colors are
constrained as described in *Note Color Spaces::.

  `(require 'color-space)'

A spectrum may be represented as:

   * A procedure of one argument accepting real numbers from 380e-9 to
     780e-9, the wavelength in meters; or

   * A vector of real numbers representing intensity samples evenly
     spaced over some range of wavelengths overlapping the range 380e-9
     to 780e-9.

CIEXYZ values are calculated as dot-product with the X, Y (Luminance),
and Z "Spectral Tristimulus Values".  The files `cie1931.xyz' and
`cie1964.xyz' in the distribution contain these CIE-defined values.

 - Feature: cie1964
     Loads the Spectral Tristimulus Values defining `CIE 1964
     Supplementary Standard Colorimetric Observer'.

 - Feature: cie1931
     Loads the Spectral Tristimulus Values defining `CIE 1931
     Supplementary Standard Colorimetric Observer'.

 - Feature: ciexyz
     Requires Spectral Tristimulus Values, defaulting to cie1931.

`(require 'cie1964)' or `(require 'cie1931)' will load specific values
used by the following spectrum conversion procedures.  The spectrum
conversion procedures `(require 'ciexyz)' to assure that a set is
loaded.

 - Function: spectrum->XYZ proc
     PROC must be a function of one argument.  `spectrum->XYZ' computes
     the CIEXYZ(1931) values for the spectrum returned by PROC when
     called with arguments from 380e-9 to 780e-9, the wavelength in
     meters.

 - Function: spectrum->XYZ spectrum x1 x2
     X1 and X2 must be positive real numbers specifying the wavelengths
     (in meters) corresponding to the zeroth and last elements of
     vector or list SPECTRUM.  `spectrum->XYZ' returns the CIEXYZ(1931)
     values for a light source with spectral values proportional to the
     elements of SPECTRUM at evenly spaced wavelengths between X1 and
     X2.

     Compute the colors of 6500.K and 5000.K blackbody radiation:

          (require 'color-space)
          (define xyz (spectrum->XYZ (blackbody-spectrum 6500)))
          (define y_n (cadr xyz))
          (map (lambda (x) (/ x y_n)) xyz)
              => (0.9687111145512467 1.0 1.1210875945303613)
          
          (define xyz (spectrum->XYZ (blackbody-spectrum 5000)))
          (map (lambda (x) (/ x y_n)) xyz)
              => (0.2933441826889158 0.2988931825387761 0.25783646831201573)

 - Function: spectrum->CIEXYZ proc
 - Function: spectrum->CIEXYZ spectrum x1 x2
     `spectrum->CIEXYZ' computes the CIEXYZ(1931) values for the
     spectrum, scaled so their sum is 1.

 - Function: spectrum->chromaticity proc
 - Function: spectrum->chromaticity spectrum x1 x2
     Computes the chromaticity for the given spectrum.

 - Function: wavelength->XYZ w
 - Function: wavelength->chromaticity w
 - Function: wavelength->CIEXYZ w
     W must be a number between 380e-9 to 780e-9.  `wavelength->XYZ'
     returns (unnormalized) XYZ values for a monochromatic light source
     with wavelength W.  `wavelength->chromaticity' returns the
     chromaticity for a monochromatic light source with wavelength W.
     `wavelength->CIEXYZ' returns XYZ values for the saturated color
     having chromaticity of a monochromatic light source with wavelength
     W.

 - Function: blackbody-spectrum temp
 - Function: blackbody-spectrum temp span
     Returns a procedure of one argument (wavelength in meters), which
     returns the radiance of a black body at TEMP.

     The optional argument SPAN is the wavelength analog of bandwidth.
     With the default SPAN of 1.nm (1e-9.m), the values returned by the
     procedure correspond to the power of the photons with wavelengths
     W to W+1e-9.

 - Function: temperature->XYZ x
     The positive number X is a temperature in degrees kelvin.
     `temperature->XYZ' computes the CIEXYZ(1931) values for the
     spectrum of a black body at temperature X.

     Compute the chromaticities of 6500.K and 5000.K blackbody
     radiation:

          (require 'color-space)
          (XYZ->chromaticity (temperature->XYZ 6500))
              => (0.3135191660557008 0.3236456786200268)
          
          (XYZ->chromaticity (temperature->XYZ 5000))
              => (0.34508082841161052 0.3516084965163377)

 - Function: temperature->CIEXYZ x
     The positive number X is a temperature in degrees kelvin.
     `temperature->CIEXYZ' computes the CIEXYZ(1931) values for the
     spectrum of a black body at temperature X, scaled to be just
     inside the RGB709 gamut.

 - Function: XYZ:normalize xyz
     XYZ is a list of three non-negative real numbers.  `XYZ:normalize'
     returns a list of numbers proportional to XYZ; scaled so their sum
     is 1.

 - Function: XYZ:normalize-colors colors ...
     COLORS is a list of XYZ triples.  `XYZ:normalize-colors' scales
     all the triples by a common factor such that the maximum sum of
     numbers in a scaled triple is 1.

 - Function: XYZ->chromaticity xyz
     Returns a two element list: the x and y components of XYZ
     normalized to 1 (= X + Y + Z).

 - Function: chromaticity->CIEXYZ x y
     Returns the list of X, and Y, 1 - Y - X.

 - Function: chromaticity->whitepoint x y
     Returns the CIEXYZ(1931) values having luminosity 1 and
     chromaticity X and Y.

Many color datasets are expressed in "xyY" format; chromaticity with
CIE luminance (Y).  But xyY is not a CIE standard like CIEXYZ, CIELAB,
and CIELUV.  Although chrominance is well defined, the luminance
component is sometimes scaled to 1, sometimes to 100, but usually has no
obvious range.  With no given whitepoint, the only reasonable course is
to ascertain the luminance range of a dataset and normalize the values
to lie from 0 to 1.

 - Function: XYZ->xyY xyz
     Returns a three element list: the X and Y components of XYZ
     normalized to 1, and CIE luminance Y.

 - Function: xyY->XYZ xyY

 - Function: xyY:normalize-colors colors
     COLORS is a list of xyY triples.  `xyY:normalize-colors' scales
     each chromaticity so it sums to 1 or less; and divides the Y
     values by the maximum Y in the dataset, so all lie between 0 and 1.

 - Function: xyY:normalize-colors colors n
     If N is positive real, then `xyY:normalize-colors' divides the Y
     values by N times the maximum Y in the dataset.

     If N is an exact non-positive integer, then `xyY:normalize-colors'
     divides the Y values by the maximum of the Ys in the dataset
     excepting the -N largest Y values.

     In all cases, returned Y values are limited to lie from 0 to 1.

Why would one want to normalize to other than 1?  If the sun or its
reflection is the brightest object in a scene, then normalizing to its
luminance will tend to make the rest of the scene very dark.  As with
photographs, limiting the specular highlights looks better than
darkening everything else.

The results of measurements being what they are, `xyY:normalize-colors'
is extremely tolerant.  Negative numbers are replaced with zero, and
chromaticities with sums greater than one are scaled to sum to one.


File: slib.info,  Node: Color Difference Metrics,  Next: Color Conversions,  Prev: Spectra,  Up: Color

Color Difference Metrics
------------------------

 - Function: CIE:DE* color1 color2 white-point
 - Function: CIE:DE* color1 color2
     Returns the Euclidean distance in L*a*b* space between COLOR1 and
     COLOR2.

 - Function: CIE:DE*94 color1 color2 parametric-factors
 - Function: CIE:DE*94 color1 color2
     `CIE:DE*94' measures distance in the L*C*h cylindrical color-space.
     The three axes are individually scaled (depending on C*) in their
     contributions to the total distance.

     The CIE has defined reference conditions under which the metric
     with default parameters can be expected to perform well.  These
     are:

        * The specimens are homogeneous in colour.

        * The colour difference (CIELAB) is <= 5 units.

        * They are placed in direct edge contact.

        * Each specimen subtends an angle of >4 degrees to the
          assessor, whose colour vision is normal.

        * They are illuminated at 1000 lux, and viewed against a
          background of uniform grey, with L* of 50, under illumination
          simulating D65.

     The PARAMETRIC-FACTORS argument is a list of 3 quantities kL, kC
     and kH.  PARAMETRIC-FACTORS independently adjust each
     colour-difference term to account for any deviations from the
     reference viewing conditions.  Under the reference conditions
     explained above, the default is kL = kC = kH = 1.

The Color Measurement Committee of The Society of Dyers and Colorists in
Great Britain created a more sophisticated color-distance function for
use in judging the consistency of dye lots.  With CMC:DE* it is possible
to use a single value pass/fail tolerance for all shades.

 - Function: CMC:DE* color1 color2 l c
 - Function: CMC:DE* color1 color2
     `CMC:DE*' is also a L*C*h metric.  The PARAMETRIC-FACTORS argument
     is a list of 2 numbers L and C.  L and C parameterize this metric.
     1 and 1 are recommended for perceptibility; the default, 2 and 1,
     for acceptability.


File: slib.info,  Node: Color Conversions,  Next: Color Names,  Prev: Color Difference Metrics,  Up: Color

Color Conversions
-----------------

This package contains the low-level color conversion and color metric
routines operating on lists of 3 numbers.  There is no type or range
checking.

  `(require 'color-space)'

 - Constant: CIEXYZ:D65
     Is the color of 6500.K (blackbody) illumination.  D65 is close to
     the average color of daylight.

 - Constant: CIEXYZ:D50
     Is the color of 5000.K (blackbody) illumination.  D50 is the color
     of indoor lighting by incandescent bulbs.

 - Constant: CIEXYZ:A
 - Constant: CIEXYZ:B
 - Constant: CIEXYZ:C
 - Constant: CIEXYZ:E
     CIE 1931 illuminants normalized to 1 = y.

 - Function: CIEXYZ->RGB709 xyz
 - Function: RGB709->CIEXYZ srgb

 - Function: CIEXYZ->L*u*v* xyz white-point
 - Function: CIEXYZ->L*u*v* xyz
 - Function: L*u*v*->CIEXYZ L*u*v* white-point
 - Function: L*u*v*->CIEXYZ L*u*v*
     The WHITE-POINT defaults to CIEXYZ:D65.

 - Function: CIEXYZ->L*a*b* xyz white-point
 - Function: CIEXYZ->L*a*b* xyz
 - Function: L*a*b*->CIEXYZ L*a*b* white-point
 - Function: L*a*b*->CIEXYZ L*a*b*
     The XYZ WHITE-POINT defaults to CIEXYZ:D65.

 - Function: L*a*b*->L*C*h L*a*b*
 - Function: L*C*h->L*a*b* L*C*h

 - Function: CIEXYZ->sRGB xyz
 - Function: sRGB->CIEXYZ srgb

 - Function: CIEXYZ->e-sRGB n xyz
 - Function: e-sRGB->CIEXYZ n srgb

 - Function: sRGB->e-sRGB n srgb
 - Function: e-sRGB->sRGB n srgb
     The integer N must be 10, 12, or 16.  Because sRGB and e-sRGB use
     the same RGB709 chromaticities, conversion between them is simpler
     than conversion through CIEXYZ.

Do not convert e-sRGB precision through `e-sRGB->sRGB' then
`sRGB->e-sRGB' - values would be truncated to 8-bits!

 - Function: e-sRGB->e-sRGB n1 srgb n2
     The integers N1 and N2 must be 10, 12, or 16.  `e-sRGB->e-sRGB'
     converts SRGB to e-sRGB of precision N2.

 - Function: L*a*b*:DE lab1 lab2
     Returns the Euclidean distance between LAB1 and LAB2.

 - Function: L*C*h:DE*94 lch1 lch2 parametric-factors
 - Function: L*C*h:DE*94 lch1 lch2
     `L*C*h:DE*94' measures distance in the L*C*h cylindrical
     color-space between LCH1 and LCH2.  The three axes are individually
     scaled (depending on C*) in their contributions to the total
     distance.

 - Function: CMC-DE lch1 lch2 parametric-factors
 - Function: CMC-DE lch1 lch2 l c
 - Function: CMC-DE lch1 lch2 l
 - Function: CMC-DE lch1 lch2
     `CMC:DE' is a L*C*h metric.  The PARAMETRIC-FACTORS argument is a
     list of 2 numbers L and C.  L and C parameterize this metric.  1
     and 1 are recommended for perceptibility; the default, 2 and 1,
     for acceptability.


File: slib.info,  Node: Color Names,  Next: Daylight,  Prev: Color Conversions,  Up: Color

Color Names
-----------

  `(require 'color-names)'

Rather than ballast the color dictionaries with numbered grays,
`file->color-dictionary' discards them.  They are provided through the
`grey' procedure:

 - Function: grey k
     Returns `(inexact->exact (round (* k 2.55)))', the X11 color
     grey<k>.

A color dictionary is a database table relating "canonical" color-names
to color-strings (*note External Representation: Color Data-Type.).

The column names in a color dictionary are unimportant; the first field
is the key, and the second is the color-string.

 - Function: color-name:canonicalize name
     Returns a downcased copy of the string or symbol NAME with `_',
     `-', and whitespace removed.

 - Function: color-name->color name table1 table2 ...
     TABLE1, TABLE2, ... must be color-dictionary tables.
     `color-name->color' searches for the canonical form of NAME in
     TABLE1, TABLE2, ... in order; returning the color-string of the
     first matching record; #f otherwise.

 - Function: color-dictionaries->lookup table1 table2 ...
     TABLE1, TABLE2, ... must be color-dictionary tables.
     `color-dictionaries->lookup' returns a procedure which searches
     for the canonical form of its string argument in TABLE1, TABLE2,
     ...; returning the color-string of the first matching record; and
     #f otherwise.

 - Function: color-dictionary name rdb base-table-type
     RDB must be a string naming a relational database file; and the
     symbol NAME a table therein.  The database will be opened as
     BASE-TABLE-TYPE.  `color-dictionary' returns the read-only table
     NAME in database NAME if it exists; #f otherwise.

 - Function: color-dictionary name rdb
     RDB must be an open relational database or a string naming a
     relational database file; and the symbol NAME a table therein.
     `color-dictionary' returns the read-only table NAME in database
     NAME if it exists; #f otherwise.

 - Function: load-color-dictionary name rdb base-table-type
 - Function: load-color-dictionary name rdb
     RDB must be a string naming a relational database file; and the
     symbol NAME a table therein.  If the symbol BASE-TABLE-TYPE is
     provided, the database will be opened as BASE-TABLE-TYPE.
     `load-color-dictionary' creates a top-level definition of the
     symbol NAME to a lookup procedure for the color dictionary NAME in
     RDB.

     The value returned by `load-color-dictionary' is unspecified.

Dictionary Creation
...................

 - Function: file->color-dictionary file table-name rdb base-table-type
 - Function: file->color-dictionary file table-name rdb
     RDB must be an open relational database or a string naming a
     relational database file, TABLE-NAME a symbol, and the string FILE
     must name an existing file with colornames and their corresponding
     xRGB (6-digit hex) values.  `file->color-dictionary' creates a
     table TABLE-NAME in RDB and enters the associations found in FILE
     into it.

 - Function: url->color-dictionary url table-name rdb base-table-type
 - Function: url->color-dictionary url table-name rdb
     RDB must be an open relational database or a string naming a
     relational database file and TABLE-NAME a symbol.
     `url->color-dictionary' retrieves the resource named by the string
     URL using the "wget" program; then calls `file->color-dictionary'
     to enter its associations in TABLE-NAME in URL.

This section has detailed the procedures for creating and loading color
dictionaries.  So where are the dictionaries to load?

  `http://swissnet.ai.mit.edu/~jaffer/Color/Dictionaries.html'

Describes and evaluates several color-name dictionaries on the web.
The following procedure creates a database containing two of these
dictionaries.

 - Function: make-slib-color-name-db
     Creates an alist-table relational database in library-vicinity
     containing the "Resene" and "saturate" color-name dictionaries.

     If the files `resenecolours.txt' and `saturate.txt' exist in the
     library-vicinity, then they used as the source of color-name data.
     Otherwise, `make-slib-color-name-db' calls url->color-dictionary
     with the URLs of appropriate source files.

The Short List
..............

  `(require 'saturate)'

 - Function: saturate name
     Looks for NAME among the 19 saturated colors from `Approximate
     Colors on CIE Chromaticity Diagram':

     reddish orange    orange            yellowish orange  yellow
     greenish yellow   yellow green      yellowish green   green
     bluish green      blue green        greenish blue     blue
     purplish blue     bluish purple     purple            reddish purple
     red purple        purplish red      red               

     (<http://swissnet.ai.mit.edu/~jaffer/Color/saturate.pdf>).  If
     NAME is found, the corresponding color is returned.  Otherwise #f
     is returned.  Use saturate only for light source colors.

Resene Paints Limited, New Zealand's largest privately-owned and
operated paint manufacturing company, has generously made their `Resene
RGB Values List' available.

  `(require 'resene)'

 - Function: resene name
     Looks for NAME among the 1300 entries in the Resene color-name
     dictionary (<http://swissnet.ai.mit.edu/~jaffer/Color/resene.pdf>).
     If NAME is found, the corresponding color is returned.  Otherwise
     #f is returned.  The `Resene RGB Values List' is an excellent
     source for surface colors.

If you include the "Resene RGB Values List" in binary form in a
program, then you must include its license with your program:

     Resene RGB Values List
     For further information refer to http://www.resene.co.nz
     Copyright Resene Paints Ltd 2001

     Permission to copy this dictionary, to modify it, to redistribute
     it, to distribute modified versions, and to use it for any purpose
     is granted, subject to the following restrictions and
     understandings.

       1. Any text copy made of this dictionary must include this
          copyright notice in full.

       2. Any redistribution in binary form must reproduce this
          copyright notice in the documentation or other materials
          provided with the distribution.

       3. Resene Paints Ltd makes no warrantee or representation that
          this dictionary is error-free, and is under no obligation to
          provide any services, by way of maintenance, update, or
          otherwise.

       4. There shall be no use of the name of Resene or Resene Paints
          Ltd in any advertising, promotional, or sales literature
          without prior written consent in each case.

       5. These RGB colour formulations may not be used to the
          detriment of Resene Paints Ltd.


File: slib.info,  Node: Daylight,  Prev: Color Names,  Up: Color

Daylight
--------

  `(require 'daylight)'

This package calculates the colors of sky as detailed in:
`http://www.cs.utah.edu/vissim/papers/sunsky/sunsky.pdf'
`A Practical Analytic Model for Daylight'
A. J. Preetham, Peter Shirley, Brian Smits

 - Function: solar-hour julian-day hour
     Returns the solar-time in hours given the integer JULIAN-DAY in
     the range 1 to 366, and the local time in hours.

     To be meticulous, subtract 4 minutes for each degree of longitude
     west of the standard meridian of your time zone.

 - Function: solar-declination julian-day

 - Function: solar-polar declination latitude solar-hour
     Returns a list of THETA_S, the solar angle from the zenith, and
     PHI_S, the solar azimuth.  0 <= THETA_S measured in degrees.
     PHI_S is measured in degrees from due south; west of south being
     positive.

In the following procedures, the number 0 <= THETA_S <= 90 is the solar
angle from the zenith in degrees.

Turbidity is a measure of the fraction of scattering due to haze as
opposed to molecules.  This is a convenient quantity because it can be
estimated based on visibility of distant objects.  This model fails for
turbidity values less than 1.3.

         _______________________________________________________________
     512|-:                                                             |
        | * pure-air                                                    |
     256|-:**                                                           |
        | : ** exceptionally-clear                                      |
     128|-:   *                                                         |
        | :    **                                                       |
      64|-:      *                                                      |
        | :       ** very-clear                                         |
      32|-:         **                                                  |
        | :           **                                                |
      16|-:             *** clear                                       |
        | :               ****                                          |
       8|-:                  ****                                       |
        | :                     **** light-haze                         |
       4|-:                         ****                                |
        | :                             ******                          |
       2|-:                                  ******** haze         thin-|
        | :                                          ***********    fog |
       1|-:----------------------------------------------------*******--|
        |_:____.____:____.____:____.____:____.____:____.____:____.____:_|
          1         2         4         8        16        32        64
                   Meterorological range (km) versus Turbidity

 - Function: sunlight-spectrum turbidity theta_s
     Returns a vector of 41 values, the spectrum of sunlight from
     380.nm to 790.nm for a given TURBIDITY and THETA_S.

 - Function: sunlight-xyz turbidity theta_s
     Returns (unnormalized) XYZ values for color of sunlight for a
     given TURBIDITY and THETA_S.

 - Function: sunlight-ciexyz turbidity theta_s
     Given TURBIDITY and THETA_S, `sunlight-ciexyz' returns the CIEXYZ
     triple for color of sunlight scaled to be just inside the RGB709
     gamut.

 - Function: zenith-xyy turbidity theta_s
     Returns the xyY (chromaticity and luminance) at the zenith.  The
     Luminance has units kcd/m^2.

 - Function: overcast-sky-color-xyy turbidity theta_s
     TURBIDITY is a positive real number expressing the amount of light
     scattering.  The real number THETA_S is the solar angle from the
     zenith in degrees.

     `overcast-sky-color-xyy' returns a function of one angle THETA,
     the angle from the zenith of the viewing direction (in degrees);
     and returning the xyY value for light coming from that elevation
     of the sky.

 - Function: clear-sky-color-xyy turbidity theta_s phi_s
 - Function: sky-color-xyy turbidity theta_s phi_s
     TURBIDITY is a positive real number expressing the amount of light
     scattering.  The real number THETA_S is the solar angle from the
     zenith in degrees.  The real number PHI_S is the solar angle from
     south.

     `clear-sky-color-xyy' returns a function of two angles, THETA and
     PHI which specify the angles from the zenith and south meridian of
     the viewing direction (in degrees); returning the xyY value for
     light coming from that direction of the sky.

     `sky-color-xyY' calls `overcast-sky-color-xyY' for TURBIDITY <=
     20; otherwise the `clear-sky-color-xyy' function.


File: slib.info,  Node: Root Finding,  Next: Minimizing,  Prev: Color,  Up: Mathematical Packages

Root Finding
============

  `(require 'root)'

 - Function: newton:find-integer-root f df/dx x0                              |
     Given integer valued procedure F, its derivative (with respect to
     its argument) DF/DX, and initial integer value X0 for which
     DF/DX(X0) is non-zero, returns an integer X for which F(X) is
     closer to zero than either of the integers adjacent to X; or
     returns `#f' if such an integer can't be found.

     To find the closest integer to a given integers square root:

          (define (integer-sqrt y)
            (newton:find-integer-root
             (lambda (x) (- (* x x) y))
             (lambda (x) (* 2 x))
             (ash 1 (quotient (integer-length y) 2))))
          
          (integer-sqrt 15) => 4

 - Function: integer-sqrt y
     Given a non-negative integer Y, returns the rounded square-root of
     Y.

 - Function: newton:find-root f df/dx x0 prec
     Given real valued procedures F, DF/DX of one (real) argument,
     initial real value X0 for which DF/DX(X0) is non-zero, and
     positive real number PREC, returns a real X for which `abs'(F(X))
     is less than PREC; or returns `#f' if such a real can't be found.

     If PREC is instead a negative integer, `newton:find-root' returns
     the result of -PREC iterations.

H. J. Orchard, `The Laguerre Method for Finding the Zeros of
Polynomials', IEEE Transactions on Circuits and Systems, Vol. 36, No.
11, November 1989, pp 1377-1381.

     There are 2 errors in Orchard's Table II.  Line k=2 for starting
     value of 1000+j0 should have Z_k of 1.0475 + j4.1036 and line k=2
     for starting value of 0+j1000 should have Z_k of 1.0988 + j4.0833.

 - Function: laguerre:find-root f df/dz ddf/dz^2 z0 prec
     Given complex valued procedure F of one (complex) argument, its
     derivative (with respect to its argument) DF/DX, its second
     derivative DDF/DZ^2, initial complex value Z0, and positive real
     number PREC, returns a complex number Z for which
     `magnitude'(F(Z)) is less than PREC; or returns `#f' if such a
     number can't be found.

     If PREC is instead a negative integer, `laguerre:find-root'
     returns the result of -PREC iterations.

 - Function: laguerre:find-polynomial-root deg f df/dz ddf/dz^2 z0 prec
     Given polynomial procedure F of integer degree DEG of one
     argument, its derivative (with respect to its argument) DF/DX, its
     second derivative DDF/DZ^2, initial complex value Z0, and positive
     real number PREC, returns a complex number Z for which
     `magnitude'(F(Z)) is less than PREC; or returns `#f' if such a
     number can't be found.

     If PREC is instead a negative integer,
     `laguerre:find-polynomial-root' returns the result of -PREC
     iterations.

 - Function: secant:find-root f x0 x1 prec
 - Function: secant:find-bracketed-root f x0 x1 prec
     Given a real valued procedure F and two real valued starting
     points X0 and X1, returns a real X for which `(abs (f x))' is less
     than PREC; or returns `#f' if such a real can't be found.

     If X0 and X1 are chosen such that they bracket a root, that is
          (or (< (f x0) 0 (f x1))
              (< (f x1) 0 (f x0)))
     then the root returned will be between X0 and X1, and F will not
     be passed an argument outside of that interval.

     `secant:find-bracketed-root' will return `#f' unless X0 and X1
     bracket a root.

     The secant method is used until a bracketing interval is found, at
     which point a modified regula falsi method is used.

     If PREC is instead a negative integer, `secant:find-root' returns
     the result of -PREC iterations.

     If PREC is a procedure it should accept 5 arguments: X0 F0 X1 F1
     and COUNT, where F0 will be `(f x0)', F1 `(f x1)', and COUNT the
     number of iterations performed so far.  PREC should return
     non-false if the iteration should be stopped.


File: slib.info,  Node: Minimizing,  Next: Commutative Rings,  Prev: Root Finding,  Up: Mathematical Packages

Minimizing
==========

  `(require 'minimize)'

The Golden Section Search (1) algorithm finds minima of functions which
are expensive to compute or for which derivatives are not available.
Although optimum for the general case, convergence is slow, requiring
nearly 100 iterations for the example (x^3-2x-5).

If the derivative is available, Newton-Raphson is probably a better
choice.  If the function is inexpensive to compute, consider
approximating the derivative.

 - Function: golden-section-search f x0 x1 prec
     X_0 are X_1 real numbers.  The (single argument) procedure F is
     unimodal over the open interval (X_0, X_1).  That is, there is
     exactly one point in the interval for which the derivative of F is
     zero.

     `golden-section-search' returns a pair (X . F(X)) where F(X) is
     the minimum.  The PREC parameter is the stop criterion.  If PREC
     is a positive number, then the iteration continues until X is
     within PREC from the true value.  If PREC is a negative integer,
     then the procedure will iterate -PREC times or until convergence.
     If PREC is a procedure of seven arguments, X0, X1, A, B, FA, FB,
     and COUNT, then the iterations will stop when the procedure
     returns `#t'.

     Analytically, the minimum of x^3-2x-5 is 0.816497.
          (define func (lambda (x) (+ (* x (+ (* x x) -2)) -5)))
          (golden-section-search func 0 1 (/ 10000))
                ==> (816.4883855245578e-3 . -6.0886621077391165)
          (golden-section-search func 0 1 -5)
                ==> (819.6601125010515e-3 . -6.088637561916407)
          (golden-section-search func 0 1
                                 (lambda (a b c d e f g ) (= g 500)))
                ==> (816.4965933140557e-3 . -6.088662107903635)

  ---------- Footnotes ----------

  (1) David Kahaner, Cleve Moler, and Stephen Nash `Numerical Methods
and Software' Prentice-Hall, 1989, ISBN 0-13-627258-4


File: slib.info,  Node: Commutative Rings,  Next: Matrix Algebra,  Prev: Minimizing,  Up: Mathematical Packages

Commutative Rings
=================

  Scheme provides a consistent and capable set of numeric functions.
Inexacts implement a field; integers a commutative ring (and Euclidean
domain).  This package allows one to use basic Scheme numeric functions
with symbols and non-numeric elements of commutative rings.

  `(require 'commutative-ring)'

  The "commutative-ring" package makes the procedures `+', `-', `*',
`/', and `^' "careful" in the sense that any non-numeric arguments they
do not reduce appear in the expression output.  In order to see what
working with this package is like, self-set all the single letter
identifiers (to their corresponding symbols).

     (define a 'a)
     ...
     (define z 'z)

  Or just `(require 'self-set)'.  Now try some sample expressions:

     (+ (+ a b) (- a b)) => (* a 2)
     (* (+ a b) (+ a b)) => (^ (+ a b) 2)
     (* (+ a b) (- a b)) => (* (+ a b) (- a b))
     (* (- a b) (- a b)) => (^ (- a b) 2)
     (* (- a b) (+ a b)) => (* (+ a b) (- a b))
     (/ (+ a b) (+ c d)) => (/ (+ a b) (+ c d))
     (^ (+ a b) 3) => (^ (+ a b) 3)
     (^ (+ a 2) 3) => (^ (+ 2 a) 3)

  Associative rules have been applied and repeated addition and
multiplication converted to multiplication and exponentiation.

  We can enable distributive rules, thus expanding to sum of products
form:
     (set! *ruleset* (combined-rulesets distribute* distribute/))
     
     (* (+ a b) (+ a b)) => (+ (* 2 a b) (^ a 2) (^ b 2))
     (* (+ a b) (- a b)) => (- (^ a 2) (^ b 2))
     (* (- a b) (- a b)) => (- (+ (^ a 2) (^ b 2)) (* 2 a b))
     (* (- a b) (+ a b)) => (- (^ a 2) (^ b 2))
     (/ (+ a b) (+ c d)) => (+ (/ a (+ c d)) (/ b (+ c d)))
     (/ (+ a b) (- c d)) => (+ (/ a (- c d)) (/ b (- c d)))
     (/ (- a b) (- c d)) => (- (/ a (- c d)) (/ b (- c d)))
     (/ (- a b) (+ c d)) => (- (/ a (+ c d)) (/ b (+ c d)))
     (^ (+ a b) 3) => (+ (* 3 a (^ b 2)) (* 3 b (^ a 2)) (^ a 3) (^ b 3))
     (^ (+ a 2) 3) => (+ 8 (* a 12) (* (^ a 2) 6) (^ a 3))

  Use of this package is not restricted to simple arithmetic
expressions:

     (require 'determinant)
     
     (determinant '((a b c) (d e f) (g h i))) =>
     (- (+ (* a e i) (* b f g) (* c d h)) (* a f h) (* b d i) (* c e g))

  Currently, only `+', `-', `*', `/', and `^' support non-numeric
elements.  Expressions with `-' are converted to equivalent expressions
without `-', so behavior for `-' is not defined separately.  `/'
expressions are handled similarly.

  This list might be extended to include `quotient', `modulo',
`remainder', `lcm', and `gcd'; but these work only for the more
restrictive Euclidean (Unique Factorization) Domain.

Rules and Rulesets
==================

  The "commutative-ring" package allows control of ring properties
through the use of "rulesets".

 - Variable: *ruleset*
     Contains the set of rules currently in effect.  Rules defined by
     `cring:define-rule' are stored within the value of *ruleset* at the
     time `cring:define-rule' is called.  If *RULESET* is `#f', then no
     rules apply.

 - Function: make-ruleset rule1 ...
 - Function: make-ruleset name rule1 ...
     Returns a new ruleset containing the rules formed by applying
     `cring:define-rule' to each 4-element list argument RULE.  If the
     first argument to `make-ruleset' is a symbol, then the database
     table created for the new ruleset will be named NAME.  Calling
     `make-ruleset' with no rule arguments creates an empty ruleset.

 - Function: combined-rulesets ruleset1 ...
 - Function: combined-rulesets name ruleset1 ...
     Returns a new ruleset containing the rules contained in each
     ruleset argument RULESET.  If the first argument to
     `combined-ruleset' is a symbol, then the database table created for
     the new ruleset will be named NAME.  Calling `combined-ruleset'
     with no ruleset arguments creates an empty ruleset.

  Two rulesets are defined by this package.

 - Constant: distribute*
     Contains the ruleset to distribute multiplication over addition and
     subtraction.

 - Constant: distribute/
     Contains the ruleset to distribute division over addition and
     subtraction.

     Take care when using both DISTRIBUTE* and DISTRIBUTE/
     simultaneously.  It is possible to put `/' into an infinite loop.

  You can specify how sum and product expressions containing non-numeric
elements simplify by specifying the rules for `+' or `*' for cases
where expressions involving objects reduce to numbers or to expressions
involving different non-numeric elements.

 - Function: cring:define-rule op sub-op1 sub-op2 reduction
     Defines a rule for the case when the operation represented by
     symbol OP is applied to lists whose `car's are SUB-OP1 and
     SUB-OP2, respectively.  The argument REDUCTION is a procedure
     accepting 2 arguments which will be lists whose `car's are SUB-OP1
     and SUB-OP2.

 - Function: cring:define-rule op sub-op1 'identity reduction
     Defines a rule for the case when the operation represented by
     symbol OP is applied to a list whose `car' is SUB-OP1, and some
     other argument.  REDUCTION will be called with the list whose
     `car' is SUB-OP1 and some other argument.

     If REDUCTION returns `#f', the reduction has failed and other
     reductions will be tried.  If REDUCTION returns a non-false value,
     that value will replace the two arguments in arithmetic (`+', `-',
     and `*') calculations involving non-numeric elements.

     The operations `+' and `*' are assumed commutative; hence both
     orders of arguments to REDUCTION will be tried if necessary.

     The following rule is the definition for distributing `*' over `+'.

          (cring:define-rule
           '* '+ 'identity
           (lambda (exp1 exp2)
             (apply + (map (lambda (trm) (* trm exp2)) (cdr exp1))))))

How to Create a Commutative Ring
================================

  The first step in creating your commutative ring is to write
procedures to create elements of the ring.  A non-numeric element of
the ring must be represented as a list whose first element is a symbol
or string.  This first element identifies the type of the object.  A
convenient and clear convention is to make the type-identifying element
be the same symbol whose top-level value is the procedure to create it.

     (define (n . list1)
       (cond ((and (= 2 (length list1))
                   (eq? (car list1) (cadr list1)))
              0)
             ((not (term< (first list1) (last1 list1)))
              (apply n (reverse list1)))
             (else (cons 'n list1))))
     
     (define (s x y) (n x y))
     
     (define (m . list1)
       (cond ((neq? (first list1) (term_min list1))
              (apply m (cyclicrotate list1)))
             ((term< (last1 list1) (cadr list1))
              (apply m (reverse (cyclicrotate list1))))
             (else (cons 'm list1))))

  Define a procedure to multiply 2 non-numeric elements of the ring.
Other multiplicatons are handled automatically.  Objects for which rules
have _not_ been defined are not changed.

     (define (n*n ni nj)
       (let ((list1 (cdr ni)) (list2 (cdr nj)))
         (cond ((null? (intersection list1 list2)) #f)
               ((and (eq? (last1 list1) (first list2))
                     (neq? (first list1) (last1 list2)))
                (apply n (splice list1 list2)))
               ((and (eq? (first list1) (first list2))
                     (neq? (last1 list1) (last1 list2)))
                (apply n (splice (reverse list1) list2)))
               ((and (eq? (last1 list1) (last1 list2))
                     (neq? (first list1) (first list2)))
                (apply n (splice list1 (reverse list2))))
               ((and (eq? (last1 list1) (first list2))
                     (eq? (first list1) (last1 list2)))
                (apply m (cyclicsplice list1 list2)))
               ((and (eq? (first list1) (first list2))
                     (eq? (last1 list1) (last1 list2)))
                (apply m (cyclicsplice (reverse list1) list2)))
               (else #f))))

  Test the procedures to see if they work.

     ;;; where cyclicrotate(list) is cyclic rotation of the list one step
     ;;; by putting the first element at the end
     (define (cyclicrotate list1)
       (append (rest list1) (list (first list1))))
     ;;; and where term_min(list) is the element of the list which is
     ;;; first in the term ordering.
     (define (term_min list1)
       (car (sort list1 term<)))
     (define (term< sym1 sym2)
       (string<? (symbol->string sym1) (symbol->string sym2)))
     (define first car)
     (define rest cdr)
     (define (last1 list1) (car (last-pair list1)))
     (define (neq? obj1 obj2) (not (eq? obj1 obj2)))
     ;;; where splice is the concatenation of list1 and list2 except that their
     ;;; common element is not repeated.
     (define (splice list1 list2)
       (cond ((eq? (last1 list1) (first list2))
              (append list1 (cdr list2)))
             (else (error 'splice list1 list2))))
     ;;; where cyclicsplice is the result of leaving off the last element of
     ;;; splice(list1,list2).
     (define (cyclicsplice list1 list2)
       (cond ((and (eq? (last1 list1) (first list2))
                   (eq? (first list1) (last1 list2)))
              (butlast (splice list1 list2) 1))
             (else (error 'cyclicsplice list1 list2))))
     
     (N*N (S a b) (S a b)) => (m a b)

  Then register the rule for multiplying type N objects by type N
objects.

     (cring:define-rule '* 'N 'N N*N))

  Now we are ready to compute!

     (define (t)
       (define detM
         (+ (* (S g b)
               (+ (* (S f d)
                     (- (* (S a f) (S d g)) (* (S a g) (S d f))))
                  (* (S f f)
                     (- (* (S a g) (S d d)) (* (S a d) (S d g))))
                  (* (S f g)
                     (- (* (S a d) (S d f)) (* (S a f) (S d d))))))
            (* (S g d)
               (+ (* (S f b)
                     (- (* (S a g) (S d f)) (* (S a f) (S d g))))
                  (* (S f f)
                     (- (* (S a b) (S d g)) (* (S a g) (S d b))))
                  (* (S f g)
                     (- (* (S a f) (S d b)) (* (S a b) (S d f))))))
            (* (S g f)
               (+ (* (S f b)
                     (- (* (S a d) (S d g)) (* (S a g) (S d d))))
                  (* (S f d)
                     (- (* (S a g) (S d b)) (* (S a b) (S d g))))
                  (* (S f g)
                     (- (* (S a b) (S d d)) (* (S a d) (S d b))))))
            (* (S g g)
               (+ (* (S f b)
                     (- (* (S a f) (S d d)) (* (S a d) (S d f))))
                  (* (S f d)
                     (- (* (S a b) (S d f)) (* (S a f) (S d b))))
                  (* (S f f)
                     (- (* (S a d) (S d b)) (* (S a b) (S d d))))))))
       (* (S b e) (S c a) (S e c)
          detM
          ))
     (pretty-print (t))
     -|
     (- (+ (m a c e b d f g)
           (m a c e b d g f)
           (m a c e b f d g)
           (m a c e b f g d)
           (m a c e b g d f)
           (m a c e b g f d))
        (* 2 (m a b e c) (m d f g))
        (* (m a c e b d) (m f g))
        (* (m a c e b f) (m d g))
        (* (m a c e b g) (m d f)))


File: slib.info,  Node: Matrix Algebra,  Prev: Commutative Rings,  Up: Mathematical Packages

Matrix Algebra
==============

  `(require 'determinant)'

A Matrix can be either a list of lists (rows) or an array.  As with
linear-algebra texts, this package uses 1-based coordinates.

 - Function: matrix->lists matrix
     Returns the list-of-lists form of MATRIX.

 - Function: matrix->array matrix
     Returns the (ones-based) array form of MATRIX.

 - Function: determinant matrix
     MATRIX must be a square matrix.  `determinant' returns the
     determinant of MATRIX.

          (require 'determinant)
          (determinant '((1 2) (3 4))) => -2
          (determinant '((1 2 3) (4 5 6) (7 8 9))) => 0

 - Function: transpose matrix
     Returns a copy of MATRIX flipped over the diagonal containing the
     1,1 element.

 - Function: matrix:product m1 m2
     Returns the product of matrices M1 and M2.

 - Function: matrix:inverse matrix
     MATRIX must be a square matrix.  If MATRIX is singlar, then
     `matrix:inverse' returns #f; otherwise `matrix:inverse' returns the
     `matrix:product' inverse of MATRIX.


File: slib.info,  Node: Database Packages,  Next: Other Packages,  Prev: Mathematical Packages,  Up: Top

Database Packages
*****************

* Menu:

* Base Table::
* Relational Database::         'relational-database
* Weight-Balanced Trees::       'wt-tree


File: slib.info,  Node: Base Table,  Next: Relational Database,  Prev: Database Packages,  Up: Database Packages

Base Table
==========

  A "base-table" is the primitive database layer upon which SLIB
relational databases are built.  At the minimum, it must support the
types integer, symbol, string, and boolean.  The base-table may restrict
the size of integers, symbols, and strings it supports.

  A base table implementation is available as the value of the
identifier naming it (eg. ALIST-TABLE) after requiring the symbol of
that name.

 - Feature: alist-table
     `(require 'alist-table)'

     Association-list base tables support all Scheme types and are
     suitable for small databases.  In order to be retrieved after
     being written to a file, the data stored should include only
     objects which are readable and writeable in the Scheme
     implementation.

     The "alist-table" base-table-type is included in the SLIB
     distribution.

 - Feature: wb-table
     `(require 'wb-table)'

     "WB" is a B-tree database package supported by the SCM Scheme
     implementation.  It supports scheme expressions for keys and values
     whose text representations are less than 255 characters in length.
     Being disk-based, wb-table readily stores hundreds of megabytes of
     data.

  This rest of this section documents the interface for a base table
implementation from which the *Note Relational Database:: package
constructs a Relational system.  It will be of interest primarily to
those wishing to port or write new base-table implementations.

 - Variable: *base-table-implementations*
     To support automatic dispatch for `open-database', each base-table
     module adds an association to *BASE-TABLE-IMPLEMENTATIONS* when
     loaded.  This association is the list of the base-table symbol and
     the value returned by `(make-relational-system BASE-TABLE)'.

  All of these functions are accessed through a single procedure by
calling that procedure with the symbol name of the operation.  A
procedure will be returned if that operation is supported and `#f'
otherwise.  For example:

     (require 'alist-table)
     (define open-base (alist-table 'make-base))
     make-base       => *a procedure*
     (define foo (alist-table 'foo))
     foo             => #f

 - Function: make-base filename key-dimension column-types
     Returns a new, open, low-level database (collection of tables)
     associated with FILENAME.  This returned database has an empty
     table associated with CATALOG-ID.  The positive integer
     KEY-DIMENSION is the number of keys composed to make a PRIMARY-KEY
     for the catalog table.  The list of symbols COLUMN-TYPES describes
     the types of each column for that table.  If the database cannot
     be created as specified, `#f' is returned.

     Calling the `close-base' method on this database and possibly other
     operations will cause FILENAME to be written to.  If FILENAME is
     `#f' a temporary, non-disk based database will be created if such
     can be supported by the base table implelentation.

 - Function: open-base filename mutable
     Returns an open low-level database associated with FILENAME.  If
     MUTABLE is `#t', this database will have methods capable of
     effecting change to the database.  If MUTABLE is `#f', only
     methods for inquiring the database will be available.  If the
     database cannot be opened as specified `#f' is returned.

     Calling the `close-base' (and possibly other) method on a MUTABLE
     database will cause FILENAME to be written to.

 - Function: write-base lldb filename
     Causes the low-level database LLDB to be written to FILENAME.  If
     the write is successful, also causes LLDB to henceforth be
     associated with FILENAME.  Calling the `close-database' (and
     possibly other) method on LLDB may cause FILENAME to be written
     to.  If FILENAME is `#f' this database will be changed to a
     temporary, non-disk based database if such can be supported by the
     underlying base table implelentation.  If the operations completed
     successfully, `#t' is returned.  Otherwise, `#f' is returned.

 - Function: sync-base lldb
     Causes the file associated with the low-level database LLDB to be
     updated to reflect its current state.  If the associated filename
     is `#f', no action is taken and `#f' is returned.  If this
     operation completes successfully, `#t' is returned.  Otherwise,
     `#f' is returned.

 - Function: close-base lldb
     Causes the low-level database LLDB to be written to its associated
     file (if any).  If the write is successful, subsequent operations
     to LLDB will signal an error.  If the operations complete
     successfully, `#t' is returned.  Otherwise, `#f' is returned.

 - Function: make-table lldb key-dimension column-types
     Returns the BASE-ID for a new base table, otherwise returns `#f'.
     The base table can then be opened using `(open-table LLDB
     BASE-ID)'.  The positive integer KEY-DIMENSION is the number of
     keys composed to make a PRIMARY-KEY for this table.  The list of
     symbols COLUMN-TYPES describes the types of each column.

 - Constant: catalog-id
     A constant BASE-ID suitable for passing as a parameter to
     `open-table'.  CATALOG-ID will be used as the base table for the
     system catalog.

 - Function: open-table lldb base-id key-dimension column-types
     Returns a HANDLE for an existing base table in the low-level
     database LLDB if that table exists and can be opened in the mode
     indicated by MUTABLE, otherwise returns `#f'.

     As with `make-table', the positive integer KEY-DIMENSION is the
     number of keys composed to make a PRIMARY-KEY for this table.  The
     list of symbols COLUMN-TYPES describes the types of each column.

 - Function: kill-table lldb base-id key-dimension column-types
     Returns `#t' if the base table associated with BASE-ID was removed
     from the low level database LLDB, and `#f' otherwise.

 - Function: make-keyifier-1 type
     Returns a procedure which accepts a single argument which must be
     of type TYPE.  This returned procedure returns an object suitable
     for being a KEY argument in the functions whose descriptions
     follow.

     Any 2 arguments of the supported type passed to the returned
     function which are not `equal?' must result in returned values
     which are not `equal?'.

 - Function: make-list-keyifier key-dimension types
     The list of symbols TYPES must have at least KEY-DIMENSION
     elements.  Returns a procedure which accepts a list of length
     KEY-DIMENSION and whose types must corresopond to the types named
     by TYPES.  This returned procedure combines the elements of its
     list argument into an object suitable for being a KEY argument in
     the functions whose descriptions follow.

     Any 2 lists of supported types (which must at least include
     symbols and non-negative integers) passed to the returned function
     which are not `equal?' must result in returned values which are not
     `equal?'.

 - Function: make-key-extractor key-dimension types column-number
     Returns a procedure which accepts objects produced by application
     of the result of `(make-list-keyifier KEY-DIMENSION TYPES)'.  This
     procedure returns a KEY which is `equal?' to the COLUMN-NUMBERth
     element of the list which was passed to create COMBINED-KEY.  The
     list TYPES must have at least KEY-DIMENSION elements.

 - Function: make-key->list key-dimension types
     Returns a procedure which accepts objects produced by application
     of the result of `(make-list-keyifier KEY-DIMENSION TYPES)'.  This
     procedure returns a list of KEYs which are elementwise `equal?' to
     the list which was passed to create COMBINED-KEY.

In the following functions, the KEY argument can always be assumed to
be the value returned by a call to a _keyify_ routine.

In contrast, a MATCH-KEYS argument is a list of length equal to the
number of primary keys.  The MATCH-KEYS restrict the actions of the
table command to those records whose primary keys all satisfy the
corresponding element of the MATCH-KEYS list.  The elements and their
actions are:

    `#f'
          The false value matches any key in the corresponding position.

    an object of type procedure
          This procedure must take a single argument, the key in the
          corresponding position.  Any key for which the procedure
          returns a non-false value is a match; Any key for which the
          procedure returns a `#f' is not.

    other values
          Any other value matches only those keys `equal?' to it.

The KEY-DIMENSION and COLUMN-TYPES arguments are needed to decode the
combined-keys for matching with MATCH-KEYS.

 - Function: for-each-key handle procedure key-dimension column-types
          match-keys
     Calls PROCEDURE once with each KEY in the table opened in HANDLE
     which satisfy MATCH-KEYS in an unspecified order.  An unspecified
     value is returned.

 - Function: map-key handle procedure key-dimension column-types
          match-keys
     Returns a list of the values returned by calling PROCEDURE once
     with each KEY in the table opened in HANDLE which satisfy
     MATCH-KEYS in an unspecified order.

 - Function: ordered-for-each-key handle procedure key-dimension
          column-types match-keys
     Calls PROCEDURE once with each KEY in the table opened in HANDLE
     which satisfy MATCH-KEYS in the natural order for the types of the
     primary key fields of that table.  An unspecified value is
     returned.

 - Function: delete* handle key-dimension column-types match-keys
     Removes all rows which satisfy MATCH-KEYS from the table opened in
     HANDLE.  An unspecified value is returned.

 - Function: present? handle key
     Returns a non-`#f' value if there is a row associated with KEY in
     the table opened in HANDLE and `#f' otherwise.

 - Function: delete handle key
     Removes the row associated with KEY from the table opened in
     HANDLE.  An unspecified value is returned.

 - Function: make-getter key-dimension types
     Returns a procedure which takes arguments HANDLE and KEY.  This
     procedure returns a list of the non-primary values of the relation
     (in the base table opened in HANDLE) whose primary key is KEY if
     it exists, and `#f' otherwise.

 - Function: make-putter key-dimension types
     Returns a procedure which takes arguments HANDLE and KEY and
     VALUE-LIST.  This procedure associates the primary key KEY with
     the values in VALUE-LIST (in the base table opened in HANDLE) and
     returns an unspecified value.

 - Function: supported-type? symbol
     Returns `#t' if SYMBOL names a type allowed as a column value by
     the implementation, and `#f' otherwise.  At a minimum, an
     implementation must support the types `integer', `symbol',
     `string', `boolean', and `base-id'.

 - Function: supported-key-type? symbol
     Returns `#t' if SYMBOL names a type allowed as a key value by the
     implementation, and `#f' otherwise.  At a minimum, an
     implementation must support the types `integer', and `symbol'.

`integer'
     Scheme exact integer.

`symbol'
     Scheme symbol.

`boolean'
     `#t' or `#f'.

`base-id'
     Objects suitable for passing as the BASE-ID parameter to
     `open-table'.  The value of CATALOG-ID must be an acceptable
     `base-id'.


File: slib.info,  Node: Relational Database,  Next: Weight-Balanced Trees,  Prev: Base Table,  Up: Database Packages

Relational Database
===================

  `(require 'relational-database)'

  This package implements a database system inspired by the Relational
Model (`E. F. Codd, A Relational Model of Data for Large Shared Data
Banks').  An SLIB relational database implementation can be created
from any *Note Base Table:: implementation.

  Why relational database?  For motivations and design issues see
`http://swissnet.ai.mit.edu/~jaffer/DBManifesto.html'.

* Menu:

* Using Databases::             'databases
* Relational Database Objects::
* Database Operations::
* Table Operations::
* Catalog Representation::
* Embedded Commands::           'database-commands
* Database Macros::             'within-database                              |
* Database Reports::
* Database Browser::            'database-browse


File: slib.info,  Node: Using Databases,  Next: Relational Database Objects,  Prev: Relational Database,  Up: Relational Database

Using Databases
---------------

  `(require 'databases)'

This enhancement wraps a utility layer on `relational-database' which
provides:

   * Identification of open databases by filename.

   * Automatic sharing of open (immutable) databases.

   * Automatic loading of base-table package when creating a database.

   * Detection and automatic loading of the appropriate base-table
     package when opening a database.

   * Table and data definition from Scheme lists.

Database Sharing
................

"Auto-sharing" refers to a call to the procedure `open-database'
returning an already open database (procedure), rather than opening the
database file a second time.

     _Note:_ Databases returned by `open-database' do not include
     wrappers applied by packages like *Note Embedded Commands::.  But
     wrapped databases do work as arguments to these functions.

When a database is created, it is mutable by the creator and not
auto-sharable.  A database opened mutably is also not auto-sharable.
But any number of readers can (open) share a non-mutable database file.

This next set of procedures mirror the whole-database methods in *Note
Database Operations::.  Except for `create-database', each procedure
will accept either a filename or database procedure for its first
argument.

 - Function: create-database filename base-table-type
     Returns an open relational database (with base-table type
     BASE-TABLE-TYPE) associated with FILENAME.

Only `alist-table' and base-table modules which have been loaded will
dispatch correctly from the `open-database' procedures.  Therefore,
either pass two arguments to `open-database', or require the base-table
your database file uses before calling `open-database' with one
argument.

 - Function: open-database! rdb base-table-type
     Returns _mutable_ open relational database or #f.

 - Function: open-database rdb base-table-type
     Returns an open relational database associated with RDB.  The
     database will be opened with base-table type BASE-TABLE-TYPE).

 - Function: open-database rdb
     Returns an open relational database associated with RDB.
     `open-database' will attempt to deduce the correct base-table-type.

 - Function: write-database rdb filename
     Writes the mutable relational-database RDB to FILENAME.

 - Function: sync-database rdb
     Writes the mutable relational-database RDB to the filename it was
     opened with.

 - Function: solidify-database rdb
     Syncs RDB and makes it immutable.

 - Function: close-database rdb
     RDB will only be closed when the count of `open-database' -
     `close-database' calls for RDB (and its filename) is 0.

 - Function: mdbm:report
     Prints a table of open database files.  The columns are the
     base-table type, number of opens, `!' for mutable, and the
     filename.

          (mdbm:report)
          -|
              alist-table 003   /usr/local/lib/slib/clrnamdb.scm
              alist-table 001 ! sdram.db

Defining Tables
...............

 - Function: define-tables rdb spec-0 ...
     Adds tables as specified in SPEC-0 ... to the open
     relational-database RDB.  Each SPEC has the form:

          (<name> <descriptor-name> <descriptor-name> <rows>)
     or
          (<name> <primary-key-fields> <other-fields> <rows>)

     where <name> is the table name, <descriptor-name> is the symbol
     name of a descriptor table, <primary-key-fields> and
     <other-fields> describe the primary keys and other fields
     respectively, and <rows> is a list of data rows to be added to the
     table.

     <primary-key-fields> and <other-fields> are lists of field
     descriptors of the form:

          (<column-name> <domain>)
     or
          (<column-name> <domain> <column-integrity-rule>)

     where <column-name> is the column name, <domain> is the domain of
     the column, and <column-integrity-rule> is an expression whose
     value is a procedure of one argument (which returns `#f' to signal
     an error).

     If <domain> is not a defined domain name and it matches the name of
     this table or an already defined (in one of SPEC-0 ...) single key
     field table, a foriegn-key domain will be created for it.

Listing Tables
..............

 - Function: list-table-definition rdb table-name
     If symbol TABLE-NAME exists in the open relational-database RDB,
     then returns a list of the table-name, its primary key names and
     domains, its other key names and domains, and the table's records
     (as lists).  Otherwise, returns #f.

     The list returned by `list-table-definition', when passed as an
     argument to `define-tables', will recreate the table.


File: slib.info,  Node: Relational Database Objects,  Next: Database Operations,  Prev: Using Databases,  Up: Relational Database

Relational Database Objects
---------------------------

 - Function: make-relational-system base-table-implementation
     Returns a procedure implementing a relational database using the
     BASE-TABLE-IMPLEMENTATION.

     All of the operations of a base table implementation are accessed
     through a procedure defined by `require'ing that implementation.
     Similarly, all of the operations of the relational database
     implementation are accessed through the procedure returned by
     `make-relational-system'.  For instance, a new relational database
     could be created from the procedure returned by
     `make-relational-system' by:

          (require 'alist-table)
          (define relational-alist-system
                  (make-relational-system alist-table))
          (define create-alist-database
                  (relational-alist-system 'create-database))
          (define my-database
                  (create-alist-database "mydata.db"))

What follows are the descriptions of the methods available from
relational system returned by a call to `make-relational-system'.

 - Function: create-database filename
     Returns an open, nearly empty relational database associated with
     FILENAME.  The only tables defined are the system catalog and
     domain table.  Calling the `close-database' method on this database
     and possibly other operations will cause FILENAME to be written
     to.  If FILENAME is `#f' a temporary, non-disk based database will
     be created if such can be supported by the underlying base table
     implelentation.  If the database cannot be created as specified
     `#f' is returned.  For the fields and layout of descriptor tables,
     *Note Catalog Representation::

 - Function: open-database filename mutable?
     Returns an open relational database associated with FILENAME.  If
     MUTABLE? is `#t', this database will have methods capable of
     effecting change to the database.  If MUTABLE? is `#f', only
     methods for inquiring the database will be available.  Calling the
     `close-database' (and possibly other) method on a MUTABLE?
     database will cause FILENAME to be written to.  If the database
     cannot be opened as specified `#f' is returned.


File: slib.info,  Node: Database Operations,  Next: Table Operations,  Prev: Relational Database Objects,  Up: Relational Database

Database Operations
-------------------

These are the descriptions of the methods available from an open
relational database.  A method is retrieved from a database by calling
the database with the symbol name of the operation.  For example:

     (define my-database
             (create-alist-database "mydata.db"))
     (define telephone-table-desc
             ((my-database 'create-table) 'telephone-table-desc))

 - Function: close-database
     Causes the relational database to be written to its associated
     file (if any).  If the write is successful, subsequent operations
     to this database will signal an error.  If the operations completed
     successfully, `#t' is returned.  Otherwise, `#f' is returned.

 - Function: write-database filename
     Causes the relational database to be written to FILENAME.  If the
     write is successful, also causes the database to henceforth be
     associated with FILENAME.  Calling the `close-database' (and
     possibly other) method on this database will cause FILENAME to be
     written to.  If FILENAME is `#f' this database will be changed to
     a temporary, non-disk based database if such can be supported by
     the underlying base table implelentation.  If the operations
     completed successfully, `#t' is returned.  Otherwise, `#f' is
     returned.

 - Function: sync-database
     Causes any pending updates to the database file to be written out.
     If the operations completed successfully, `#t' is returned.
     Otherwise, `#f' is returned.

 - Function: solidify-database
     Causes any pending updates to the database file to be written out.
     If the writes completed successfully, then the database is
     changed to be immutable and `#t' is returned.  Otherwise, `#f' is
     returned.

 - Function: table-exists? table-name
     Returns `#t' if TABLE-NAME exists in the system catalog, otherwise
     returns `#f'.

 - Function: open-table table-name mutable?
     Returns a "methods" procedure for an existing relational table in
     this database if it exists and can be opened in the mode indicated
     by MUTABLE?, otherwise returns `#f'.

These methods will be present only in mutable databases.

 - Function: delete-table table-name
     Removes and returns the TABLE-NAME row from the system catalog if
     the table or view associated with TABLE-NAME gets removed from the
     database, and `#f' otherwise.

 - Function: create-table table-desc-name
     Returns a methods procedure for a new (open) relational table for
     describing the columns of a new base table in this database,
     otherwise returns `#f'.  For the fields and layout of descriptor
     tables, *Note Catalog Representation::.

 - Function: create-table table-name table-desc-name
     Returns a methods procedure for a new (open) relational table with
     columns as described by TABLE-DESC-NAME, otherwise returns `#f'.

 - Function: create-view ??
 - Function: project-table ??
 - Function: restrict-table ??
 - Function: cart-prod-tables ??
     Not yet implemented.


File: slib.info,  Node: Table Operations,  Next: Catalog Representation,  Prev: Database Operations,  Up: Relational Database

Table Operations
----------------

These are the descriptions of the methods available from an open
relational table.  A method is retrieved from a table by calling the
table with the symbol name of the operation.  For example:

     (define telephone-table-desc
             ((my-database 'create-table) 'telephone-table-desc))
     (require 'common-list-functions)
     (define ndrp (telephone-table-desc 'row:insert))
     (ndrp '(1 #t name #f string))
     (ndrp '(2 #f telephone
               (lambda (d)
                 (and (string? d) (> (string-length d) 2)
                      (every
                       (lambda (c)
                         (memv c '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
                                       #\+ #\( #\  #\) #\-)))
                       (string->list d))))
               string))

Some operations described below require primary key arguments.  Primary
keys arguments are denoted KEY1 KEY2 ....  It is an error to call an
operation for a table which takes primary key arguments with the wrong
number of primary keys for that table.

The term "row" used below refers to a Scheme list of values (one for
each column) in the order specified in the descriptor (table) for this
table.  Missing values appear as `#f'.  Primary keys must not be
missing.

 - Function: get column-name
     Returns a procedure of arguments KEY1 KEY2 ... which returns the
     value for the COLUMN-NAME column of the row associated with
     primary keys KEY1, KEY2 ... if that row exists in the table, or
     `#f' otherwise.

          ((plat 'get 'processor) 'djgpp) => i386
          ((plat 'get 'processor) 'be-os) => #f

 - Function: get* column-name
     Returns a procedure of optional arguments MATCH-KEY1 ... which
     returns a list of the values for the specified column for all rows
     in this table.  The optional MATCH-KEY1 ... arguments restrict
     actions to a subset of the table.  See the match-key description
     below for details.

          ((plat 'get* 'processor)) =>
          (i386 8086 i386 8086 i386 i386 8086 m68000
           m68000 m68000 m68000 m68000 powerpc)
          
          ((plat 'get* 'processor) #f) =>
          (i386 8086 i386 8086 i386 i386 8086 m68000
           m68000 m68000 m68000 m68000 powerpc)
          
          (define (a-key? key)
             (char=? #\a (string-ref (symbol->string key) 0)))
          
          ((plat 'get* 'processor) a-key?) =>
          (m68000 m68000 m68000 m68000 m68000 powerpc)
          
          ((plat 'get* 'name) a-key?) =>
          (atari-st-turbo-c atari-st-gcc amiga-sas/c-5.10
           amiga-aztec amiga-dice-c aix)

 - Function: row:retrieve
     Returns a procedure of arguments KEY1 KEY2 ... which returns the
     row associated with primary keys KEY1, KEY2 ... if it exists, or
     `#f' otherwise.

          ((plat 'row:retrieve) 'linux) => (linux i386 linux gcc)
          ((plat 'row:retrieve) 'multics) => #f

 - Function: row:retrieve*
     Returns a procedure of optional arguments MATCH-KEY1 ... which
     returns a list of all rows in this table.  The optional MATCH-KEY1
     ... arguments restrict actions to a subset of the table.  See the
     match-key description below for details.

     ((plat 'row:retrieve*) a-key?) =>
     ((atari-st-turbo-c m68000 atari turbo-c)
      (atari-st-gcc m68000 atari gcc)
      (amiga-sas/c-5.10 m68000 amiga sas/c)
      (amiga-aztec m68000 amiga aztec)
      (amiga-dice-c m68000 amiga dice-c)
      (aix powerpc aix -))

 - Function: row:remove
     Returns a procedure of arguments KEY1 KEY2 ... which removes and
     returns the row associated with primary keys KEY1, KEY2 ... if it
     exists, or `#f' otherwise.

 - Function: row:remove*
     Returns a procedure of optional arguments MATCH-KEY1 ... which
     removes and returns a list of all rows in this table.  The optional
     MATCH-KEY1 ... arguments restrict actions to a subset of the
     table.  See the match-key description below for details.

 - Function: row:delete
     Returns a procedure of arguments KEY1 KEY2 ... which deletes the
     row associated with primary keys KEY1, KEY2 ... if it exists.  The
     value returned is unspecified.

 - Function: row:delete*
     Returns a procedure of optional arguments MATCH-KEY1 ... which
     Deletes all rows from this table.  The optional MATCH-KEY1 ...
     arguments restrict deletions to a subset of the table.  See the
     match-key description below for details.  The value returned is
     unspecified.  The descriptor table and catalog entry for this
     table are not affected.

 - Function: row:update
     Returns a procedure of one argument, ROW, which adds the row, ROW,
     to this table.  If a row for the primary key(s) specified by ROW
     already exists in this table, it will be overwritten.  The value
     returned is unspecified.

 - Function: row:update*
     Returns a procedure of one argument, ROWS, which adds each row in
     the list of rows, ROWS, to this table.  If a row for the primary
     key specified by an element of ROWS already exists in this table,
     it will be overwritten.  The value returned is unspecified.

 - Function: row:insert
     Adds the row ROW to this table.  If a row for the primary key(s)
     specified by ROW already exists in this table an error is
     signaled.  The value returned is unspecified.

 - Function: row:insert*
     Returns a procedure of one argument, ROWS, which adds each row in
     the list of rows, ROWS, to this table.  If a row for the primary
     key specified by an element of ROWS already exists in this table,
     an error is signaled.  The value returned is unspecified.

 - Function: for-each-row
     Returns a procedure of arguments PROC MATCH-KEY1 ...  which calls
     PROC with each ROW in this table in the (implementation-dependent)
     natural ordering for rows.  The optional MATCH-KEY1 ... arguments
     restrict actions to a subset of the table.  See the match-key
     description below for details.

     _Real_ relational programmers would use some least-upper-bound join
     for every row to get them in order; But we don't have joins yet.

The (optional) MATCH-KEY1 ... arguments are used to restrict actions of
a whole-table operation to a subset of that table.  Those procedures
(returned by methods) which accept match-key arguments will accept any
number of match-key arguments between zero and the number of primary
keys in the table.  Any unspecified MATCH-KEY arguments default to `#f'.

The MATCH-KEY1 ... restrict the actions of the table command to those
records whose primary keys each satisfy the corresponding MATCH-KEY
argument.  The arguments and their actions are:

    `#f'
          The false value matches any key in the corresponding position.

    an object of type procedure
          This procedure must take a single argument, the key in the
          corresponding position.  Any key for which the procedure
          returns a non-false value is a match; Any key for which the
          procedure returns a `#f' is not.

    other values
          Any other value matches only those keys `equal?' to it.

 - Function: close-table
     Subsequent operations to this table will signal an error.

 - Constant: column-names
 - Constant: column-foreigns
 - Constant: column-domains
 - Constant: column-types
     Return a list of the column names, foreign-key table names, domain
     names, or type names respectively for this table.  These 4 methods
     are different from the others in that the list is returned, rather
     than a procedure to obtain the list.

 - Constant: primary-limit
     Returns the number of primary keys fields in the relations in this
     table.


File: slib.info,  Node: Catalog Representation,  Next: Embedded Commands,  Prev: Table Operations,  Up: Relational Database

Catalog Representation
----------------------

Each database (in an implementation) has a "system catalog" which
describes all the user accessible tables in that database (including
itself).

The system catalog base table has the following fields.  `PRI'
indicates a primary key for that table.

     PRI table-name
         column-limit            the highest column number
         coltab-name             descriptor table name
         bastab-id               data base table identifier
         user-integrity-rule
         view-procedure          A scheme thunk which, when called,
                                 produces a handle for the view.  coltab
                                 and bastab are specified if and only if
                                 view-procedure is not.

Descriptors for base tables (not views) are tables (pointed to by
system catalog).  Descriptor (base) tables have the fields:

     PRI column-number           sequential integers from 1
         primary-key?            boolean TRUE for primary key components
         column-name
         column-integrity-rule
         domain-name

A "primary key" is any column marked as `primary-key?' in the
corresponding descriptor table.  All the `primary-key?' columns must
have lower column numbers than any non-`primary-key?' columns.  Every
table must have at least one primary key.  Primary keys must be
sufficient to distinguish all rows from each other in the table.  All of
the system defined tables have a single primary key.

This package currently supports tables having from 1 to 4 primary keys
if there are non-primary columns, and any (natural) number if _all_
columns are primary keys.  If you need more than 4 primary keys, I would
like to hear what you are doing!

A "domain" is a category describing the allowable values to occur in a
column.  It is described by a (base) table with the fields:

     PRI domain-name
         foreign-table
         domain-integrity-rule
         type-id
         type-param

The "type-id" field value is a symbol.  This symbol may be used by the
underlying base table implementation in storing that field.

If the `foreign-table' field is non-`#f' then that field names a table
from the catalog.  The values for that domain must match a primary key
of the table referenced by the TYPE-PARAM (or `#f', if allowed).  This
package currently does not support composite foreign-keys.

The types for which support is planned are:
         atom
         symbol
         string                  [<length>]
         number                  [<base>]
         money                   <currency>
         date-time
         boolean
     
         foreign-key             <table-name>
         expression
         virtual                 <expression>


File: slib.info,  Node: Embedded Commands,  Next: Database Macros,  Prev: Catalog Representation,  Up: Relational Database
                                                                              |
Embedded Commands
-----------------

  `(require 'database-commands)'

This enhancement wraps a utility layer on `relational-database' which
provides:

   * Automatic execution of initialization commands stored in database.

   * Transparent execution of database commands stored in `*commands*'
     table in database.

  When an enhanced relational-database is called with a symbol which
matches a NAME in the `*commands*' table, the associated procedure
expression is evaluated and applied to the enhanced
relational-database.  A procedure should then be returned which the user
can invoke on (optional) arguments.

  The command `*initialize*' is special.  If present in the
`*commands*' table, `open-database' or `open-database!' will return the
value of the `*initialize*' command.  Notice that arbitrary code can be
run when the `*initialize*' procedure is automatically applied to the
enhanced relational-database.

  Note also that if you wish to shadow or hide from the user
relational-database methods described in *Note Database Operations::,
this can be done by a dispatch in the closure returned by the
`*initialize*' expression rather than by entries in the `*commands*'
table if it is desired that the underlying methods remain accessible to
code in the `*commands*' table.

* Menu:

* Database Extension::
* Command Intrinsics::
* Define-tables Example::
* The *commands* Table::
* Command Service::
* Command Example::


File: slib.info,  Node: Database Extension,  Next: Command Intrinsics,  Prev: Embedded Commands,  Up: Embedded Commands

Database Extension
..................

 - Function: wrap-command-interface rdb
     Returns relational database RDB wrapped with additional commands
     defined in its *commands* table.

 - Function: add-command-tables rdb
     The relational database RDB must be mutable.  ADD-COMMAND-TABLES
     adds a *command* table to RDB; then returns
     `(wrap-command-interface RDB)'.

 - Function: define-*commands* rdb spec-0 ...                                 |
     Adds commands to the `*commands*' table as specified in SPEC-0 ...       |
     to the open relational-database RDB.  Each SPEC has the form:            |
                                                                              |
          ((<name> <rdb>) "comment" <expression1> <expression2> ...)          |
     or                                                                       |
          ((<name> <rdb>) <expression1> <expression2> ...)                    |
                                                                              |
     where <name> is the command name, <rdb> is a formal passed the           |
     calling relational database, "comment" describes the command, and        |
     <expression1>, <expression1>, ... are the body of the procedure.         |
                                                                              |
     `define-*commands*' adds to the `*commands*' table a command             |
     <name>:                                                                  |
                                                                              |
          (lambda (<name> <rdb>) <expression1> <expression2> ...)             |
                                                                              |
                                                                              |
 - Function: open-command-database filename
 - Function: open-command-database filename base-table-type
     Returns an open enhanced relational database associated with
     FILENAME.  The database will be opened with base-table type
     BASE-TABLE-TYPE) if supplied.  If BASE-TABLE-TYPE is not supplied,
     `open-command-database' will attempt to deduce the correct
     base-table-type.  If the database can not be opened or if it lacks
     the `*commands*' table, `#f' is returned.

 - Function: open-command-database! filename
 - Function: open-command-database! filename base-table-type
     Returns _mutable_ open enhanced relational database ...

 - Function: open-command-database database
     Returns DATABASE if it is an immutable relational database; #f
     otherwise.

 - Function: open-command-database! database
     Returns DATABASE if it is a mutable relational database; #f
     otherwise.


File: slib.info,  Node: Command Intrinsics,  Next: Define-tables Example,  Prev: Database Extension,  Up: Embedded Commands

Command Intrinsics
..................

  Some commands are defined in all extended relational-databases.  The
are called just like *Note Database Operations::.

 - Function: add-domain domain-row
     Adds DOMAIN-ROW to the "domains" table if there is no row in the
     domains table associated with key `(car DOMAIN-ROW)' and returns
     `#t'.  Otherwise returns `#f'.

     For the fields and layout of the domain table, *Note Catalog
     Representation::.  Currently, these fields are
        * domain-name

        * foreign-table

        * domain-integrity-rule

        * type-id

        * type-param

     The following example adds 3 domains to the `build' database.
     `Optstring' is either a string or `#f'.  `filename' is a string
     and `build-whats' is a symbol.

          (for-each (build 'add-domain)
                    '((optstring #f
                                 (lambda (x) (or (not x) (string? x)))
                                 string
                                 #f)
                      (filename #f #f string #f)
                      (build-whats #f #f symbol #f)))

 - Function: delete-domain domain-name
     Removes and returns the DOMAIN-NAME row from the "domains" table.

 - Function: domain-checker domain
     Returns a procedure to check an argument for conformance to domain
     DOMAIN.


File: slib.info,  Node: Define-tables Example,  Next: The *commands* Table,  Prev: Command Intrinsics,  Up: Embedded Commands

Define-tables Example
.....................

The following example shows a new database with the name of `foo.db'
being created with tables describing processor families and
processor/os/compiler combinations.

The database command `define-tables' is defined to call `define-tables'
with its arguments.  The database is also configured to print `Welcome'
when the database is opened.  The database is then closed and reopened.

     (require 'databases)
     (define my-rdb (create-database "foo.db" 'alist-table))
     
     (define-tables my-rdb
       '(*commands*
         ((name symbol))
         ((parameters parameter-list)
          (procedure expression)
          (documentation string))
         ((define-tables
           no-parameters
           no-parameter-names
           (lambda (rdb) (lambda specs (apply define-tables rdb specs)))
           "Create or Augment tables from list of specs")
          (*initialize*
           no-parameters
           no-parameter-names
           (lambda (rdb) (display "Welcome") (newline) rdb)
           "Print Welcome"))))
     
     ((my-rdb 'define-tables)
      '(processor-family
        ((family    atom))
        ((also-ran  processor-family))
        ((m68000           #f)
         (m68030           m68000)
         (i386             8086)
         (8086             #f)
         (powerpc          #f)))
     
      '(platform
        ((name      symbol))
        ((processor processor-family)
         (os        symbol)
         (compiler  symbol))
        ((aix              powerpc aix     -)
         (amiga-dice-c     m68000  amiga   dice-c)
         (amiga-aztec      m68000  amiga   aztec)
         (amiga-sas/c-5.10 m68000  amiga   sas/c)
         (atari-st-gcc     m68000  atari   gcc)
         (atari-st-turbo-c m68000  atari   turbo-c)
         (borland-c-3.1    8086    ms-dos  borland-c)
         (djgpp            i386    ms-dos  gcc)
         (linux            i386    linux   gcc)
         (microsoft-c      8086    ms-dos  microsoft-c)
         (os/2-emx         i386    os/2    gcc)
         (turbo-c-2        8086    ms-dos  turbo-c)
         (watcom-9.0       i386    ms-dos  watcom))))
     
     ((my-rdb 'close-database))
     
     (set! my-rdb (open-database "foo.db" 'alist-table))
     -|
     Welcome


File: slib.info,  Node: The *commands* Table,  Next: Command Service,  Prev: Define-tables Example,  Up: Embedded Commands

The *commands* Table
....................

The table `*commands*' in an "enhanced" relational-database has the
fields (with domains):
     PRI name        symbol
         parameters  parameter-list
         procedure   expression
         documentation string

  The `parameters' field is a foreign key (domain `parameter-list') of
the `*catalog-data*' table and should have the value of a table
described by `*parameter-columns*'.  This `parameter-list' table
describes the arguments suitable for passing to the associated command.
The intent of this table is to be of a form such that different
user-interfaces (for instance, pull-down menus or plain-text queries)
can operate from the same table.  A `parameter-list' table has the
following fields:
     PRI index       uint
         name        symbol
         arity       parameter-arity
         domain      domain
         defaulter   expression
         expander    expression
         documentation string

  The `arity' field can take the values:

`single'
     Requires a single parameter of the specified domain.

`optional'
     A single parameter of the specified domain or zero parameters is
     acceptable.

`boolean'
     A single boolean parameter or zero parameters (in which case `#f'
     is substituted) is acceptable.

`nary'
     Any number of parameters of the specified domain are acceptable.
     The argument passed to the command function is always a list of the
     parameters.

`nary1'
     One or more of parameters of the specified domain are acceptable.
     The argument passed to the command function is always a list of the
     parameters.

  The `domain' field specifies the domain which a parameter or
parameters in the `index'th field must satisfy.

  The `defaulter' field is an expression whose value is either `#f' or
a procedure of one argument (the parameter-list) which returns a _list_
of the default value or values as appropriate.  Note that since the
`defaulter' procedure is called every time a default parameter is
needed for this column, "sticky" defaults can be implemented using
shared state with the domain-integrity-rule.


File: slib.info,  Node: Command Service,  Next: Command Example,  Prev: The *commands* Table,  Up: Embedded Commands

Command Service
...............

 - Function: make-command-server rdb table-name
     Returns a procedure of 2 arguments, a (symbol) command and a
     call-back procedure.  When this returned procedure is called, it
     looks up COMMAND in table TABLE-NAME and calls the call-back
     procedure with arguments:
    COMMAND
          The COMMAND

    COMMAND-VALUE
          The result of evaluating the expression in the PROCEDURE
          field of TABLE-NAME and calling it with RDB.

    PARAMETER-NAME
          A list of the "official" name of each parameter.  Corresponds
          to the `name' field of the COMMAND's parameter-table.

    POSITIONS
          A list of the positive integer index of each parameter.
          Corresponds to the `index' field of the COMMAND's
          parameter-table.

    ARITIES
          A list of the arities of each parameter.  Corresponds to the
          `arity' field of the COMMAND's parameter-table.  For a
          description of `arity' see table above.

    TYPES
          A list of the type name of each parameter.  Correspnds to the
          `type-id' field of the contents of the `domain' of the
          COMMAND's parameter-table.

    DEFAULTERS
          A list of the defaulters for each parameter.  Corresponds to
          the `defaulters' field of the COMMAND's parameter-table.

    DOMAIN-INTEGRITY-RULES
          A list of procedures (one for each parameter) which tests
          whether a value for a parameter is acceptable for that
          parameter.  The procedure should be called with each datum in
          the list for `nary' arity parameters.

    ALIASES
          A list of lists of `(alias parameter-name)'.  There can be
          more than one alias per PARAMETER-NAME.

  For information about parameters, *Note Parameter lists::.


File: slib.info,  Node: Command Example,  Prev: Command Service,  Up: Embedded Commands

Command Example
...............

  Here is an example of setting up a command with arguments and parsing
those arguments from a `getopt' style argument list (*note Getopt::).

     (require 'database-commands)                                             |
     (require 'databases)
     (require 'getopt-parameters)                                             |
     (require 'parameters)
     (require 'getopt)
     (require 'fluid-let)                                                     |
     (require 'printf)                                                        |
     
     (define my-rdb (add-command-tables (create-database #f 'alist-table)))   |
     
     (define-tables my-rdb
       '(foo-params
         *parameter-columns*
         *parameter-columns*
         ((1 single-string single string
             (lambda (pl) '("str")) #f "single string")
          (2 nary-symbols nary symbol
             (lambda (pl) '()) #f "zero or more symbols")
          (3 nary1-symbols nary1 symbol
             (lambda (pl) '(symb)) #f "one or more symbols")
          (4 optional-number optional uint
             (lambda (pl) '()) #f "zero or one number")
          (5 flag boolean boolean
             (lambda (pl) '(#f)) #f "a boolean flag")))
       '(foo-pnames
         ((name string))
         ((parameter-index uint))
         (("s" 1)
          ("single-string" 1)
          ("n" 2)
          ("nary-symbols" 2)
          ("N" 3)
          ("nary1-symbols" 3)
          ("o" 4)
          ("optional-number" 4)
          ("f" 5)
          ("flag" 5)))
       '(my-commands
         ((name symbol))
         ((parameters parameter-list)
          (parameter-names parameter-name-translation)
          (procedure expression)
          (documentation string))
         ((foo
           foo-params
           foo-pnames
           (lambda (rdb) (lambda args (print args)))
           "test command arguments"))))
     
     (define (dbutil:serve-command-line rdb command-table
                                        command argc argv)
       (set! argv (if (vector? argv) (vector->list argv) argv))
       ((make-command-server rdb command-table)
        command
        (lambda (comname comval options positions
                         arities types defaulters dirs aliases)
          (apply comval (getopt->arglist
                         argc argv options positions
                         arities types defaulters dirs aliases)))))
     
     (define (cmd . opts)
       (fluid-let ((*optind* 1))
         (printf "%-34s => "
                 (call-with-output-string
                  (lambda (pt) (write (cons 'cmd opts) pt))))
         (set! opts (cons "cmd" opts))
         (force-output)
         (dbutil:serve-command-line
          my-rdb 'my-commands 'foo (length opts) opts)))
     
     (cmd)                              => ("str" () (symb) () #f)
     (cmd "-f")                         => ("str" () (symb) () #t)
     (cmd "--flag")                     => ("str" () (symb) () #t)
     (cmd "-o177")                      => ("str" () (symb) (177) #f)
     (cmd "-o" "177")                   => ("str" () (symb) (177) #f)
     (cmd "--optional" "621")           => ("str" () (symb) (621) #f)
     (cmd "--optional=621")             => ("str" () (symb) (621) #f)
     (cmd "-s" "speciality")            => ("speciality" () (symb) () #f)
     (cmd "-sspeciality")               => ("speciality" () (symb) () #f)
     (cmd "--single" "serendipity")     => ("serendipity" () (symb) () #f)
     (cmd "--single=serendipity")       => ("serendipity" () (symb) () #f)
     (cmd "-n" "gravity" "piety")       => ("str" () (piety gravity) () #f)
     (cmd "-ngravity" "piety")          => ("str" () (piety gravity) () #f)
     (cmd "--nary" "chastity")          => ("str" () (chastity) () #f)
     (cmd "--nary=chastity" "")         => ("str" () ( chastity) () #f)
     (cmd "-N" "calamity")              => ("str" () (calamity) () #f)
     (cmd "-Ncalamity")                 => ("str" () (calamity) () #f)
     (cmd "--nary1" "surety")           => ("str" () (surety) () #f)
     (cmd "--nary1=surety")             => ("str" () (surety) () #f)
     (cmd "-N" "levity" "fealty")       => ("str" () (fealty levity) () #f)
     (cmd "-Nlevity" "fealty")          => ("str" () (fealty levity) () #f)
     (cmd "--nary1" "surety" "brevity") => ("str" () (brevity surety) () #f)
     (cmd "--nary1=surety" "brevity")   => ("str" () (brevity surety) () #f)
     (cmd "-?")
     -|
     Usage: cmd [OPTION ARGUMENT ...] ...
     
       -f, --flag
       -o, --optional[=]<number>
       -n, --nary[=]<symbols> ...
       -N, --nary1[=]<symbols> ...
       -s, --single[=]<string>
     
     ERROR: getopt->parameter-list "unrecognized option" "-?"


File: slib.info,  Node: Database Macros,  Next: Database Reports,  Prev: Embedded Commands,  Up: Relational Database
                                                                              |
Database Macros                                                               |
---------------                                                               |
                                                                              |
  `(require 'within-database)'                                                |
                                                                              |
  The object-oriented programming interface to SLIB relational databases      |
has failed to support clear, understandable, and modular code-writing         |
for database applications.                                                    |
                                                                              |
  This seems to be a failure of the object-oriented paradigm where the        |
type of an object is not manifest (or even traceable) in source code.         |
                                                                              |
  `within-database', along with the `databases' package, reorganizes          |
high-level database functions toward a more declarative style.  Using         |
this package, one can tag database table and command declarations for         |
emacs:                                                                        |
                                                                              |
     etags -lscheme -r'/ *(define-\(command\|table\) (\([^; \t]+\)/\2/' \     |
           source1.scm ...                                                    |
                                                                              |
* Menu:                                                                       |
                                                                              |
* Within-database Example::                                                   |
                                                                              |
 - Function: within-database database statement-1 ...                         |
     `within-database' creates a lexical scope in which the commands          |
     `define-table' and `define-command' create tables and                    |
     `*commands*'-table entries respectively in open relational               |
     database DATABASE.                                                       |
                                                                              |
     `within-database' Returns DATABASE.                                      |
                                                                              |
 - Syntax: define-command (<name> <rdb>) "comment" <expression1>              |
          <expression2> ...                                                   |
 - Syntax: define-command (<name> <rdb>) <expression1> <expression2> ...      |
     Adds to the `*commands*' table a command <name>:                         |
                                                                              |
          (lambda (<name> <rdb>) <expression1> <expression2> ...)             |
                                                                              |
                                                                              |
 - Syntax: define-table <name> <descriptor-name> <descriptor-name>            |
          <rows>                                                              |
 - Syntax: define-table <name> <primary-key-fields> <other-fields>            |
          <rows>                                                              |
     where <name> is the table name, <descriptor-name> is the symbol          |
     name of a descriptor table, <primary-key-fields> and                     |
     <other-fields> describe the primary keys and other fields                |
     respectively, and <rows> is a list of data rows to be added to the       |
     table.                                                                   |
                                                                              |
     <primary-key-fields> and <other-fields> are lists of field               |
     descriptors of the form:                                                 |
                                                                              |
          (<column-name> <domain>)                                            |
     or                                                                       |
          (<column-name> <domain> <column-integrity-rule>)                    |
                                                                              |
     where <column-name> is the column name, <domain> is the domain of        |
     the column, and <column-integrity-rule> is an expression whose           |
     value is a procedure of one argument (which returns `#f' to signal       |
     an error).                                                               |
                                                                              |
     If <domain> is not a defined domain name and it matches the name of      |
     this table or an already defined (in one of SPEC-0 ...) single key       |
     field table, a foriegn-key domain will be created for it.                |
                                                                              |
                                                                              |

File: slib.info,  Node: Within-database Example,  Prev: Database Macros,  Up: Database Macros
                                                                              |
Within-database Example                                                       |
.......................                                                       |
                                                                              |
Here is an example of `within-database' macros:                               |
                                                                              |
     (require 'within-database)                                               |
                                                                              |
     (define my-rdb                                                           |
       (add-command-tables                                                    |
        (create-database "foo.db" 'alist-table)))                             |
                                                                              |
     (within-database my-rdb                                                  |
       (define-command (*initialize* rdb)                                     |
         "Print Welcome"                                                      |
         (display "Welcome")                                                  |
         (newline)                                                            |
         rdb)                                                                 |
       (define-table (processor-family                                        |
                      ((family   atom))                                       |
                      ((also-ran processor-family)))                          |
         (m68000  #f)                                                         |
         (m68030  m68000)                                                     |
         (i386    8086)                                                       |
         (8086    #f)                                                         |
         (powerpc #f))                                                        |
       (define-table (platform                                                |
                      ((name symbol))                                         |
                      ((processor processor-family)                           |
                       (os        symbol)                                     |
                       (compiler  symbol)))                                   |
         (aix              powerpc aix     -)                                 |
         ;; ...                                                               |
         (amiga-aztec      m68000  amiga   aztec)                             |
         (amiga-sas/c-5.10 m68000  amiga   sas/c)                             |
         (atari-st-gcc     m68000  atari   gcc)                               |
         ;; ...                                                               |
         (watcom-9.0       i386    ms-dos  watcom))                           |
       (define-command (get-processor rdb)                                    |
         "Get processor for given platform."                                  |
         (((rdb 'open-table) 'platform #f) 'get 'processor)))                 |
                                                                              |
     ((my-rdb 'close-database))                                               |
                                                                              |
     (set! my-rdb (open-command-database! "foo.db"))                          |
     -|                                                                       |
     Welcome                                                                  |
                                                                              |
     ((my-rdb 'get-processor) 'amiga-sas/c-5.10)                              |
     => m68000                                                                |
                                                                              |

File: slib.info,  Node: Database Reports,  Next: Database Browser,  Prev: Database Macros,  Up: Relational Database
                                                                              |
Database Reports
----------------

Code for generating database reports is in `report.scm'.  After writing
it using `format', I discovered that Common-Lisp `format' is not
useable for this application because there is no mechanismm for
truncating fields.  `report.scm' needs to be rewritten using `printf'.

 - Procedure: create-report rdb destination report-name table
 - Procedure: create-report rdb destination report-name
     The symbol REPORT-NAME must be primary key in the table named
     `*reports*' in the relational database RDB.  DESTINATION is a
     port, string, or symbol.  If DESTINATION is a:

    port
          The table is created as ascii text and written to that port.

    string
          The table is created as ascii text and written to the file
          named by DESTINATION.

    symbol
          DESTINATION is the primary key for a row in the table named
          *printers*.

     The report is prepared as follows:

        * `Format' (*note Format::) is called with the `header' field
          and the (list of) `column-names' of the table.

        * `Format' is called with the `reporter' field and (on
          successive calls) each record in the natural order for the
          table.  A count is kept of the number of newlines output by
          format.  When the number of newlines to be output exceeds the
          number of lines per page, the set of lines will be broken if
          there are more than `minimum-break' left on this page and the
          number of lines for this row is larger or equal to twice
          `minimum-break'.

        * `Format' is called with the `footer' field and the (list of)
          `column-names' of the table.  The footer field should not
          output a newline.

        * A new page is output.

        * This entire process repeats until all the rows are output.

  Each row in the table *reports* has the fields:

name
     The report name.

default-table
     The table to report on if none is specified.

header, footer
     A `format' string.  At the beginning and end of each page
     respectively, `format' is called with this string and the (list of)
     column-names of this table.

reporter
     A `format' string.  For each row in the table, `format' is called
     with this string and the row.

minimum-break
     The minimum number of lines into which the report lines for a row
     can be broken.  Use `0' if a row's lines should not be broken over
     page boundaries.

  Each row in the table *printers* has the fields:

name
     The printer name.

print-procedure
     The procedure to call to actually print.


File: slib.info,  Node: Database Browser,  Prev: Database Reports,  Up: Relational Database

Database Browser
----------------

  (require 'database-browse)

 - Procedure: browse database
     Prints the names of all the tables in DATABASE and sets browse's
     default to DATABASE.

 - Procedure: browse
     Prints the names of all the tables in the default database.

 - Procedure: browse table-name
     For each record of the table named by the symbol TABLE-NAME,
     prints a line composed of all the field values.

 - Procedure: browse pathname
     Opens the database named by the string PATHNAME, prints the names
     of all its tables, and sets browse's default to the database.

 - Procedure: browse database table-name
     Sets browse's default to DATABASE and prints the records of the
     table named by the symbol TABLE-NAME.

 - Procedure: browse pathname table-name
     Opens the database named by the string PATHNAME and sets browse's
     default to it; `browse' prints the records of the table named by
     the symbol TABLE-NAME.



File: slib.info,  Node: Weight-Balanced Trees,  Prev: Relational Database,  Up: Database Packages

Weight-Balanced Trees
=====================

  `(require 'wt-tree)'

  Balanced binary trees are a useful data structure for maintaining
large sets of ordered objects or sets of associations whose keys are
ordered.  MIT Scheme has an comprehensive implementation of
weight-balanced binary trees which has several advantages over the
other data structures for large aggregates:

   * In addition to the usual element-level operations like insertion,
     deletion and lookup, there is a full complement of collection-level
     operations, like set intersection, set union and subset test, all
     of which are implemented with good orders of growth in time and
     space.  This makes weight balanced trees ideal for rapid
     prototyping of functionally derived specifications.

   * An element in a tree may be indexed by its position under the
     ordering of the keys, and the ordinal position of an element may
     be determined, both with reasonable efficiency.

   * Operations to find and remove minimum element make weight balanced
     trees simple to use for priority queues.

   * The implementation is _functional_ rather than _imperative_.  This
     means that operations like `inserting' an association in a tree do
     not destroy the old tree, in much the same way that `(+ 1 x)'
     modifies neither the constant 1 nor the value bound to `x'.  The
     trees are referentially transparent thus the programmer need not
     worry about copying the trees.  Referential transparency allows
     space efficiency to be achieved by sharing subtrees.


  These features make weight-balanced trees suitable for a wide range of
applications, especially those that require large numbers of sets or
discrete maps.  Applications that have a few global databases and/or
concentrate on element-level operations like insertion and lookup are
probably better off using hash-tables or red-black trees.

  The _size_ of a tree is the number of associations that it contains.
Weight balanced binary trees are balanced to keep the sizes of the
subtrees of each node within a constant factor of each other.  This
ensures logarithmic times for single-path operations (like lookup and
insertion).  A weight balanced tree takes space that is proportional to
the number of associations in the tree.  For the current
implementation, the constant of proportionality is six words per
association.

  Weight balanced trees can be used as an implementation for either
discrete sets or discrete maps (associations).  Sets are implemented by
ignoring the datum that is associated with the key.  Under this scheme
if an associations exists in the tree this indicates that the key of the
association is a member of the set.  Typically a value such as `()',
`#t' or `#f' is associated with the key.

  Many operations can be viewed as computing a result that, depending on
whether the tree arguments are thought of as sets or maps, is known by
two different names.  An example is `wt-tree/member?', which, when
regarding the tree argument as a set, computes the set membership
operation, but, when regarding the tree as a discrete map,
`wt-tree/member?' is the predicate testing if the map is defined at an
element in its domain.  Most names in this package have been chosen
based on interpreting the trees as sets, hence the name
`wt-tree/member?' rather than `wt-tree/defined-at?'.

  The weight balanced tree implementation is a run-time-loadable option.
To use weight balanced trees, execute

     (load-option 'wt-tree)

once before calling any of the procedures defined here.

* Menu:

* Construction of Weight-Balanced Trees::
* Basic Operations on Weight-Balanced Trees::
* Advanced Operations on Weight-Balanced Trees::
* Indexing Operations on Weight-Balanced Trees::


File: slib.info,  Node: Construction of Weight-Balanced Trees,  Next: Basic Operations on Weight-Balanced Trees,  Prev: Weight-Balanced Trees,  Up: Weight-Balanced Trees

Construction of Weight-Balanced Trees
-------------------------------------

  Binary trees require there to be a total order on the keys used to
arrange the elements in the tree.  Weight balanced trees are organized
by _types_, where the type is an object encapsulating the ordering
relation.  Creating a tree is a two-stage process.  First a tree type
must be created from the predicate which gives the ordering.  The tree
type is then used for making trees, either empty or singleton trees or
trees from other aggregate structures like association lists.  Once
created, a tree `knows' its type and the type is used to test
compatibility between trees in operations taking two trees.  Usually a
small number of tree types are created at the beginning of a program and
used many times throughout the program's execution.

 - procedure+: make-wt-tree-type key<?
     This procedure creates and returns a new tree type based on the
     ordering predicate KEY<?.  KEY<? must be a total ordering, having
     the property that for all key values `a', `b' and `c':

          (key<? a a)                         => #f
          (and (key<? a b) (key<? b a))       => #f
          (if (and (key<? a b) (key<? b c))
              (key<? a c)
              #t)                             => #t

     Two key values are assumed to be equal if neither is less than the
     other by KEY<?.

     Each call to `make-wt-tree-type' returns a distinct value, and
     trees are only compatible if their tree types are `eq?'.  A
     consequence is that trees that are intended to be used in binary
     tree operations must all be created with a tree type originating
     from the same call to `make-wt-tree-type'.

 - variable+: number-wt-type
     A standard tree type for trees with numeric keys.  `Number-wt-type'
     could have been defined by

          (define number-wt-type (make-wt-tree-type  <))

 - variable+: string-wt-type
     A standard tree type for trees with string keys.  `String-wt-type'
     could have been defined by

          (define string-wt-type (make-wt-tree-type  string<?))

 - procedure+: make-wt-tree wt-tree-type
     This procedure creates and returns a newly allocated weight
     balanced tree.  The tree is empty, i.e. it contains no
     associations.  WT-TREE-TYPE is a weight balanced tree type
     obtained by calling `make-wt-tree-type'; the returned tree has
     this type.

 - procedure+: singleton-wt-tree wt-tree-type key datum
     This procedure creates and returns a newly allocated weight
     balanced tree.  The tree contains a single association, that of
     DATUM with KEY.  WT-TREE-TYPE is a weight balanced tree type
     obtained by calling `make-wt-tree-type'; the returned tree has
     this type.

 - procedure+: alist->wt-tree tree-type alist
     Returns a newly allocated weight-balanced tree that contains the
     same associations as ALIST.  This procedure is equivalent to:

          (lambda (type alist)
            (let ((tree (make-wt-tree type)))
              (for-each (lambda (association)
                          (wt-tree/add! tree
                                        (car association)
                                        (cdr association)))
                        alist)
              tree))


File: slib.info,  Node: Basic Operations on Weight-Balanced Trees,  Next: Advanced Operations on Weight-Balanced Trees,  Prev: Construction of Weight-Balanced Trees,  Up: Weight-Balanced Trees

Basic Operations on Weight-Balanced Trees
-----------------------------------------

  This section describes the basic tree operations on weight balanced
trees.  These operations are the usual tree operations for insertion,
deletion and lookup, some predicates and a procedure for determining the
number of associations in a tree.

 - procedure+: wt-tree? object
     Returns `#t' if OBJECT is a weight-balanced tree, otherwise
     returns `#f'.

 - procedure+: wt-tree/empty? wt-tree
     Returns `#t' if WT-TREE contains no associations, otherwise
     returns `#f'.

 - procedure+: wt-tree/size wt-tree
     Returns the number of associations in WT-TREE, an exact
     non-negative integer.  This operation takes constant time.

 - procedure+: wt-tree/add wt-tree key datum
     Returns a new tree containing all the associations in WT-TREE and
     the association of DATUM with KEY.  If WT-TREE already had an
     association for KEY, the new association overrides the old.  The
     average and worst-case times required by this operation are
     proportional to the logarithm of the number of associations in
     WT-TREE.

 - procedure+: wt-tree/add! wt-tree key datum
     Associates DATUM with KEY in WT-TREE and returns an unspecified
     value.  If WT-TREE already has an association for KEY, that
     association is replaced.  The average and worst-case times
     required by this operation are proportional to the logarithm of
     the number of associations in WT-TREE.

 - procedure+: wt-tree/member? key wt-tree
     Returns `#t' if WT-TREE contains an association for KEY, otherwise
     returns `#f'.  The average and worst-case times required by this
     operation are proportional to the logarithm of the number of
     associations in WT-TREE.

 - procedure+: wt-tree/lookup wt-tree key default
     Returns the datum associated with KEY in WT-TREE.  If WT-TREE
     doesn't contain an association for KEY, DEFAULT is returned.  The
     average and worst-case times required by this operation are
     proportional to the logarithm of the number of associations in
     WT-TREE.

 - procedure+: wt-tree/delete wt-tree key
     Returns a new tree containing all the associations in WT-TREE,
     except that if WT-TREE contains an association for KEY, it is
     removed from the result.  The average and worst-case times required
     by this operation are proportional to the logarithm of the number
     of associations in WT-TREE.

 - procedure+: wt-tree/delete! wt-tree key
     If WT-TREE contains an association for KEY the association is
     removed.  Returns an unspecified value.  The average and worst-case
     times required by this operation are proportional to the logarithm
     of the number of associations in WT-TREE.


File: slib.info,  Node: Advanced Operations on Weight-Balanced Trees,  Next: Indexing Operations on Weight-Balanced Trees,  Prev: Basic Operations on Weight-Balanced Trees,  Up: Weight-Balanced Trees

Advanced Operations on Weight-Balanced Trees
--------------------------------------------

  In the following the _size_ of a tree is the number of associations
that the tree contains, and a _smaller_ tree contains fewer
associations.

 - procedure+: wt-tree/split< wt-tree bound
     Returns a new tree containing all and only the associations in
     WT-TREE which have a key that is less than BOUND in the ordering
     relation of the tree type of WT-TREE.  The average and worst-case
     times required by this operation are proportional to the logarithm
     of the size of WT-TREE.

 - procedure+: wt-tree/split> wt-tree bound
     Returns a new tree containing all and only the associations in
     WT-TREE which have a key that is greater than BOUND in the
     ordering relation of the tree type of WT-TREE.  The average and
     worst-case times required by this operation are proportional to the
     logarithm of size of WT-TREE.

 - procedure+: wt-tree/union wt-tree-1 wt-tree-2
     Returns a new tree containing all the associations from both trees.
     This operation is asymmetric: when both trees have an association
     for the same key, the returned tree associates the datum from
     WT-TREE-2 with the key.  Thus if the trees are viewed as discrete
     maps then `wt-tree/union' computes the map override of WT-TREE-1 by
     WT-TREE-2.  If the trees are viewed as sets the result is the set
     union of the arguments.  The worst-case time required by this
     operation is proportional to the sum of the sizes of both trees.
     If the minimum key of one tree is greater than the maximum key of
     the other tree then the time required is at worst proportional to
     the logarithm of the size of the larger tree.

 - procedure+: wt-tree/intersection wt-tree-1 wt-tree-2
     Returns a new tree containing all and only those associations from
     WT-TREE-1 which have keys appearing as the key of an association
     in WT-TREE-2.  Thus the associated data in the result are those
     from WT-TREE-1.  If the trees are being used as sets the result is
     the set intersection of the arguments.  As a discrete map
     operation, `wt-tree/intersection' computes the domain restriction
     of WT-TREE-1 to (the domain of) WT-TREE-2.  The time required by
     this operation is never worse that proportional to the sum of the
     sizes of the trees.

 - procedure+: wt-tree/difference wt-tree-1 wt-tree-2
     Returns a new tree containing all and only those associations from
     WT-TREE-1 which have keys that _do not_ appear as the key of an
     association in WT-TREE-2.  If the trees are viewed as sets the
     result is the asymmetric set difference of the arguments.  As a
     discrete map operation, it computes the domain restriction of
     WT-TREE-1 to the complement of (the domain of) WT-TREE-2.  The
     time required by this operation is never worse that proportional to
     the sum of the sizes of the trees.

 - procedure+: wt-tree/subset? wt-tree-1 wt-tree-2
     Returns `#t' iff the key of each association in WT-TREE-1 is the
     key of some association in WT-TREE-2, otherwise returns `#f'.
     Viewed as a set operation, `wt-tree/subset?' is the improper subset
     predicate.  A proper subset predicate can be constructed:

          (define (proper-subset? s1 s2)
            (and (wt-tree/subset? s1 s2)
                 (< (wt-tree/size s1) (wt-tree/size s2))))

     As a discrete map operation, `wt-tree/subset?' is the subset test
     on the domain(s) of the map(s).  In the worst-case the time
     required by this operation is proportional to the size of
     WT-TREE-1.

 - procedure+: wt-tree/set-equal? wt-tree-1 wt-tree-2
     Returns `#t' iff for every association in WT-TREE-1 there is an
     association in WT-TREE-2 that has the same key, and _vice versa_.

     Viewing the arguments as sets `wt-tree/set-equal?' is the set
     equality predicate.  As a map operation it determines if two maps
     are defined on the same domain.

     This procedure is equivalent to

          (lambda (wt-tree-1 wt-tree-2)
            (and (wt-tree/subset? wt-tree-1 wt-tree-2
                 (wt-tree/subset? wt-tree-2 wt-tree-1)))

     In the worst-case the time required by this operation is
     proportional to the size of the smaller tree.

 - procedure+: wt-tree/fold combiner initial wt-tree
     This procedure reduces WT-TREE by combining all the associations,
     using an reverse in-order traversal, so the associations are
     visited in reverse order.  COMBINER is a procedure of three
     arguments: a key, a datum and the accumulated result so far.
     Provided COMBINER takes time bounded by a constant, `wt-tree/fold'
     takes time proportional to the size of WT-TREE.

     A sorted association list can be derived simply:

          (wt-tree/fold  (lambda (key datum list)
                           (cons (cons key datum) list))
                         '()
                         WT-TREE))

     The data in the associations can be summed like this:

          (wt-tree/fold  (lambda (key datum sum) (+ sum datum))
                         0
                         WT-TREE)

 - procedure+: wt-tree/for-each action wt-tree
     This procedure traverses the tree in-order, applying ACTION to
     each association.  The associations are processed in increasing
     order of their keys.  ACTION is a procedure of two arguments which
     take the key and datum respectively of the association.  Provided
     ACTION takes time bounded by a constant, `wt-tree/for-each' takes
     time proportional to in the size of WT-TREE.  The example prints
     the tree:

          (wt-tree/for-each (lambda (key value)
                              (display (list key value)))
                            WT-TREE))


File: slib.info,  Node: Indexing Operations on Weight-Balanced Trees,  Prev: Advanced Operations on Weight-Balanced Trees,  Up: Weight-Balanced Trees

Indexing Operations on Weight-Balanced Trees
--------------------------------------------

  Weight balanced trees support operations that view the tree as sorted
sequence of associations.  Elements of the sequence can be accessed by
position, and the position of an element in the sequence can be
determined, both in logarthmic time.

 - procedure+: wt-tree/index wt-tree index
 - procedure+: wt-tree/index-datum wt-tree index
 - procedure+: wt-tree/index-pair wt-tree index
     Returns the 0-based INDEXth association of WT-TREE in the sorted
     sequence under the tree's ordering relation on the keys.
     `wt-tree/index' returns the INDEXth key, `wt-tree/index-datum'
     returns the datum associated with the INDEXth key and
     `wt-tree/index-pair' returns a new pair `(KEY . DATUM)' which is
     the `cons' of the INDEXth key and its datum.  The average and
     worst-case times required by this operation are proportional to
     the logarithm of the number of associations in the tree.

     These operations signal an error if the tree is empty, if
     INDEX`<0', or if INDEX is greater than or equal to the number of
     associations in the tree.

     Indexing can be used to find the median and maximum keys in the
     tree as follows:

          median:   (wt-tree/index WT-TREE
                                   (quotient (wt-tree/size WT-TREE) 2))
          
          maximum:  (wt-tree/index WT-TREE
                                   (-1+ (wt-tree/size WT-TREE)))

 - procedure+: wt-tree/rank wt-tree key
     Determines the 0-based position of KEY in the sorted sequence of
     the keys under the tree's ordering relation, or `#f' if the tree
     has no association with for KEY.  This procedure returns either an
     exact non-negative integer or `#f'.  The average and worst-case
     times required by this operation are proportional to the logarithm
     of the number of associations in the tree.

 - procedure+: wt-tree/min wt-tree
 - procedure+: wt-tree/min-datum wt-tree
 - procedure+: wt-tree/min-pair wt-tree
     Returns the association of WT-TREE that has the least key under
     the tree's ordering relation.  `wt-tree/min' returns the least key,
     `wt-tree/min-datum' returns the datum associated with the least key
     and `wt-tree/min-pair' returns a new pair `(key . datum)' which is
     the `cons' of the minimum key and its datum.  The average and
     worst-case times required by this operation are proportional to the
     logarithm of the number of associations in the tree.

     These operations signal an error if the tree is empty.  They could
     be written
          (define (wt-tree/min tree)        (wt-tree/index tree 0))
          (define (wt-tree/min-datum tree)  (wt-tree/index-datum tree 0))
          (define (wt-tree/min-pair tree)   (wt-tree/index-pair tree 0))

 - procedure+: wt-tree/delete-min wt-tree
     Returns a new tree containing all of the associations in WT-TREE
     except the association with the least key under the WT-TREE's
     ordering relation.  An error is signalled if the tree is empty.
     The average and worst-case times required by this operation are
     proportional to the logarithm of the number of associations in the
     tree.  This operation is equivalent to

          (wt-tree/delete WT-TREE (wt-tree/min WT-TREE))

 - procedure+: wt-tree/delete-min! wt-tree
     Removes the association with the least key under the WT-TREE's
     ordering relation.  An error is signalled if the tree is empty.
     The average and worst-case times required by this operation are
     proportional to the logarithm of the number of associations in the
     tree.  This operation is equivalent to

          (wt-tree/delete! WT-TREE (wt-tree/min WT-TREE))


File: slib.info,  Node: Other Packages,  Next: About SLIB,  Prev: Database Packages,  Up: Top

Other Packages
**************

* Menu:

* Data Structures::             Various data structures.
* Sorting and Searching::
* Procedures::                  Miscellaneous utility procedures.
* Standards Support::           Support for Scheme Standards.
* Session Support::             REPL and Debugging.
* System Interface::            'system, 'getenv, and other programs.
* Extra-SLIB Packages::


File: slib.info,  Node: Data Structures,  Next: Sorting and Searching,  Prev: Other Packages,  Up: Other Packages

Data Structures
===============

* Menu:

* Arrays::                      'array
* Subarrays::                   'subarray
* Array Mapping::               'array-for-each
* Association Lists::           'alist
* Byte::                        'byte
* MAT-File Format::             'matfile
* Portable Image Files::        'pnm
* Collections::                 'collect
* Dynamic Data Type::           'dynamic
* Hash Tables::                 'hash-table                                   |
* Object::                      'object
* Priority Queues::             'priority-queue
* Queues::                      'queue
* Records::                     'record


File: slib.info,  Node: Arrays,  Next: Subarrays,  Prev: Data Structures,  Up: Data Structures

Arrays
------

  `(require 'array)'

 - Function: array? obj
     Returns `#t' if the OBJ is an array, and `#f' if not.

_Note:_ Arrays are not disjoint from other Scheme types.  Strings and
vectors also satisfy `array?'.  A disjoint array predicate can be
written:

     (define (strict-array? obj)
       (and (array? obj) (not (string? obj)) (not (vector? obj))))

 - Function: array=? array1 array2
     Returns `#t' if ARRAY1 and ARRAY2 have the same rank and shape and
     the corresponding elements of ARRAY1 and ARRAY2 are `equal?'.

          (array=? (create-array '#(foo) 3 3) (create-array '#(foo) '(0 2) '(0 2)))
            => #t

 - Function: create-array prototype bound1 bound2 ...
     Creates and returns an array of type PROTOTYPE with dimensions
     BOUND1, BOUND2, ... and filled with elements from PROTOTYPE.
     PROTOTYPE must be an array, vector, or string.  The
     implementation-dependent type of the returned array will be the
     same as the type of PROTOTYPE; except if that would be a vector or
     string with non-zero origin, in which case some variety of array
     will be returned.

     If the PROTOTYPE has no elements, then the initial contents of the
     returned array are unspecified.  Otherwise, the returned array
     will be filled with the element at the origin of PROTOTYPE.

These functions return a uniform array prototype enclosing the optional
argument (which must be of the correct type).  If the uniform-array
type is supported by the implementation, then it is returned; promoting
to the next larger precision type; promoting finally to vector.

 - Function: ac64 z
 - Function: ac64
     Returns a high-precision complex uniform-array prototype.

 - Function: ac32 z
 - Function: ac32
     Returns a complex uniform-array prototype.

 - Function: ar64 x
 - Function: ar64
     Returns a high-precision real uniform-array prototype.

 - Function: ar32 x
 - Function: ar32
     Returns a real uniform-array prototype.

 - Function: as64 n
 - Function: as64
     Returns an exact signed integer uniform-array prototype with at
     least 64 bits of precision.

 - Function: as32 n
 - Function: as32
     Returns an exact signed integer uniform-array prototype with at
     least 32 bits of precision.

 - Function: as16 n
 - Function: as16
     Returns an exact signed integer uniform-array prototype with at
     least 16 bits of precision.

 - Function: as8 n
 - Function: as8
     Returns an exact signed integer uniform-array prototype with at
     least 8 bits of precision.

 - Function: au64 k
 - Function: au64
     Returns an exact non-negative integer uniform-array prototype with
     at least 64 bits of precision.

 - Function: au32 k
 - Function: au32
     Returns an exact non-negative integer uniform-array prototype with
     at least 32 bits of precision.

 - Function: au16 k
 - Function: au16
     Returns an exact non-negative integer uniform-array prototype with
     at least 16 bits of precision.

 - Function: au8 k
 - Function: au8
     Returns an exact non-negative integer uniform-array prototype with
     at least 8 bits of precision.

 - Function: at1 bool
 - Function: at1
     Returns a boolean uniform-array prototype.

 - Function: make-array initial-value bound1 bound2 ...
     Creates and returns an array with dimensions BOUND1, BOUND2, ...
     and filled with INITIAL-VALUE.

     `make-array' is a legacy function - now defined in terms of
     `create-array'.

          (define (make-array initial-value . dimensions)
            (apply create-array (vector initial-value) dimensions))

When constructing an array, BOUND is either an inclusive range of
indices expressed as a two element list, or an upper bound expressed as
a single integer.  So

     (create-array '#(foo) 3 3) == (make-array '#(foo) '(0 2) '(0 2))

 - Function: make-shared-array array mapper bound1 bound2 ...
     `make-shared-array' can be used to create shared subarrays of other
     arrays.  The MAPPER is a function that translates coordinates in
     the new array into coordinates in the old array.  A MAPPER must be
     linear, and its range must stay within the bounds of the old
     array, but it can be otherwise arbitrary.  A simple example:

          (define fred (create-array '#(#f) 8 8))
          (define freds-diagonal
            (make-shared-array fred (lambda (i) (list i i)) 8))
          (array-set! freds-diagonal 'foo 3)
          (array-ref fred 3 3)
             => FOO
          (define freds-center
            (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j)))
                               2 2))
          (array-ref freds-center 0 0)
             => FOO

 - Function: array-rank obj
     Returns the number of dimensions of OBJ.  If OBJ is not an array,
     0 is returned.

 - Function: array-shape array
     Returns a list of inclusive bounds.

          (array-shape (create-array '#() 3 5))
             => ((0 2) (0 4))

 - Function: array-dimensions array
     `array-dimensions' is similar to `array-shape' but replaces
     elements with a 0 minimum with one greater than the maximum.

          (array-dimensions (create-array '#() 3 5))
             => (3 5)

 - Function: array-in-bounds? array index1 index2 ...
     Returns `#t' if its arguments would be acceptable to `array-ref'.

 - Function: array-ref array index1 index2 ...
     Returns the (INDEX1, INDEX2, ...) element of ARRAY.

 - Function: array-set! array obj index1 index2 ...
     Stores OBJ in the (INDEX1, INDEX2, ...) element of ARRAY.  The
     value returned by `array-set!' is unspecified.


File: slib.info,  Node: Subarrays,  Next: Array Mapping,  Prev: Arrays,  Up: Data Structures

Subarrays
---------

  `(require 'subarray)'

 - Function: subarray array select ...
     selects a subset of an array.  For ARRAY of rank n, there must be
     at least n SELECTS arguments.  For 0 <= j < n, SELECTSj is either
     an integer, a list of two integers within the range for the jth
     index, or #f.

     When SELECTSj is a list of two integers, then the jth index is
     restricted to that subrange in the returned array.

     When SELECTSj is #f, then the full range of the jth index is
     accessible in the returned array.  An elided argument is
     equivalent to #f.

     When SELECTSj is an integer, then the rank of the returned array is
     less than ARRAY, and only elements whose jth index equals SELECTSj
     are shared.

          > (define ra '#2A((a b c) (d e f)))
          #<unspecified>
          > (subarray ra 0 #f)
          #1A(a b c)
          > (subarray ra 1 #f)
          #1A(d e f)
          > (subarray ra #f 1)
          #1A(b e)
          > (subarray ra '(0 1) #f)
          #2A((a b c) (d e f))
          > (subarray ra #f '(0 1))
          #2A((a b) (d e))
          > (subarray ra #f '(1 2))
          #2A((b c) (e f))

 - Function: subarray0 array select ...
     Behaves like subarray, but aligns the returned array origin to 0
     ....

 - Function: array-align array coord ...
     Returns an array shared with ARRAY but with a different origin.
     The COORDS are the exact integer coordinates of the new origin.
     Indexes corresponding to missing or #f coordinates are not
     realigned.

     For example:
          (define ra2 (create-array '#(5) '(5 9) '(-4 0)))
          (array-shape ra2)                       => ((5 9) (-4 0))
          (array-shape (array-align ra2 0 0))     => ((0 4) (0 4))
          (array-shape (array-align ra2 0))       => ((0 4) (-4 0))
          (array-shape (array-align ra2))         => ((5 9) (-4 0))
          (array-shape (array-align ra2 0 #f))    => ((0 4) (-4 0))
          (array-shape (array-align ra2 #f 0))    => ((5 9) (0 4))

 - Function: array-trim array trim ...
     Returns a subarray sharing contents with ARRAY except for slices
     removed from either side of each dimension.  Each of the TRIMS is
     an exact integer indicating how much to trim.  A positive S trims
     the data from the lower end and reduces the upper bound of the
     result; a negative S trims from the upper end and increases the
     lower bound.

     For example:
          (array-trim '#(0 1 2 3 4) 1)  => #1A(1 2 3 4) ;; shape is ((0 3))
          (array-trim '#(0 1 2 3 4) -1) => #1A(0 1 2 3) ;; shape is ((1 4))
          
          (require 'array-for-each)
          (define (centered-difference ra)
            (array-map - (array-trim ra 1) (array-trim ra -1)))
          (define (forward-difference ra)
            (array-map - (array-trim ra 1) ra))
          (define (backward-difference ra)
            (array-map - ra (array-trim ra -1)))
          
          (centered-difference '#(0 1 3 5 9 22))
            => #1A(3 4 6 17) ;;shape is ((1 4))
          (backward-difference '#(0 1 3 5 9 22))
            => #1A(1 2 2 4 13) ;; shape is ((1 5))
          (forward-difference '#(0 1 3 5 9 22))
            => #(1 2 2 4 13)  ;; shape is ((0 4))


File: slib.info,  Node: Array Mapping,  Next: Association Lists,  Prev: Subarrays,  Up: Data Structures

Array Mapping
-------------

  `(require 'array-for-each)'

 - Function: array-map! array0 proc array1 ...
     ARRAY1, ... must have the same number of dimensions as ARRAY0 and
     have a range for each index which includes the range for the
     corresponding index in ARRAY0.  PROC is applied to each tuple of
     elements of ARRAY1 ... and the result is stored as the
     corresponding element in ARRAY0.  The value returned is
     unspecified.  The order of application is unspecified.

 - Function: array-for-each PROC ARRAY0 ...
     PROC is applied to each tuple of elements of ARRAY0 ...  in
     row-major order.  The value returned is unspecified.

 - Function: array-indexes ARRAY
     Returns an array of lists of indexes for ARRAY such that, if LI is
     a list of indexes for which ARRAY is defined, (equal?  LI (apply
     array-ref (array-indexes ARRAY) LI)).

 - Function: array-index-map! array proc
     applies PROC to the indices of each element of ARRAY in turn,
     storing the result in the corresponding element.  The value
     returned and the order of application are unspecified.

     One can implement ARRAY-INDEXES as
          (define (array-indexes array)
              (let ((ra (apply create-array '#() (array-shape array))))
                (array-index-map! ra (lambda x x))
                ra))
     Another example:
          (define (apl:index-generator n)
              (let ((v (make-vector n 1)))
                (array-index-map! v (lambda (i) i))
                v))

 - Function: array-copy! source destination
     Copies every element from vector or array SOURCE to the
     corresponding element of DESTINATION.  DESTINATION must have the
     same rank as SOURCE, and be at least as large in each dimension.
     The order of copying is unspecified.


File: slib.info,  Node: Association Lists,  Next: Byte,  Prev: Array Mapping,  Up: Data Structures

Association Lists
-----------------

  `(require 'alist)'

  Alist functions provide utilities for treating a list of key-value
pairs as an associative database.  These functions take an equality
predicate, PRED, as an argument.  This predicate should be repeatable,
symmetric, and transitive.

  Alist functions can be used with a secondary index method such as hash
tables for improved performance.

 - Function: predicate->asso pred
     Returns an "association function" (like `assq', `assv', or
     `assoc') corresponding to PRED.  The returned function returns a
     key-value pair whose key is `pred'-equal to its first argument or
     `#f' if no key in the alist is PRED-equal to the first argument.

 - Function: alist-inquirer pred
     Returns a procedure of 2 arguments, ALIST and KEY, which returns
     the value associated with KEY in ALIST or `#f' if KEY does not
     appear in ALIST.

 - Function: alist-associator pred
     Returns a procedure of 3 arguments, ALIST, KEY, and VALUE, which
     returns an alist with KEY and VALUE associated.  Any previous
     value associated with KEY will be lost.  This returned procedure
     may or may not have side effects on its ALIST argument.  An
     example of correct usage is:
          (define put (alist-associator string-ci=?))
          (define alist '())
          (set! alist (put alist "Foo" 9))

 - Function: alist-remover pred
     Returns a procedure of 2 arguments, ALIST and KEY, which returns
     an alist with an association whose KEY is key removed.  This
     returned procedure may or may not have side effects on its ALIST
     argument.  An example of correct usage is:
          (define rem (alist-remover string-ci=?))
          (set! alist (rem alist "foo"))

 - Function: alist-map proc alist
     Returns a new association list formed by mapping PROC over the
     keys and values of ALIST.   PROC must be a function of 2 arguments
     which returns the new value part.

 - Function: alist-for-each proc alist
     Applies PROC to each pair of keys and values of ALIST.  PROC must
     be a function of 2 arguments.  The returned value is unspecified.


File: slib.info,  Node: Byte,  Next: MAT-File Format,  Prev: Association Lists,  Up: Data Structures

Byte
----

  `(require 'byte)'

  Some algorithms are expressed in terms of arrays of small integers.
Using Scheme strings to implement these arrays is not portable vis-a-vis
the correspondence between integers and characters and non-ascii
character sets.  These functions abstract the notion of a "byte".

 - Function: byte-ref bytes k
     K must be a valid index of BYTES.  `byte-ref' returns byte K of
     BYTES using zero-origin indexing.

 - Procedure: byte-set! bytes k byte
     K must be a valid index of BYTES%, and BYTE must be a small
     integer.  `Byte-set!' stores BYTE in element K of BYTES and
     returns an unspecified value.

 - Function: make-bytes k
 - Function: make-bytes k byte
     `Make-bytes' returns a newly allocated byte-array of length K.  If
     BYTE is given, then all elements of the byte-array are initialized
     to BYTE, otherwise the contents of the byte-array are unspecified.


 - Function: bytes-length bytes
     `bytes-length' returns length of byte-array BYTES.


 - Function: bytes byte ...
     Returns a newly allocated byte-array composed of the arguments.


 - Function: bytes->list bytes
 - Function: list->bytes bytes
     `Bytes->list' returns a newly allocated list of the bytes that
     make up the given byte-array.  `List->bytes' returns a newly
     allocated byte-array formed from the small integers in the list
     BYTES. `Bytes->list' and `list->bytes' are inverses so far as
     `equal?' is concerned.


  Input and output of bytes should be with ports opened in "binary"
mode (*note Input/Output::).  Calling `open-file' with 'rb or 'wb modes
argument will return a binary port if the Scheme implementation
supports it.

 - Function: write-byte byte
 - Function: write-byte byte port
     Writes the byte BYTE (not an external representation of the byte)
     to the given PORT and returns an unspecified value.  The PORT
     argument may be omitted, in which case it defaults to the value
     returned by `current-output-port'.


 - Function: read-byte
 - Function: read-byte port
     Returns the next byte available from the input PORT, updating the
     PORT to point to the following byte.  If no more bytes are
     available, an end of file object is returned.  PORT may be
     omitted, in which case it defaults to the value returned by
     `current-input-port'.



File: slib.info,  Node: MAT-File Format,  Next: Portable Image Files,  Prev: Byte,  Up: Data Structures

MAT-File Format
---------------

  `(require 'matfile)'

`http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf'

This package reads MAT-File Format version 4 (MATLAB) binary data
files.  MAT-files written from big-endian or little-endian computers
having IEEE format numbers are currently supported.  Support for files
written from VAX or Cray machines could also be added.

The numeric and text matrix types handled; support for "sparse"
matrices awaits a sample file.

 - Function: matfile:read filename
     FILENAME should be a string naming an existing file containing a
     MATLAB Version 4 MAT-File.  The `matfile:read' procedure reads
     matrices from the file and returns a list of the results; a list
     of the name string and array for each matrix.

 - Function: matfile:load filename
     FILENAME should be a string naming an existing file containing a
     MATLAB Version 4 MAT-File.  The `matfile:load' procedure reads
     matrices from the file and defines the `string-ci->symbol' for
     each matrix to its corresponding array.  `matfile:load' returns a
     list of the symbols defined.


File: slib.info,  Node: Portable Image Files,  Next: Collections,  Prev: MAT-File Format,  Up: Data Structures

Portable Image Files
--------------------

  `(require 'pnm)'

 - Function: pnm:type-dimensions path
     The string PATH must name a "portable bitmap graphics" file.
     `pnm:type-dimensions' returns a list of 4 items:
       1. A symbol describing the type of the file named by PATH.

       2. The image width in pixels.

       3. The image height in pixels.

       4. The maximum value of pixels assume in the file.

     The current set of file-type symbols is:
    pbm
    pbm-raw
          Black-and-White image; pixel values are 0 or 1.

    pgm
    pgm-raw
          Gray (monochrome) image; pixel values are from 0 to MAXVAL
          specified in file header.

    ppm
    ppm-raw
          RGB (full color) image; red, green, and blue interleaved
          pixel values are from 0 to MAXVAL


 - Function: pnm:image-file->array path array
     Reads the "portable bitmap graphics" file named by PATH into
     ARRAY.  ARRAY must be the correct size and type for PATH.  ARRAY
     is returned.

 - Function: pnm:image-file->array path
     `pnm:image-file->array' creates and returns an array with the
     "portable bitmap graphics" file named by PATH read into it.


 - Procedure: pnm:array-write type array maxval path comment ...              |
     Writes the contents of ARRAY to a TYPE image file named PATH.  The
     file will have pixel values between 0 and MAXVAL, which must be
     compatible with TYPE.  For `pbm' files, MAXVAL must be `1'.
     COMMENTs are included in the file header.                                |



File: slib.info,  Node: Collections,  Next: Dynamic Data Type,  Prev: Portable Image Files,  Up: Data Structures

Collections
-----------

  `(require 'collect)'

  Routines for managing collections.  Collections are aggregate data
structures supporting iteration over their elements, similar to the
Dylan(TM) language, but with a different interface.  They have
"elements" indexed by corresponding "keys", although the keys may be
implicit (as with lists).

  New types of collections may be defined as YASOS objects (*note
Yasos::).  They must support the following operations:
   * `(collection? SELF)' (always returns `#t');

   * `(size SELF)' returns the number of elements in the collection;

   * `(print SELF PORT)' is a specialized print operation for the
     collection which prints a suitable representation on the given
     PORT or returns it as a string if PORT is `#t';

   * `(gen-elts SELF)' returns a thunk which on successive invocations
     yields elements of SELF in order or gives an error if it is
     invoked more than `(size SELF)' times;

   * `(gen-keys SELF)' is like `gen-elts', but yields the collection's
     keys in order.

  They might support specialized `for-each-key' and `for-each-elt'
operations.

 - Function: collection? obj
     A predicate, true initially of lists, vectors and strings.  New
     sorts of collections must answer `#t' to `collection?'.

 - Procedure: map-elts proc collection1 ...
 - Procedure: do-elts proc collection1 ...
     PROC is a procedure taking as many arguments as there are
     COLLECTIONS (at least one).  The COLLECTIONS are iterated over in
     their natural order and PROC is applied to the elements yielded by
     each iteration in turn.  The order in which the arguments are
     supplied corresponds to te order in which the COLLECTIONS appear.
     `do-elts' is used when only side-effects of PROC are of interest
     and its return value is unspecified.  `map-elts' returns a
     collection (actually a vector) of the results of the applications
     of PROC.

     Example:
          (map-elts + (list 1 2 3) (vector 1 2 3))
             => #(2 4 6)

 - Procedure: map-keys proc collection1 ...
 - Procedure: do-keys proc collection1 ...
     These are analogous to `map-elts' and `do-elts', but each
     iteration is over the COLLECTIONS' _keys_ rather than their
     elements.

     Example:
          (map-keys + (list 1 2 3) (vector 1 2 3))
             => #(0 2 4)

 - Procedure: for-each-key collection proc
 - Procedure: for-each-elt collection proc
     These are like `do-keys' and `do-elts' but only for a single
     collection; they are potentially more efficient.

 - Function: reduce proc seed collection1 ...
     A generalization of the list-based `comlist:reduce-init' (*note
     Lists as sequences::) to collections which will shadow the
     list-based version if `(require 'collect)' follows `(require
     'common-list-functions)' (*note Common List Functions::).

     Examples:
          (reduce + 0 (vector 1 2 3))
             => 6
          (reduce union '() '((a b c) (b c d) (d a)))
             => (c b d a).

 - Function: any? pred collection1 ...
     A generalization of the list-based `some' (*note Lists as
     sequences::) to collections.

     Example:
          (any? odd? (list 2 3 4 5))
             => #t

 - Function: every? pred collection1 ...
     A generalization of the list-based `every' (*note Lists as
     sequences::) to collections.

     Example:
          (every? collection? '((1 2) #(1 2)))
             => #t

 - Function: empty? collection
     Returns `#t' iff there are no elements in COLLECTION.

     `(empty? COLLECTION) == (zero? (size COLLECTION))'

 - Function: size collection
     Returns the number of elements in COLLECTION.

 - Function: Setter list-ref
     See *Note Setters:: for a definition of "setter".  N.B.  `(setter
     list-ref)' doesn't work properly for element 0 of a list.

  Here is a sample collection: `simple-table' which is also a `table'.
     (define-predicate TABLE?)
     (define-operation (LOOKUP table key failure-object))
     (define-operation (ASSOCIATE! table key value)) ;; returns key
     (define-operation (REMOVE! table key))          ;; returns value
     
     (define (MAKE-SIMPLE-TABLE)
       (let ( (table (list)) )
         (object
          ;; table behaviors
          ((TABLE? self) #t)
          ((SIZE self) (size table))
          ((PRINT self port) (format port "#<SIMPLE-TABLE>"))
          ((LOOKUP self key failure-object)
           (cond
            ((assq key table) => cdr)
            (else failure-object)
            ))
          ((ASSOCIATE! self key value)
           (cond
            ((assq key table)
             => (lambda (bucket) (set-cdr! bucket value) key))
            (else
             (set! table (cons (cons key value) table))
             key)
            ))
          ((REMOVE! self key);; returns old value
           (cond
            ((null? table) (slib:error "TABLE:REMOVE! Key not found: " key))
            ((eq? key (caar table))
             (let ( (value (cdar table)) )
               (set! table (cdr table))
               value)
             )
            (else
             (let loop ( (last table) (this (cdr table)) )
               (cond
                ((null? this)
                 (slib:error "TABLE:REMOVE! Key not found: " key))
                ((eq? key (caar this))
                 (let ( (value (cdar this)) )
                   (set-cdr! last (cdr this))
                   value)
                 )
                (else
                 (loop (cdr last) (cdr this)))
                ) ) )
            ))
          ;; collection behaviors
          ((COLLECTION? self) #t)
          ((GEN-KEYS self) (collect:list-gen-elts (map car table)))
          ((GEN-ELTS self) (collect:list-gen-elts (map cdr table)))
          ((FOR-EACH-KEY self proc)
           (for-each (lambda (bucket) (proc (car bucket))) table)
           )
          ((FOR-EACH-ELT self proc)
           (for-each (lambda (bucket) (proc (cdr bucket))) table)
           )
          ) ) )


File: slib.info,  Node: Dynamic Data Type,  Next: Hash Tables,  Prev: Collections,  Up: Data Structures

Dynamic Data Type
-----------------

  `(require 'dynamic)'

 - Function: make-dynamic obj
     Create and returns a new "dynamic" whose global value is OBJ.

 - Function: dynamic? obj
     Returns true if and only if OBJ is a dynamic.  No object
     satisfying `dynamic?' satisfies any of the other standard type
     predicates.

 - Function: dynamic-ref dyn
     Return the value of the given dynamic in the current dynamic
     environment.

 - Procedure: dynamic-set! dyn obj
     Change the value of the given dynamic to OBJ in the current
     dynamic environment.  The returned value is unspecified.

 - Function: call-with-dynamic-binding dyn obj thunk
     Invoke and return the value of the given thunk in a new, nested
     dynamic environment in which the given dynamic has been bound to a
     new location whose initial contents are the value OBJ.  This
     dynamic environment has precisely the same extent as the
     invocation of the thunk and is thus captured by continuations
     created within that invocation and re-established by those
     continuations when they are invoked.

  The `dynamic-bind' macro is not implemented.


File: slib.info,  Node: Hash Tables,  Next: Object,  Prev: Dynamic Data Type,  Up: Data Structures
                                                                              |
Hash Tables
-----------

  `(require 'hash-table)'

 - Function: predicate->hash pred
     Returns a hash function (like `hashq', `hashv', or `hash')
     corresponding to the equality predicate PRED.  PRED should be
     `eq?', `eqv?', `equal?', `=', `char=?', `char-ci=?', `string=?', or
     `string-ci=?'.

  A hash table is a vector of association lists.

 - Function: make-hash-table k
     Returns a vector of K empty (association) lists.

  Hash table functions provide utilities for an associative database.
These functions take an equality predicate, PRED, as an argument.  PRED
should be `eq?', `eqv?', `equal?', `=', `char=?', `char-ci=?',
`string=?', or `string-ci=?'.

 - Function: predicate->hash-asso pred
     Returns a hash association function of 2 arguments, KEY and
     HASHTAB, corresponding to PRED.  The returned function returns a
     key-value pair whose key is PRED-equal to its first argument or
     `#f' if no key in HASHTAB is PRED-equal to the first argument.

 - Function: hash-inquirer pred
     Returns a procedure of 2 arguments, HASHTAB and KEY, which returns
     the value associated with KEY in HASHTAB or `#f' if KEY does not
     appear in HASHTAB.

 - Function: hash-associator pred
     Returns a procedure of 3 arguments, HASHTAB, KEY, and VALUE, which
     modifies HASHTAB so that KEY and VALUE associated.  Any previous
     value associated with KEY will be lost.

 - Function: hash-remover pred
     Returns a procedure of 2 arguments, HASHTAB and KEY, which
     modifies HASHTAB so that the association whose key is KEY is
     removed.

 - Function: hash-map proc hash-table
     Returns a new hash table formed by mapping PROC over the keys and
     values of HASH-TABLE.  PROC must be a function of 2 arguments
     which returns the new value part.

 - Function: hash-for-each proc hash-table
     Applies PROC to each pair of keys and values of HASH-TABLE.  PROC
     must be a function of 2 arguments.  The returned value is
     unspecified.


File: slib.info,  Node: Object,  Next: Priority Queues,  Prev: Hash Tables,  Up: Data Structures
                                                                              |
Macroless Object System
-----------------------

  `(require 'object)'

  This is the Macroless Object System written by Wade Humeniuk
(whumeniu@datap.ca).  Conceptual Tributes: *Note Yasos::, MacScheme's
%object, CLOS, Lack of R4RS macros.

Concepts
--------

OBJECT
     An object is an ordered association-list (by `eq?') of methods
     (procedures).  Methods can be added (`make-method!'), deleted
     (`unmake-method!') and retrieved (`get-method').  Objects may
     inherit methods from other objects.  The object binds to the
     environment it was created in, allowing closures to be used to
     hide private procedures and data.

GENERIC-METHOD
     A generic-method associates (in terms of `eq?') object's method.
     This allows scheme function style to be used for objects.  The
     calling scheme for using a generic method is `(generic-method
     object param1 param2 ...)'.

METHOD
     A method is a procedure that exists in the object.  To use a method
     get-method must be called to look-up the method.  Generic methods
     implement the get-method functionality.  Methods may be added to an
     object associated with any scheme obj in terms of eq?

GENERIC-PREDICATE
     A generic method that returns a boolean value for any scheme obj.

PREDICATE
     A object's method asscociated with a generic-predicate. Returns
     `#t'.

Procedures
----------

 - Function: make-object ancestor ...
     Returns an object.  Current object implementation is a tagged
     vector.  ANCESTORs are optional and must be objects in terms of
     object?.  ANCESTORs methods are included in the object.  Multiple
     ANCESTORs might associate the same generic-method with a method.
     In this case the method of the ANCESTOR first appearing in the
     list is the one returned by `get-method'.

 - Function: object? obj
     Returns boolean value whether OBJ was created by make-object.

 - Function: make-generic-method exception-procedure
     Returns a procedure which be associated with an object's methods.
     If EXCEPTION-PROCEDURE is specified then it is used to process
     non-objects.

 - Function: make-generic-predicate
     Returns a boolean procedure for any scheme object.

 - Function: make-method! object generic-method method
     Associates METHOD to the GENERIC-METHOD in the object.  The METHOD
     overrides any previous association with the GENERIC-METHOD within
     the object.  Using `unmake-method!' will restore the object's
     previous association with the GENERIC-METHOD.  METHOD must be a
     procedure.

 - Function: make-predicate! object generic-preciate
     Makes a predicate method associated with the GENERIC-PREDICATE.

 - Function: unmake-method! object generic-method
     Removes an object's association with a GENERIC-METHOD .

 - Function: get-method object generic-method
     Returns the object's method associated (if any) with the
     GENERIC-METHOD.  If no associated method exists an error is
     flagged.

Examples
--------

     (require 'object)
     
     (define instantiate (make-generic-method))
     
     (define (make-instance-object . ancestors)
       (define self (apply make-object
                           (map (lambda (obj) (instantiate obj)) ancestors)))
       (make-method! self instantiate (lambda (self) self))
       self)
     
     (define who (make-generic-method))
     (define imigrate! (make-generic-method))
     (define emigrate! (make-generic-method))
     (define describe (make-generic-method))
     (define name (make-generic-method))
     (define address (make-generic-method))
     (define members (make-generic-method))
     
     (define society
       (let ()
         (define self (make-instance-object))
         (define population '())
         (make-method! self imigrate!
                       (lambda (new-person)
                         (if (not (eq? new-person self))
                             (set! population (cons new-person population)))))
         (make-method! self emigrate!
                       (lambda (person)
                         (if (not (eq? person self))
                             (set! population
                                   (comlist:remove-if (lambda (member)
                                                        (eq? member person))
                                                      population)))))
         (make-method! self describe
                       (lambda (self)
                         (map (lambda (person) (describe person)) population)))
         (make-method! self who
                       (lambda (self) (map (lambda (person) (name person))
                                           population)))
         (make-method! self members (lambda (self) population))
         self))
     
     (define (make-person %name %address)
       (define self (make-instance-object society))
       (make-method! self name (lambda (self) %name))
       (make-method! self address (lambda (self) %address))
       (make-method! self who (lambda (self) (name self)))
       (make-method! self instantiate
                     (lambda (self)
                       (make-person (string-append (name self) "-son-of")
                                    %address)))
       (make-method! self describe
                     (lambda (self) (list (name self) (address self))))
       (imigrate! self)
       self)

Inverter Documentation
......................

  Inheritance:
             <inverter>::(<number> <description>)
  Generic-methods
             <inverter>::value      => <number>::value
             <inverter>::set-value! => <number>::set-value!
             <inverter>::describe   => <description>::describe
             <inverter>::help
             <inverter>::invert
             <inverter>::inverter?

Number Documention
..................

  Inheritance
             <number>::()
  Slots
             <number>::<x>
  Generic Methods
             <number>::value
             <number>::set-value!

Inverter code
.............

     (require 'object)
     
     (define value (make-generic-method (lambda (val) val)))
     (define set-value! (make-generic-method))
     (define invert (make-generic-method
                     (lambda (val)
                       (if (number? val)
                           (/ 1 val)
                           (error "Method not supported:" val)))))
     (define noop (make-generic-method))
     (define inverter? (make-generic-predicate))
     (define describe (make-generic-method))
     (define help (make-generic-method))
     
     (define (make-number x)
       (define self (make-object))
       (make-method! self value (lambda (this) x))
       (make-method! self set-value!
                     (lambda (this new-value) (set! x new-value)))
       self)
     
     (define (make-description str)
       (define self (make-object))
       (make-method! self describe (lambda (this) str))
       (make-method! self help (lambda (this) "Help not available"))
       self)
     
     (define (make-inverter)
       (let* ((self (make-object
                     (make-number 1)
                     (make-description "A number which can be inverted")))
              (<value> (get-method self value)))
         (make-method! self invert (lambda (self) (/ 1 (<value> self))))
         (make-predicate! self inverter?)
         (unmake-method! self help)
         (make-method! self help
                       (lambda (self)
                         (display "Inverter Methods:") (newline)
                         (display "  (value inverter) ==> n") (newline)))
         self))
     
     ;;;; Try it out
     
     (define invert! (make-generic-method))
     
     (define x (make-inverter))
     
     (make-method! x invert! (lambda (x) (set-value! x (/ 1 (value x)))))
     
     (value x)                       => 1
     (set-value! x 33)               => undefined
     (invert! x)                     => undefined
     (value x)                       => 1/33
     
     (unmake-method! x invert!)      => undefined
     
     (invert! x)                     error-->  ERROR: Method not supported: x


File: slib.info,  Node: Priority Queues,  Next: Queues,  Prev: Object,  Up: Data Structures

Priority Queues
---------------

  `(require 'priority-queue)'

 - Function: make-heap pred<?
     Returns a binary heap suitable which can be used for priority queue
     operations.

 - Function: heap-length heap
     Returns the number of elements in HEAP.

 - Procedure: heap-insert! heap item
     Inserts ITEM into HEAP.  ITEM can be inserted multiple times.  The
     value returned is unspecified.

 - Function: heap-extract-max! heap
     Returns the item which is larger than all others according to the
     PRED<? argument to `make-heap'.  If there are no items in HEAP, an
     error is signaled.

  The algorithm for priority queues was taken from `Introduction to
Algorithms' by T. Cormen, C. Leiserson, R. Rivest.  1989 MIT Press.


File: slib.info,  Node: Queues,  Next: Records,  Prev: Priority Queues,  Up: Data Structures

Queues
------

  `(require 'queue)'

  A "queue" is a list where elements can be added to both the front and
rear, and removed from the front (i.e., they are what are often called
"dequeues").  A queue may also be used like a stack.

 - Function: make-queue
     Returns a new, empty queue.

 - Function: queue? obj
     Returns `#t' if OBJ is a queue.

 - Function: queue-empty? q
     Returns `#t' if the queue Q is empty.

 - Procedure: queue-push! q datum
     Adds DATUM to the front of queue Q.

 - Procedure: enquque! q datum
     Adds DATUM to the rear of queue Q.

  All of the following functions raise an error if the queue Q is empty.

 - Function: queue-front q
     Returns the datum at the front of the queue Q.

 - Function: queue-rear q
     Returns the datum at the rear of the queue Q.

 - Prcoedure: queue-pop! q
 - Procedure: dequeue! q
     Both of these procedures remove and return the datum at the front
     of the queue.  `queue-pop!' is used to suggest that the queue is
     being used like a stack.


File: slib.info,  Node: Records,  Prev: Queues,  Up: Data Structures

Records
-------

  `(require 'record)'

  The Record package provides a facility for user to define their own
record data types.

 - Function: make-record-type type-name field-names
     Returns a "record-type descriptor", a value representing a new data
     type disjoint from all others.  The TYPE-NAME argument must be a
     string, but is only used for debugging purposes (such as the
     printed representation of a record of the new type).  The
     FIELD-NAMES argument is a list of symbols naming the "fields" of a
     record of the new type.  It is an error if the list contains any
     duplicates.  It is unspecified how record-type descriptors are
     represented.

 - Function: record-constructor rtd [field-names]
     Returns a procedure for constructing new members of the type
     represented by RTD.  The returned procedure accepts exactly as
     many arguments as there are symbols in the given list,
     FIELD-NAMES; these are used, in order, as the initial values of
     those fields in a new record, which is returned by the constructor
     procedure.  The values of any fields not named in that list are
     unspecified.  The FIELD-NAMES argument defaults to the list of
     field names in the call to `make-record-type' that created the
     type represented by RTD; if the FIELD-NAMES argument is provided,
     it is an error if it contains any duplicates or any symbols not in
     the default list.

 - Function: record-predicate rtd
     Returns a procedure for testing membership in the type represented
     by RTD.  The returned procedure accepts exactly one argument and
     returns a true value if the argument is a member of the indicated
     record type; it returns a false value otherwise.

 - Function: record-accessor rtd field-name
     Returns a procedure for reading the value of a particular field of
     a member of the type represented by RTD.  The returned procedure
     accepts exactly one argument which must be a record of the
     appropriate type; it returns the current value of the field named
     by the symbol FIELD-NAME in that record.  The symbol FIELD-NAME
     must be a member of the list of field-names in the call to
     `make-record-type' that created the type represented by RTD.

 - Function: record-modifier rtd field-name
     Returns a procedure for writing the value of a particular field of
     a member of the type represented by RTD.  The returned procedure
     accepts exactly two arguments: first, a record of the appropriate
     type, and second, an arbitrary Scheme value; it modifies the field
     named by the symbol FIELD-NAME in that record to contain the given
     value.  The returned value of the modifier procedure is
     unspecified.  The symbol FIELD-NAME must be a member of the list
     of field-names in the call to `make-record-type' that created the
     type represented by RTD.

  In May of 1996, as a product of discussion on the `rrrs-authors'
mailing list, I rewrote `record.scm' to portably implement type
disjointness for record data types.

  As long as an implementation's procedures are opaque and the `record'
code is loaded before other programs, this will give disjoint record
types which are unforgeable and incorruptible by R4RS procedures.

  As a consequence, the procedures `record?', `record-type-descriptor',
`record-type-name'.and `record-type-field-names' are no longer
supported.


File: slib.info,  Node: Sorting and Searching,  Next: Procedures,  Prev: Data Structures,  Up: Other Packages

Sorting and Searching
=====================

* Menu:

* Common List Functions::       'common-list-functions
* Tree Operations::             'tree
* Chapter Ordering::            'chapter-order
* Sorting::                     'sort
* Topological Sort::            Keep your socks on.
* Hashing::                     'hash                                         |
* Space-Filling Curves::        'hilbert and 'sierpinski                      |
* Soundex::                     Dimension Reduction of Last Names             |
* String Search::               Also Search from a Port.
* Sequence Comparison::         'diff and longest-common-subsequence


File: slib.info,  Node: Common List Functions,  Next: Tree Operations,  Prev: Sorting and Searching,  Up: Sorting and Searching

Common List Functions
---------------------

  `(require 'common-list-functions)'

  The procedures below follow the Common LISP equivalents apart from
optional arguments in some cases.

* Menu:

* List construction::
* Lists as sets::
* Lists as sequences::
* Destructive list operations::
* Non-List functions::


File: slib.info,  Node: List construction,  Next: Lists as sets,  Prev: Common List Functions,  Up: Common List Functions

List construction
.................

 - Function: make-list k
 - Function: make-list k init
     `make-list' creates and returns a list of K elements.  If INIT is
     included, all elements in the list are initialized to INIT.

     Example:
          (make-list 3)
             => (#<unspecified> #<unspecified> #<unspecified>)
          (make-list 5 'foo)
             => (foo foo foo foo foo)

 - Function: list* obj1 obj2 ...
     Works like `list' except that the cdr of the last pair is the last
     argument unless there is only one argument, when the result is
     just that argument.  Sometimes called `cons*'.  E.g.:
          (list* 1)
             => 1
          (list* 1 2 3)
             => (1 2 . 3)
          (list* 1 2 '(3 4))
             => (1 2 3 4)
          (list* ARGS '())
             == (list ARGS)

 - Function: copy-list lst
     `copy-list' makes a copy of LST using new pairs and returns it.
     Only the top level of the list is copied, i.e., pairs forming
     elements of the copied list remain `eq?' to the corresponding
     elements of the original; the copy is, however, not `eq?' to the
     original, but is `equal?' to it.

     Example:
          (copy-list '(foo foo foo))
             => (foo foo foo)
          (define q '(foo bar baz bang))
          (define p q)
          (eq? p q)
             => #t
          (define r (copy-list q))
          (eq? q r)
             => #f
          (equal? q r)
             => #t
          (define bar '(bar))
          (eq? bar (car (copy-list (list bar 'foo))))
          => #t


File: slib.info,  Node: Lists as sets,  Next: Lists as sequences,  Prev: List construction,  Up: Common List Functions

Lists as sets
.............

  `eqv?' is used to test for membership by procedures which treat lists
as sets.

 - Function: adjoin e l
     `adjoin' returns the adjoint of the element E and the list L.
     That is, if E is in L, `adjoin' returns L, otherwise, it returns
     `(cons E L)'.

     Example:
          (adjoin 'baz '(bar baz bang))
             => (bar baz bang)
          (adjoin 'foo '(bar baz bang))
             => (foo bar baz bang)

 - Function: union l1 l2
     `union' returns the combination of L1 and L2.  Duplicates between
     L1 and L2 are culled.  Duplicates within L1 or within L2 may or
     may not be removed.

     Example:
          (union '(1 2 3 4) '(5 6 7 8))
             => (8 7 6 5 1 2 3 4)
          (union '(1 2 3 4) '(3 4 5 6))
             => (6 5 1 2 3 4)

 - Function: intersection l1 l2
     `intersection' returns all elements that are in both L1 and L2.

     Example:
          (intersection '(1 2 3 4) '(3 4 5 6))
             => (3 4)
          (intersection '(1 2 3 4) '(5 6 7 8))
             => ()

 - Function: set-difference l1 l2
     `set-difference' returns all elements that are in L1 but not in L2.

     Example:
          (set-difference '(1 2 3 4) '(3 4 5 6))
             => (1 2)
          (set-difference '(1 2 3 4) '(1 2 3 4 5 6))
             => ()

 - Function: member-if pred lst
     `member-if' returns the list headed by the first element of LST to
     satisfy `(PRED ELEMENT)'.  `Member-if' returns `#f' if PRED
     returns `#f' for every ELEMENT in LST.

     Example:
          (member-if vector? '(a 2 b 4))
             => #f
          (member-if number? '(a 2 b 4))
             => (2 b 4)

 - Function: some pred lst1 lst2 ...
     PRED is a boolean function of as many arguments as there are list
     arguments to `some' i.e., LST plus any optional arguments.  PRED
     is applied to successive elements of the list arguments in order.
     `some' returns `#t' as soon as one of these applications returns
     `#t', and is `#f' if none returns `#t'.  All the lists should have
     the same length.

     Example:
          (some odd? '(1 2 3 4))
             => #t
          
          (some odd? '(2 4 6 8))
             => #f
          
          (some > '(2 3) '(1 4))
             => #f

 - Function: every pred lst1 lst2 ...
     `every' is analogous to `some' except it returns `#t' if every
     application of PRED is `#t' and `#f' otherwise.

     Example:
          (every even? '(1 2 3 4))
             => #f
          
          (every even? '(2 4 6 8))
             => #t
          
          (every > '(2 3) '(1 4))
             => #f

 - Function: notany pred lst1 ...
     `notany' is analogous to `some' but returns `#t' if no application
     of PRED returns `#t' or `#f' as soon as any one does.

 - Function: notevery pred lst1 ...
     `notevery' is analogous to `some' but returns `#t' as soon as an
     application of PRED returns `#f', and `#f' otherwise.

     Example:
          (notevery even? '(1 2 3 4))
             => #t
          
          (notevery even? '(2 4 6 8))
             => #f

 - Function: list-of?? predicate
     Returns a predicate which returns true if its argument is a list
     every element of which satisfies PREDICATE.

 - Function: list-of?? predicate low-bound high-bound
     LOW-BOUND and HIGH-BOUND are non-negative integers.  `list-of??'
     returns a predicate which returns true if its argument is a list
     of length between LOW-BOUND and HIGH-BOUND (inclusive); every
     element of which satisfies PREDICATE.

 - Function: list-of?? predicate bound
     BOUND is an integer.  If BOUND is negative, `list-of??' returns a
     predicate which returns true if its argument is a list of length
     greater than `(- BOUND)'; every element of which satisfies
     PREDICATE.  Otherwise, `list-of??'  returns a predicate which
     returns true if its argument is a list of length less than or
     equal to BOUND; every element of which satisfies PREDICATE.

 - Function: find-if pred lst
     `find-if' searches for the first ELEMENT in LST such that `(PRED
     ELEMENT)' returns `#t'.  If it finds any such ELEMENT in LST,
     ELEMENT is returned.  Otherwise, `#f' is returned.

     Example:
          (find-if number? '(foo 1 bar 2))
             => 1
          
          (find-if number? '(foo bar baz bang))
             => #f
          
          (find-if symbol? '(1 2 foo bar))
             => foo

 - Function: remove elt lst
     `remove' removes all occurrences of ELT from LST using `eqv?' to
     test for equality and returns everything that's left.  N.B.: other
     implementations (Chez, Scheme->C and T, at least) use `equal?' as
     the equality test.

     Example:
          (remove 1 '(1 2 1 3 1 4 1 5))
             => (2 3 4 5)
          
          (remove 'foo '(bar baz bang))
             => (bar baz bang)

 - Function: remove-if pred lst
     `remove-if' removes all ELEMENTs from LST where `(PRED ELEMENT)'
     is `#t' and returns everything that's left.

     Example:
          (remove-if number? '(1 2 3 4))
             => ()
          
          (remove-if even? '(1 2 3 4 5 6 7 8))
             => (1 3 5 7)

 - Function: remove-if-not pred lst
     `remove-if-not' removes all ELEMENTs from LST for which `(PRED
     ELEMENT)' is `#f' and returns everything that's left.

     Example:
          (remove-if-not number? '(foo bar baz))
             => ()
          (remove-if-not odd? '(1 2 3 4 5 6 7 8))
             => (1 3 5 7)

 - Function: has-duplicates? lst
     returns `#t' if 2 members of LST are `equal?', `#f' otherwise.

     Example:
          (has-duplicates? '(1 2 3 4))
             => #f
          
          (has-duplicates? '(2 4 3 4))
             => #t

  The procedure `remove-duplicates' uses `member' (rather than `memv').

 - Function: remove-duplicates lst
     returns a copy of LST with its duplicate members removed.
     Elements are considered duplicate if they are `equal?'.

     Example:
          (remove-duplicates '(1 2 3 4))
             => (1 2 3 4)
          
          (remove-duplicates '(2 4 3 4))
             => (2 4 3)


File: slib.info,  Node: Lists as sequences,  Next: Destructive list operations,  Prev: Lists as sets,  Up: Common List Functions

Lists as sequences
..................

 - Function: position obj lst
     `position' returns the 0-based position of OBJ in LST, or `#f' if
     OBJ does not occur in LST.

     Example:
          (position 'foo '(foo bar baz bang))
             => 0
          (position 'baz '(foo bar baz bang))
             => 2
          (position 'oops '(foo bar baz bang))
             => #f

 - Function: reduce p lst
     `reduce' combines all the elements of a sequence using a binary
     operation (the combination is left-associative).  For example,
     using `+', one can add up all the elements.  `reduce' allows you to
     apply a function which accepts only two arguments to more than 2
     objects.  Functional programmers usually refer to this as "foldl".
     `collect:reduce' (*note Collections::) provides a version of
     `collect' generalized to collections.

     Example:
          (reduce + '(1 2 3 4))
             => 10
          (define (bad-sum . l) (reduce + l))
          (bad-sum 1 2 3 4)
             == (reduce + (1 2 3 4))
             == (+ (+ (+ 1 2) 3) 4)
          => 10
          (bad-sum)
             == (reduce + ())
             => ()
          (reduce string-append '("hello" "cruel" "world"))
             == (string-append (string-append "hello" "cruel") "world")
             => "hellocruelworld"
          (reduce anything '())
             => ()
          (reduce anything '(x))
             => x

     What follows is a rather non-standard implementation of `reverse'
     in terms of `reduce' and a combinator elsewhere called "C".

          ;;; Contributed by Jussi Piitulainen (jpiitula @ ling.helsinki.fi)
          
          (define commute
            (lambda (f)
              (lambda (x y)
                (f y x))))
          
          (define reverse
            (lambda (args)
              (reduce-init (commute cons) '() args)))

 - Function: reduce-init p init lst
     `reduce-init' is the same as reduce, except that it implicitly
     inserts INIT at the start of the list.  `reduce-init' is preferred
     if you want to handle the null list, the one-element, and lists
     with two or more elements consistently.  It is common to use the
     operator's idempotent as the initializer.  Functional programmers
     usually call this "foldl".

     Example:
          (define (sum . l) (reduce-init + 0 l))
          (sum 1 2 3 4)
             == (reduce-init + 0 (1 2 3 4))
             == (+ (+ (+ (+ 0 1) 2) 3) 4)
             => 10
          (sum)
             == (reduce-init + 0 '())
             => 0
          
          (reduce-init string-append "@" '("hello" "cruel" "world"))
          ==
          (string-append (string-append (string-append "@" "hello")
                                         "cruel")
                         "world")
          => "@hellocruelworld"

     Given a differentiation of 2 arguments, `diff', the following will
     differentiate by any number of variables.
          (define (diff* exp . vars)
            (reduce-init diff exp vars))

     Example:
          ;;; Real-world example:  Insertion sort using reduce-init.
          
          (define (insert l item)
            (if (null? l)
                (list item)
                (if (< (car l) item)
                    (cons (car l) (insert (cdr l) item))
                    (cons item l))))
          (define (insertion-sort l) (reduce-init insert '() l))
          
          (insertion-sort '(3 1 4 1 5)
             == (reduce-init insert () (3 1 4 1 5))
             == (insert (insert (insert (insert (insert () 3) 1) 4) 1) 5)
             == (insert (insert (insert (insert (3)) 1) 4) 1) 5)
             == (insert (insert (insert (1 3) 4) 1) 5)
             == (insert (insert (1 3 4) 1) 5)
             == (insert (1 1 3 4) 5)
             => (1 1 3 4 5)

 - Function: last lst n
     `last' returns the last N elements of LST.  N must be a
     non-negative integer.

     Example:
          (last '(foo bar baz bang) 2)
             => (baz bang)
          (last '(1 2 3) 0)
             => 0

 - Function: butlast lst n
     `butlast' returns all but the last N elements of LST.

     Example:
          (butlast '(a b c d) 3)
             => (a)
          (butlast '(a b c d) 4)
             => ()

`last' and `butlast' split a list into two parts when given identical
arugments.
     (last '(a b c d e) 2)
        => (d e)
     (butlast '(a b c d e) 2)
        => (a b c)

 - Function: nthcdr n lst
     `nthcdr' takes N `cdr's of LST and returns the result.  Thus
     `(nthcdr 3 LST)' == `(cdddr LST)'

     Example:
          (nthcdr 2 '(a b c d))
             => (c d)
          (nthcdr 0 '(a b c d))
             => (a b c d)

 - Function: butnthcdr n lst
     `butnthcdr' returns all but the nthcdr N elements of LST.

     Example:
          (butnthcdr 3 '(a b c d))
             => (a b c)
          (butnthcdr 4 '(a b c d))
             => (a b c d)

`nthcdr' and `butnthcdr' split a list into two parts when given
identical arugments.
     (nthcdr 2 '(a b c d e))
        => (c d e)
     (butnthcdr 2 '(a b c d e))
        => (a b)


File: slib.info,  Node: Destructive list operations,  Next: Non-List functions,  Prev: Lists as sequences,  Up: Common List Functions

Destructive list operations
...........................

  These procedures may mutate the list they operate on, but any such
mutation is undefined.

 - Procedure: nconc args
     `nconc' destructively concatenates its arguments.  (Compare this
     with `append', which copies arguments rather than destroying them.)
     Sometimes called `append!' (*note Rev2 Procedures::).

     Example:  You want to find the subsets of a set.  Here's the
     obvious way:

          (define (subsets set)
            (if (null? set)
                '(())
                (append (mapcar (lambda (sub) (cons (car set) sub))
                                (subsets (cdr set)))
                        (subsets (cdr set)))))
     But that does way more consing than you need.  Instead, you could
     replace the `append' with `nconc', since you don't have any need
     for all the intermediate results.

     Example:
          (define x '(a b c))
          (define y '(d e f))
          (nconc x y)
             => (a b c d e f)
          x
             => (a b c d e f)

     `nconc' is the same as `append!' in `sc2.scm'.

 - Procedure: nreverse lst
     `nreverse' reverses the order of elements in LST by mutating
     `cdr's of the list.  Sometimes called `reverse!'.

     Example:
          (define foo '(a b c))
          (nreverse foo)
             => (c b a)
          foo
             => (a)

     Some people have been confused about how to use `nreverse',
     thinking that it doesn't return a value.  It needs to be pointed
     out that
          (set! lst (nreverse lst))

     is the proper usage, not
          (nreverse lst)
     The example should suffice to show why this is the case.

 - Procedure: delete elt lst
 - Procedure: delete-if pred lst
 - Procedure: delete-if-not pred lst
     Destructive versions of `remove' `remove-if', and `remove-if-not'.

     Example:
          (define lst (list 'foo 'bar 'baz 'bang))
          (delete 'foo lst)
             => (bar baz bang)
          lst
             => (foo bar baz bang)
          
          (define lst (list 1 2 3 4 5 6 7 8 9))
          (delete-if odd? lst)
             => (2 4 6 8)
          lst
             => (1 2 4 6 8)

     Some people have been confused about how to use `delete',
     `delete-if', and `delete-if', thinking that they don't return a
     value.  It needs to be pointed out that
          (set! lst (delete el lst))

     is the proper usage, not
          (delete el lst)
     The examples should suffice to show why this is the case.


File: slib.info,  Node: Non-List functions,  Prev: Destructive list operations,  Up: Common List Functions

Non-List functions
..................

 - Function: and? arg1 ...
     `and?' checks to see if all its arguments are true.  If they are,
     `and?' returns `#t', otherwise, `#f'.  (In contrast to `and', this
     is a function, so all arguments are always evaluated and in an
     unspecified order.)

     Example:
          (and? 1 2 3)
             => #t
          (and #f 1 2)
             => #f

 - Function: or? arg1 ...
     `or?' checks to see if any of its arguments are true.  If any is
     true, `or?' returns `#t', and `#f' otherwise.  (To `or' as `and?'
     is to `and'.)

     Example:
          (or? 1 2 #f)
             => #t
          (or? #f #f #f)
             => #f

 - Function: atom? object
     Returns `#t' if OBJECT is not a pair and `#f' if it is pair.
     (Called `atom' in Common LISP.)
          (atom? 1)
             => #t
          (atom? '(1 2))
             => #f
          (atom? #(1 2))   ; dubious!
             => #t


File: slib.info,  Node: Tree Operations,  Next: Chapter Ordering,  Prev: Common List Functions,  Up: Sorting and Searching

Tree operations
---------------

  `(require 'tree)'

  These are operations that treat lists a representations of trees.

 - Function: subst new old tree
 - Function: subst new old tree equ?
 - Function: substq new old tree
 - Function: substv new old tree
     `subst' makes a copy of TREE, substituting NEW for every subtree
     or leaf of TREE which is `equal?' to OLD and returns a modified
     tree.  The original TREE is unchanged, but may share parts with
     the result.

     `substq' and `substv' are similar, but test against OLD using
     `eq?' and `eqv?' respectively.  If `subst' is called with a fourth
     argument, EQU? is the equality predicate.

     Examples:
          (substq 'tempest 'hurricane '(shakespeare wrote (the hurricane)))
             => (shakespeare wrote (the tempest))
          (substq 'foo '() '(shakespeare wrote (twelfth night)))
             => (shakespeare wrote (twelfth night . foo) . foo)
          (subst '(a . cons) '(old . pair)
                 '((old . spice) ((old . shoes) old . pair) (old . pair)))
             => ((old . spice) ((old . shoes) a . cons) (a . cons))

 - Function: copy-tree tree
     Makes a copy of the nested list structure TREE using new pairs and
     returns it.  All levels are copied, so that none of the pairs in
     the tree are `eq?' to the original ones - only the leaves are.

     Example:
          (define bar '(bar))
          (copy-tree (list bar 'foo))
             => ((bar) foo)
          (eq? bar (car (copy-tree (list bar 'foo))))
             => #f


File: slib.info,  Node: Chapter Ordering,  Next: Sorting,  Prev: Tree Operations,  Up: Sorting and Searching

Chapter Ordering
----------------

  `(require 'chapter-order)'

  The `chap:' functions deal with strings which are ordered like
chapter numbers (or letters) in a book.  Each section of the string
consists of consecutive numeric or consecutive aphabetic characters of
like case.

 - Function: chap:string<? string1 string2
     Returns #t if the first non-matching run of alphabetic upper-case
     or the first non-matching run of alphabetic lower-case or the first
     non-matching run of numeric characters of STRING1 is `string<?'
     than the corresponding non-matching run of characters of STRING2.

          (chap:string<? "a.9" "a.10")                    => #t
          (chap:string<? "4c" "4aa")                      => #t
          (chap:string<? "Revised^{3.99}" "Revised^{4}")  => #t

 - Function: chap:string>? string1 string2
 - Function: chap:string<=? string1 string2
 - Function: chap:string>=? string1 string2
     Implement the corresponding chapter-order predicates.

 - Function: chap:next-string string
     Returns the next string in the _chapter order_.  If STRING has no
     alphabetic or numeric characters, `(string-append STRING "0")' is
     returnd.  The argument to chap:next-string will always be
     `chap:string<?' than the result.

          (chap:next-string "a.9")                => "a.10"
          (chap:next-string "4c")                 => "4d"
          (chap:next-string "4z")                 => "4aa"
          (chap:next-string "Revised^{4}")        => "Revised^{5}"


File: slib.info,  Node: Sorting,  Next: Topological Sort,  Prev: Chapter Ordering,  Up: Sorting and Searching

Sorting
-------

  `(require 'sort)'

  Many Scheme systems provide some kind of sorting functions.  They do
not, however, always provide the _same_ sorting functions, and those
that I have had the opportunity to test provided inefficient ones (a
common blunder is to use quicksort which does not perform well).

  Because `sort' and `sort!' are not in the standard, there is very
little agreement about what these functions look like.  For example,
Dybvig says that Chez Scheme provides
     (merge predicate list1 list2)
     (merge! predicate list1 list2)
     (sort predicate list)
     (sort! predicate list)

while MIT Scheme 7.1, following Common LISP, offers unstable
     (sort list predicate)

TI PC Scheme offers
     (sort! list/vector predicate?)

and Elk offers
     (sort list/vector predicate?)
     (sort! list/vector predicate?)

  Here is a comprehensive catalogue of the variations I have found.

  1. Both `sort' and `sort!' may be provided.

  2. `sort' may be provided without `sort!'.

  3. `sort!' may be provided without `sort'.

  4. Neither may be provided.

  5. The sequence argument may be either a list or a vector.

  6. The sequence argument may only be a list.

  7. The sequence argument may only be a vector.

  8. The comparison function may be expected to behave like `<'.

  9. The comparison function may be expected to behave like `<='.

 10. The interface may be `(sort predicate? sequence)'.

 11. The interface may be `(sort sequence predicate?)'.

 12. The interface may be `(sort sequence &optional (predicate? <))'.

 13. The sort may be stable.

 14. The sort may be unstable.

  All of this variation really does not help anybody.  A nice simple
merge sort is both stable and fast (quite a lot faster than _quick_
sort).

  I am providing this source code with no restrictions at all on its use
(but please retain D.H.D.Warren's credit for the original idea).  You
may have to rename some of these functions in order to use them in a
system which already provides incompatible or inferior sorts.  For each
of the functions, only the top-level define needs to be edited to do
that.

  I could have given these functions names which would not clash with
any Scheme that I know of, but I would like to encourage implementors to
converge on a single interface, and this may serve as a hint.  The
argument order for all functions has been chosen to be as close to
Common LISP as made sense, in order to avoid NIH-itis.

  Each of the five functions has a required _last_ parameter which is a
comparison function.  A comparison function `f' is a function of 2
arguments which acts like `<'.  For example,

     (not (f x x))
     (and (f x y) (f y z)) == (f x z)

  The standard functions `<', `>', `char<?', `char>?', `char-ci<?',
`char-ci>?', `string<?', `string>?', `string-ci<?', and `string-ci>?'
are suitable for use as comparison functions.  Think of `(less? x y)'
as saying when `x' must _not_ precede `y'.

 - Function: sorted? sequence less?
     Returns `#t' when the sequence argument is in non-decreasing order
     according to LESS? (that is, there is no adjacent pair `... x y
     ...' for which `(less? y x)').

     Returns `#f' when the sequence contains at least one out-of-order
     pair.  It is an error if the sequence is neither a list nor a
     vector.

 - Function: merge list1 list2 less?
     This merges two lists, producing a completely new list as result.
     I gave serious consideration to producing a Common-LISP-compatible
     version.  However, Common LISP's `sort' is our `sort!' (well, in
     fact Common LISP's `stable-sort' is our `sort!', merge sort is
     _fast_ as well as stable!) so adapting CL code to Scheme takes a
     bit of work anyway.  I did, however, appeal to CL to determine the
     _order_ of the arguments.

 - Procedure: merge! list1 list2 less?
     Merges two lists, re-using the pairs of LIST1 and LIST2 to build
     the result.  If the code is compiled, and LESS? constructs no new
     pairs, no pairs at all will be allocated.  The first pair of the
     result will be either the first pair of LIST1 or the first pair of
     LIST2, but you can't predict which.

     The code of `merge' and `merge!' could have been quite a bit
     simpler, but they have been coded to reduce the amount of work
     done per iteration.  (For example, we only have one `null?' test
     per iteration.)

 - Function: sort sequence less?
     Accepts either a list or a vector, and returns a new sequence
     which is sorted.  The new sequence is the same type as the input.
     Always `(sorted? (sort sequence less?) less?)'.  The original
     sequence is not altered in any way.  The new sequence shares its
     _elements_ with the old one; no elements are copied.

 - Procedure: sort! sequence less?
     Returns its sorted result in the original boxes.  If the original
     sequence is a list, no new storage is allocated at all.  If the
     original sequence is a vector, the sorted elements are put back in
     the same vector.

     Some people have been confused about how to use `sort!', thinking
     that it doesn't return a value.  It needs to be pointed out that
          (set! slist (sort! slist <))

     is the proper usage, not
          (sort! slist <)

  Note that these functions do _not_ accept a CL-style `:key' argument.
A simple device for obtaining the same expressiveness is to define
     (define (keyed less? key)
       (lambda (x y) (less? (key x) (key y))))

and then, when you would have written
     (sort a-sequence #'my-less :key #'my-key)

in Common LISP, just write
     (sort! a-sequence (keyed my-less? my-key))

in Scheme.


File: slib.info,  Node: Topological Sort,  Next: Hashing,  Prev: Sorting,  Up: Sorting and Searching
                                                                              |
Topological Sort
----------------

  `(require 'topological-sort)' or `(require 'tsort)'

The algorithm is inspired by Cormen, Leiserson and Rivest (1990)
`Introduction to Algorithms', chapter 23.

 - Function: tsort dag pred
 - Function: topological-sort dag pred
     where
    DAG
          is a list of sublists.  The car of each sublist is a vertex.
          The cdr is the adjacency list of that vertex, i.e. a list of
          all vertices to which there exists an edge from the car
          vertex.

    PRED
          is one of `eq?', `eqv?', `equal?', `=', `char=?',
          `char-ci=?', `string=?', or `string-ci=?'.

     Sort the directed acyclic graph DAG so that for every edge from
     vertex U to V, U will come before V in the resulting list of
     vertices.

     Time complexity: O (|V| + |E|)

     Example (from Cormen):
          Prof. Bumstead topologically sorts his clothing when getting
          dressed.  The first argument to `tsort' describes which
          garments he needs to put on before others.  (For example,
          Prof Bumstead needs to put on his shirt before he puts on his
          tie or his belt.)  `tsort' gives the correct order of
          dressing:

          (require 'tsort)
          (tsort '((shirt tie belt)
                   (tie jacket)
                   (belt jacket)
                   (watch)
                   (pants shoes belt)
                   (undershorts pants shoes)
                   (socks shoes))
                 eq?)
          =>
          (socks undershorts pants shoes watch shirt belt tie jacket)


File: slib.info,  Node: Hashing,  Next: Space-Filling Curves,  Prev: Topological Sort,  Up: Sorting and Searching
                                                                              |
Hashing                                                                       |
-------                                                                       |
                                                                              |
  `(require 'hash)'                                                           |
                                                                              |
  These hashing functions are for use in quickly classifying objects.         |
Hash tables use these functions.                                              |
                                                                              |
 - Function: hashq obj k                                                      |
 - Function: hashv obj k                                                      |
 - Function: hash obj k                                                       |
     Returns an exact non-negative integer less than K.  For each             |
     non-negative integer less than K there are arguments OBJ for which       |
     the hashing functions applied to OBJ and K returns that integer.         |
                                                                              |
     For `hashq', `(eq? obj1 obj2)' implies `(= (hashq obj1 k) (hashq         |
     obj2))'.                                                                 |
                                                                              |
     For `hashv', `(eqv? obj1 obj2)' implies `(= (hashv obj1 k) (hashv        |
     obj2))'.                                                                 |
                                                                              |
     For `hash', `(equal? obj1 obj2)' implies `(= (hash obj1 k) (hash         |
     obj2))'.                                                                 |
                                                                              |
     `hash', `hashv', and `hashq' return in time bounded by a constant.       |
     Notice that items having the same `hash' implies the items have          |
     the same `hashv' implies the items have the same `hashq'.                |
                                                                              |

File: slib.info,  Node: Space-Filling Curves,  Next: Soundex,  Prev: Hashing,  Up: Sorting and Searching
                                                                              |
Space-Filling Curves                                                          |
--------------------                                                          |
                                                                              |
  `(require 'sierpinski)'                                                     |
                                                                              |
 - Function: make-sierpinski-indexer max-coordinate                           |
     Returns a procedure (eg hash-function) of 2 numeric arguments which      |
     preserves _nearness_ in its mapping from NxN to N.                       |
                                                                              |
     MAX-COORDINATE is the maximum coordinate (a positive integer) of a       |
     population of points.  The returned procedures is a function that        |
     takes the x and y coordinates of a point, (non-negative integers)        |
     and returns an integer corresponding to the relative position of         |
     that point along a Sierpinski curve.  (You can think of this as          |
     computing a (pseudo-) inverse of the Sierpinski spacefilling             |
     curve.)                                                                  |
                                                                              |
     Example use: Make an indexer (hash-function) for integer points          |
     lying in square of integer grid points [0,99]x[0,99]:                    |
          (define space-key (make-sierpinski-indexer 100))                    |
     Now let's compute the index of some points:                              |
          (space-key 24 78)               => 9206                             |
          (space-key 23 80)               => 9172                             |
                                                                              |
     Note that locations (24, 78) and (23, 80) are near in index and          |
     therefore, because the Sierpinski spacefilling curve is                  |
     continuous, we know they must also be near in the plane.  Nearness       |
     in the plane does not, however, necessarily correspond to nearness       |
     in index, although it _tends_ to be so.                                  |
                                                                              |
     Example applications:                                                    |
        * Sort points by Sierpinski index to get heuristic solution to        |
          _travelling salesman problem_.  For details of performance,         |
          see L. Platzman and J. Bartholdi, "Spacefilling curves and the      |
          Euclidean travelling salesman problem", JACM 36(4):719-737          |
          (October 1989) and references therein.                              |
                                                                              |
        * Use Sierpinski index as key by which to store 2-dimensional         |
          data in a 1-dimensional data structure (such as a table).           |
          Then locations that are near each other in 2-d space will           |
          tend to be near each other in 1-d data structure; and               |
          locations that are near in 1-d data structure will be near in       |
          2-d space.  This can significantly speed retrieval from             |
          secondary storage because contiguous regions in the plane           |
          will tend to correspond to contiguous regions in secondary          |
          storage.  (This is a standard technique for managing CAD/CAM        |
          or geographic data.)                                                |
                                                                              |
                                                                              |

File: slib.info,  Node: Soundex,  Next: String Search,  Prev: Space-Filling Curves,  Up: Sorting and Searching
                                                                              |
Soundex                                                                       |
-------                                                                       |
                                                                              |
  `(require 'soundex)'                                                        |
                                                                              |
 - Function: soundex name                                                     |
     Computes the _soundex_ hash of NAME.  Returns a string of an             |
     initial letter and up to three digits between 0 and 6.  Soundex          |
     supposedly has the property that names that sound similar in normal      |
     English pronunciation tend to map to the same key.                       |
                                                                              |
     Soundex was a classic algorithm used for manual filing of personal       |
     records before the advent of computers.  It performs adequately for      |
     English names but has trouble with other languages.                      |
                                                                              |
     See Knuth, Vol. 3 `Sorting and searching', pp 391-2                      |
                                                                              |
     To manage unusual inputs, `soundex' omits all non-alphabetic             |
     characters.  Consequently, in this implementation:                       |
                                                                              |
          (soundex <string of blanks>)    => ""                               |
          (soundex "")                    => ""                               |
                                                                              |
     Examples from Knuth:                                                     |
                                                                              |
          (map soundex '("Euler" "Gauss" "Hilbert" "Knuth"                    |
                                 "Lloyd" "Lukasiewicz"))                      |
                  => ("E460" "G200" "H416" "K530" "L300" "L222")              |
                                                                              |
          (map soundex '("Ellery" "Ghosh" "Heilbronn" "Kant"                  |
                                  "Ladd" "Lissajous"))                        |
                  => ("E460" "G200" "H416" "K530" "L300" "L222")              |
                                                                              |
     Some cases in which the algorithm fails (Knuth):                         |
                                                                              |
          (map soundex '("Rogers" "Rodgers"))     => ("R262" "R326")          |
                                                                              |
          (map soundex '("Sinclair" "St. Clair")) => ("S524" "S324")          |
                                                                              |
          (map soundex '("Tchebysheff" "Chebyshev")) => ("T212" "C121")       |
                                                                              |

File: slib.info,  Node: String Search,  Next: Sequence Comparison,  Prev: Soundex,  Up: Sorting and Searching
                                                                              |
String Search
-------------

  `(require 'string-search)'

 - Procedure: string-index string char
 - Procedure: string-index-ci string char
     Returns the index of the first occurence of CHAR within STRING, or
     `#f' if the STRING does not contain a character CHAR.

 - Procedure: string-reverse-index string char
 - Procedure: string-reverse-index-ci string char
     Returns the index of the last occurence of CHAR within STRING, or
     `#f' if the STRING does not contain a character CHAR.

 - procedure: substring? pattern string
 - procedure: substring-ci? pattern string
     Searches STRING to see if some substring of STRING is equal to
     PATTERN.  `substring?' returns the index of the first character of
     the first substring of STRING that is equal to PATTERN; or `#f' if
     STRING does not contain PATTERN.

          (substring? "rat" "pirate") =>  2
          (substring? "rat" "outrage") =>  #f
          (substring? "" any-string) =>  0

 - Procedure: find-string-from-port? str in-port max-no-chars
     Looks for a string STR within the first MAX-NO-CHARS chars of the
     input port IN-PORT.

 - Procedure: find-string-from-port? str in-port
     When called with two arguments, the search span is limited by the
     end of the input stream.

 - Procedure: find-string-from-port? str in-port char
     Searches up to the first occurrence of character CHAR in STR.

 - Procedure: find-string-from-port? str in-port proc
     Searches up to the first occurrence of the procedure PROC
     returning non-false when called with a character (from IN-PORT)
     argument.

     When the STR is found, `find-string-from-port?' returns the number
     of characters it has read from the port, and the port is set to
     read the first char after that (that is, after the STR) The
     function returns `#f' when the STR isn't found.

     `find-string-from-port?' reads the port _strictly_ sequentially,
     and does not perform any buffering.  So `find-string-from-port?'
     can be used even if the IN-PORT is open to a pipe or other
     communication channel.

 - Function: string-subst txt old1 new1 ...
     Returns a copy of string TXT with all occurrences of string OLD1
     in TXT replaced with NEW1, OLD2 replaced with NEW2 ....


File: slib.info,  Node: Sequence Comparison,  Prev: String Search,  Up: Sorting and Searching

Sequence Comparison
-------------------

  `(require 'diff)'

`diff:edit-length' implements the algorithm:                                  |

     S. Wu, E. Myers, U. Manber, and W. Miller,
        "An O(NP) Sequence Comparison Algorithm,"
        Information Processing Letters 35, 6 (1990), 317-323.
        <http://www.cs.arizona.edu/people/gene/vita.html>

The values returned by `diff:edit-length' can be used to gauge the            |
degree of match between two sequences.                                        |
                                                                              |
Surprisingly, "An O(NP) Sequence Comparison Algorithm" does not derive        |
the edit sequence; only the sequence length.  Developing an algorithm         |
for computing the edit sequence preserving the "O(NP)" time bound in          |
O(N) space required a month of evenings and weekends.  Read the details       |
in:                                                                           |
                                                                              |
     A. Jaffer,                                                               |
        "An O(NP), Linear Space Algorithm for Computing Shortest Edit         |
        Sequences",                                                           |
        Go Figure! 2002.                                                      |
        <http://swissnet.ai.mit.edu/~jaffer/ONPACSES.html>                    |
                                                                              |
If the items being sequenced are text lines, then the computed
edit-list is equivalent to the output of the "diff" utility program.
If the items being sequenced are words, then it is like the lesser
known "spiff" program.

 - Function: diff:longest-common-subsequence array1 array2 =? p-lim           |
 - Function: diff:longest-common-subsequence array1 array2 =?                 |
     ARRAY1 and ARRAY2 are one-dimensional arrays.  The procedure =? is
     used to compare sequence tokens for equality.                            |
                                                                              |
     The non-negative integer P-LIM, if provided, is maximum number of        |
     deletions of the shorter sequence to allow.                              |
     `diff:longest-common-subsequence' will return `#f' if more               |
     deletions would be necessary.                                            |
                                                                              |
     `diff:longest-common-subsequence' returns a one-dimensional array        |
     of length `(quotient (- (+ len1 len2) (diff:edit-length ARRAY1           |
     ARRAY2)) 2)' holding the longest sequence common to both ARRAYs.         |

 - Function: diff:edits array1 array2 =? p-lim                                |
 - Function: diff:edits array1 array2 =?                                      |
     ARRAY1 and ARRAY2 are one-dimensional arrays.  The procedure =? is
     used to compare sequence tokens for equality.                            |

     The non-negative integer P-LIM, if provided, is maximum number of        |
     deletions of the shorter sequence to allow.  `diff:edits' will           |
     return `#f' if more deletions would be necessary.                        |

     `diff:edits' returns a vector of length `(diff:edit-length ARRAY1        |
     ARRAY2)' composed of a shortest sequence of edits transformaing          |
     ARRAY1 to ARRAY2.                                                        |
                                                                              |
     Each edit is an integer:                                                 |
    K > 0                                                                     |
          Inserts `(array-ref ARRAY1 (+ -1 J))' into the sequence.            |
                                                                              |
    K < 0                                                                     |
          Deletes `(array-ref ARRAY2 (- -1 K))' from the sequence.            |

 - Function: diff:edit-length array1 array2 =? p-lim                          |
 - Function: diff:edit-length array1 array2 =?                                |
     ARRAY1 and ARRAY2 are one-dimensional arrays.  The procedure =? is
     used to compare sequence tokens for equality.                            |

     The non-negative integer P-LIM, if provided, is maximum number of        |
     deletions of the shorter sequence to allow.  `diff:edit-length'          |
     will return `#f' if more deletions would be necessary.                   |

     `diff:edit-length' returns the length of the shortest sequence of        |
     edits transformaing ARRAY1 to ARRAY2.                                    |
                                                                              |
     (diff:longest-common-subsequence "fghiejcklm" "fgehijkpqrlm" eqv?)       |
     => "fghijklm"                                                            |
                                                                              |
     (diff:edit-length "fghiejcklm" "fgehijkpqrlm" eqv?)                      |
     => 6
     
     (diff:edits "fghiejcklm" "fgehijkpqrlm" eqv?)                            |
     => #As32(3 -5 -7 8 9 10)                                                 |
            ; e  c  h p q  r                                                  |


File: slib.info,  Node: Procedures,  Next: Standards Support,  Prev: Sorting and Searching,  Up: Other Packages

Procedures
==========

  Anything that doesn't fall neatly into any of the other categories
winds up here.

* Menu:

* Type Coercion::               'coerce
* String-Case::                 'string-case
* String Ports::                'string-port
* Line I/O::                    'line-i/o
* Multi-Processing::            'process
* Metric Units::                Portable manifest types for numeric values.


File: slib.info,  Node: Type Coercion,  Next: String-Case,  Prev: Procedures,  Up: Procedures

Type Coercion
-------------

  `(require 'coerce)'

 - Function: type-of obj
     Returns a symbol name for the type of OBJ.

 - Function: coerce obj result-type
     Converts and returns OBJ of type `char', `number', `string',
     `symbol', `list', or `vector' to RESULT-TYPE (which must be one of
     these symbols).


File: slib.info,  Node: String-Case,  Next: String Ports,  Prev: Type Coercion,  Up: Procedures

String-Case
-----------

  `(require 'string-case)'

 - Procedure: string-upcase str
 - Procedure: string-downcase str
 - Procedure: string-capitalize str
     The obvious string conversion routines.  These are non-destructive.

 - Function: string-upcase! str
 - Function: string-downcase! str
 - Function: string-captialize! str
     The destructive versions of the functions above.

 - Function: string-ci->symbol str
     Converts string STR to a symbol having the same case as if the
     symbol had been `read'.

 - Function: symbol-append obj1 ...
     Converts OBJ1 ... to strings, appends them, and converts to a
     symbol which is returned.  Strings and numbers are converted to
     read's symbol case; the case of symbol characters is not changed.
     #f is converted to the empty string (symbol).

 - Function: StudlyCapsExpand str delimiter
 - Function: StudlyCapsExpand str
     DELIMITER must be a string or character.  If absent, DELIMITER
     defaults to `-'.  `StudlyCapsExpand' returns a copy of STR where
     DELIMITER is inserted between each lower-case character
     immediately followed by an upper-case character; and between two
     upper-case characters immediately followed by a lower-case
     character.

          (StudlyCapsExpand "aX" " ")   => "a X"
          (StudlyCapsExpand "aX" "..")  => "a..X"
          (StudlyCapsExpand "AX")       => "AX"
          (StudlyCapsExpand "Ax")       => "Ax"
          (StudlyCapsExpand "AXLE")     => "AXLE"
          (StudlyCapsExpand "aAXACz")   => "a-AXA-Cz"
          (StudlyCapsExpand "AaXACz")   => "Aa-XA-Cz"
          (StudlyCapsExpand "AAaXACz")  => "A-Aa-XA-Cz"
          (StudlyCapsExpand "AAaXAC")   => "A-Aa-XAC"



File: slib.info,  Node: String Ports,  Next: Line I/O,  Prev: String-Case,  Up: Procedures

String Ports
------------

  `(require 'string-port)'

 - Procedure: call-with-output-string proc
     PROC must be a procedure of one argument.  This procedure calls
     PROC with one argument: a (newly created) output port.  When the
     function returns, the string composed of the characters written
     into the port is returned.

 - Procedure: call-with-input-string string proc
     PROC must be a procedure of one argument.  This procedure calls
     PROC with one argument: an (newly created) input port from which
     STRING's contents may be read.  When PROC returns, the port is
     closed and the value yielded by the procedure PROC is returned.


File: slib.info,  Node: Line I/O,  Next: Multi-Processing,  Prev: String Ports,  Up: Procedures

Line I/O
--------

  `(require 'line-i/o)'

 - Function: read-line
 - Function: read-line port
     Returns a string of the characters up to, but not including a
     newline or end of file, updating PORT to point to the character
     following the newline.  If no characters are available, an end of
     file object is returned.  The PORT argument may be omitted, in
     which case it defaults to the value returned by
     `current-input-port'.

 - Function: read-line! string
 - Function: read-line! string port
     Fills STRING with characters up to, but not including a newline or
     end of file, updating the PORT to point to the last character read
     or following the newline if it was read.  If no characters are
     available, an end of file object is returned.  If a newline or end
     of file was found, the number of characters read is returned.
     Otherwise, `#f' is returned.  The PORT argument may be omitted, in
     which case it defaults to the value returned by
     `current-input-port'.

 - Function: write-line string
 - Function: write-line string port
     Writes STRING followed by a newline to the given PORT and returns
     an unspecified value.  The PORT argument may be omitted, in which
     case it defaults to the value returned by `current-input-port'.

 - Function: display-file path
 - Function: display-file path port
     Displays the contents of the file named by PATH to PORT.  The PORT
     argument may be ommited, in which case it defaults to the value
     returned by `current-output-port'.


File: slib.info,  Node: Multi-Processing,  Next: Metric Units,  Prev: Line I/O,  Up: Procedures

Multi-Processing
----------------

  `(require 'process)'

  This module implements asynchronous (non-polled) time-sliced
multi-processing in the SCM Scheme implementation using procedures
`alarm' and `alarm-interrupt'.  Until this is ported to another
implementation, consider it an example of writing schedulers in Scheme.

 - Procedure: add-process! proc
     Adds proc, which must be a procedure (or continuation) capable of
     accepting accepting one argument, to the `process:queue'.  The
     value returned is unspecified.  The argument to PROC should be
     ignored.  If PROC returns, the process is killed.

 - Procedure: process:schedule!
     Saves the current process on `process:queue' and runs the next
     process from `process:queue'.  The value returned is unspecified.

 - Procedure: kill-process!
     Kills the current process and runs the next process from
     `process:queue'.  If there are no more processes on
     `process:queue', `(slib:exit)' is called (*note System::).


File: slib.info,  Node: Metric Units,  Prev: Multi-Processing,  Up: Procedures

Metric Units
------------

  `(require 'metric-units)'

  <http://swissnet.ai.mit.edu/~jaffer/MIXF.html>

  "Metric Interchange Format" is a character string encoding for
numerical values and units which:

   * is unambiguous in all locales;

   * uses only [TOG] "Portable Character Set" characters matching "Basic
     Latin" characters in Plane 0 of the Universal Character Set [UCS];

   * is transparent to [UTF-7] and [UTF-8] UCS transformation formats;

   * is human readable and writable;

   * is machine readable and writable;

   * incorporates SI prefixes and units;

   * incorporates [ISO 6093] numbers; and

   * incorporates [IEC 60027-2] binary prefixes.

  In the expression for the value of a quantity, the unit symbol is
placed after the numerical value.  A dot (PERIOD, `.') is placed between
the numerical value and the unit symbol.

  Within a compound unit, each of the base and derived symbols can
optionally have an attached SI prefix.

  Unit symbols formed from other unit symbols by multiplication are
indicated by means of a dot (PERIOD, `.') placed between them.

  Unit symbols formed from other unit symbols by division are indicated
by means of a SOLIDUS (`/') or negative exponents.  The SOLIDUS must
not be repeated in the same compound unit unless contained within a
parenthesized subexpression.

  The grouping formed by a prefix symbol attached to a unit symbol
constitutes a new inseparable symbol (forming a multiple or submultiple
of the unit concerned) which can be raised to a positive or negative
power and which can be combined with other unit symbols to form compound
unit symbols.

  The grouping formed by surrounding compound unit symbols with
parentheses (`(' and `)') constitutes a new inseparable symbol which
can be raised to a positive or negative power and which can be combined
with other unit symbols to form compound unit symbols.

  Compound prefix symbols, that is, prefix symbols formed by the
juxtaposition of two or more prefix symbols, are not permitted.

  Prefix symbols are not used with the time-related unit symbols min
(minute), h (hour), d (day).  No prefix symbol may be used with dB
(decibel).  Only submultiple prefix symbols may be used with the unit
symbols L (liter), Np (neper), o (degree), oC (degree Celsius), rad
(radian), and sr (steradian).  Submultiple prefix symbols may not be
used with the unit symbols t (metric ton), r (revolution), or Bd (baud).

  A unit exponent follows the unit, separated by a CIRCUMFLEX (`^').
Exponents may be positive or negative.  Fractional exponents must be
parenthesized.

SI Prefixes
...........

            Factor     Name    Symbol  |  Factor     Name    Symbol
            ======     ====    ======  |  ======     ====    ======
             1e24      yotta      Y    |   1e-1      deci       d
             1e21      zetta      Z    |   1e-2      centi      c
             1e18      exa        E    |   1e-3      milli      m
             1e15      peta       P    |   1e-6      micro      u
             1e12      tera       T    |   1e-9      nano       n
             1e9       giga       G    |   1e-12     pico       p
             1e6       mega       M    |   1e-15     femto      f
             1e3       kilo       k    |   1e-18     atto       a
             1e2       hecto      h    |   1e-21     zepto      z
             1e1       deka       da   |   1e-24     yocto      y

Binary Prefixes
...............

  These binary prefixes are valid only with the units B (byte) and bit.
However, decimal prefixes can also be used with bit; and decimal
multiple (not submultiple) prefixes can also be used with B (byte).

                     Factor       (power-of-2)  Name  Symbol
                     ======       ============  ====  ======
            1.152921504606846976e18  (2^60)     exbi    Ei
               1.125899906842624e15  (2^50)     pebi    Pi
                  1.099511627776e12  (2^40)     tebi    Ti
                     1.073741824e9   (2^30)     gibi    Gi
                        1.048576e6   (2^20)     mebi    Mi
                           1.024e3   (2^10)     kibi    Ki

Unit Symbols
............

         Type of Quantity      Name          Symbol   Equivalent
         ================      ====          ======   ==========
     time                      second           s
     time                      minute           min = 60.s
     time                      hour             h   = 60.min
     time                      day              d   = 24.h
     frequency                 hertz            Hz    s^-1
     signaling rate            baud             Bd    s^-1
     length                    meter            m
     volume                    liter            L     dm^3
     plane angle               radian           rad
     solid angle               steradian        sr    rad^2
     plane angle               revolution     * r   = 6.283185307179586.rad
     plane angle               degree         * o   = 2.777777777777778e-3.r
     information capacity      bit              bit
     information capacity      byte, octet      B   = 8.bit
     mass                      gram             g
     mass                      ton              t     Mg
     mass              unified atomic mass unit u   = 1.66053873e-27.kg
     amount of substance       mole             mol
     catalytic activity        katal            kat   mol/s
     thermodynamic temperature kelvin           K
     centigrade temperature    degree Celsius   oC
     luminous intensity        candela          cd
     luminous flux             lumen            lm    cd.sr
     illuminance               lux              lx    lm/m^2
     force                     newton           N     m.kg.s^-2
     pressure, stress          pascal           Pa    N/m^2
     energy, work, heat        joule            J     N.m
     energy                    electronvolt     eV  = 1.602176462e-19.J
     power, radiant flux       watt             W     J/s
     logarithm of power ratio  neper            Np
     logarithm of power ratio  decibel        * dB  = 0.1151293.Np
     electric current          ampere           A
     electric charge           coulomb          C     s.A
     electric potential, EMF   volt             V     W/A
     capacitance               farad            F     C/V
     electric resistance       ohm              Ohm   V/A
     electric conductance      siemens          S     A/V
     magnetic flux             weber            Wb    V.s
     magnetic flux density     tesla            T     Wb/m^2
     inductance                henry            H     Wb/A
     radionuclide activity     becquerel        Bq    s^-1
     absorbed dose energy      gray             Gy    m^2.s^-2
     dose equivalent           sievert          Sv    m^2.s^-2

  * The formulas are:

   * r/rad = 8 * atan(1)

   * o/r = 1 / 360

   * db/Np = ln(10) / 20

 - Function: si:conversion-factor to-unit from-unit
     If the strings FROM-UNIT and TO-UNIT express valid unit
     expressions for quantities of the same unit-dimensions, then the
     value returned by `si:conversion-factor' will be such that
     multiplying a numerical value expressed in FROM-UNITs by the
     returned conversion factor yields the numerical value expressed in
     TO-UNITs.

     Otherwise, `si:conversion-factor' returns:

    -3
          if neither FROM-UNIT nor TO-UNIT is a syntactically valid
          unit.

    -2
          if FROM-UNIT is not a syntactically valid unit.

    -1
          if TO-UNIT is not a syntactically valid unit.

    0
          if linear conversion (by a factor) is not possible.


     (si:conversion-factor "km/s" "m/s" ) => 0.001
     (si:conversion-factor "N"    "m/s" ) => 0
     (si:conversion-factor "moC"  "oC"  ) => 1000
     (si:conversion-factor "mK"   "oC"  ) => 0
     (si:conversion-factor "rad"  "o"   ) => 0.0174533
     (si:conversion-factor "K"    "o"   ) => 0
     (si:conversion-factor "K"    "K"   ) => 1
     (si:conversion-factor "oK"   "oK"  ) => -3
     (si:conversion-factor ""     "s/s" ) => 1
     (si:conversion-factor "km/h" "mph" ) => -2


File: slib.info,  Node: Standards Support,  Next: Session Support,  Prev: Procedures,  Up: Other Packages

Standards Support
=================

* Menu:

* RnRS::                        Revised Reports on Scheme
* With-File::                   'with-file
* Transcripts::                 'transcript
* Rev2 Procedures::             'rev2-procedures
* Rev4 Optional Procedures::    'rev4-optional-procedures
* Multi-argument / and -::      'multiarg/and-
* Multi-argument Apply::        'multiarg-apply
* Rationalize::                 'rationalize
* Promises::                    'promise
* Dynamic-Wind::                'dynamic-wind
* Eval::                        'eval
* Values::                      'values
* SRFI::                        'http://srfi.schemers.org/srfi-0/srfi-0.html


File: slib.info,  Node: RnRS,  Next: With-File,  Prev: Standards Support,  Up: Standards Support

RnRS
----

The `r2rs', `r3rs', `r4rs', and `r5rs' features attempt to provide
procedures and macros to bring a Scheme implementation to the desired
version of Scheme.

 - Feature: r2rs
     Requires features implementing procedures and optional procedures
     specified by `Revised^2 Report on the Algorithmic Language Scheme';
     namely `rev3-procedures' and `rev2-procedures'.

 - Feature: r3rs
     Requires features implementing procedures and optional procedures
     specified by `Revised^3 Report on the Algorithmic Language Scheme';
     namely `rev3-procedures'.

     _Note:_ SLIB already mandates the `r3rs' procedures which can be
     portably implemented in `r4rs' implementations.

 - Feature: r4rs
     Requires features implementing procedures and optional procedures
     specified by `Revised^4 Report on the Algorithmic Language Scheme';
     namely `rev4-optional-procedures'.

 - Feature: r5rs
     Requires features implementing procedures and optional procedures
     specified by `Revised^5 Report on the Algorithmic Language Scheme';
     namely `values', `macro', and `eval'.


File: slib.info,  Node: With-File,  Next: Transcripts,  Prev: RnRS,  Up: Standards Support

With-File
---------

  `(require 'with-file)'

 - Function: with-input-from-file file thunk
 - Function: with-output-to-file file thunk
     Description found in R4RS.


File: slib.info,  Node: Transcripts,  Next: Rev2 Procedures,  Prev: With-File,  Up: Standards Support

Transcripts
-----------

  `(require 'transcript)'

 - Function: transcript-on filename
 - Function: transcript-off filename
     Redefines `read-char', `read', `write-char', `write', `display',
     and `newline'.


File: slib.info,  Node: Rev2 Procedures,  Next: Rev4 Optional Procedures,  Prev: Transcripts,  Up: Standards Support

Rev2 Procedures
---------------

  `(require 'rev2-procedures)'

  The procedures below were specified in the `Revised^2 Report on
Scheme'.  *N.B.*: The symbols `1+' and `-1+' are not `R4RS' syntax.
Scheme->C, for instance, chokes on this module.

 - Procedure: substring-move-left! string1 start1 end1 string2 start2
 - Procedure: substring-move-right! string1 start1 end1 string2 start2
     STRING1 and STRING2 must be a strings, and START1, START2 and END1
     must be exact integers satisfying

          0 <= START1 <= END1 <= (string-length STRING1)
          0 <= START2 <= END1 - START1 + START2 <= (string-length STRING2)

     `substring-move-left!' and `substring-move-right!' store
     characters of STRING1 beginning with index START1 (inclusive) and
     ending with index END1 (exclusive) into STRING2 beginning with
     index START2 (inclusive).

     `substring-move-left!' stores characters in time order of
     increasing indices.  `substring-move-right!' stores characters in
     time order of increasing indeces.

 - Procedure: substring-fill! string start end char
     Fills the elements START-END of STRING with the character CHAR.

 - Function: string-null? str
     == `(= 0 (string-length STR))'

 - Procedure: append! pair1 ...
     Destructively appends its arguments.  Equivalent to `nconc'.

 - Function: 1+ n
     Adds 1 to N.

 - Function: -1+ n
     Subtracts 1 from N.

 - Function: <?
 - Function: <=?
 - Function: =?
 - Function: >?
 - Function: >=?
     These are equivalent to the procedures of the same name but
     without the trailing `?'.


File: slib.info,  Node: Rev4 Optional Procedures,  Next: Multi-argument / and -,  Prev: Rev2 Procedures,  Up: Standards Support

Rev4 Optional Procedures
------------------------

  `(require 'rev4-optional-procedures)'

  For the specification of these optional procedures, *Note Standard
procedures: (r4rs)Standard procedures.

 - Function: list-tail l p

 - Function: string->list s

 - Function: list->string l

 - Function: string-copy

 - Procedure: string-fill! s obj

 - Function: list->vector l

 - Function: vector->list s

 - Procedure: vector-fill! s obj


File: slib.info,  Node: Multi-argument / and -,  Next: Multi-argument Apply,  Prev: Rev4 Optional Procedures,  Up: Standards Support

Multi-argument / and -
----------------------

  `(require 'multiarg/and-)'

  For the specification of these optional forms, *Note Numerical
operations: (r4rs)Numerical operations.  The `two-arg:'* forms are only
defined if the implementation does not support the many-argument forms.

 - Function: two-arg:/ n1 n2
     The original two-argument version of `/'.

 - Function: / dividend divisor1 ...

 - Function: two-arg:- n1 n2
     The original two-argument version of `-'.

 - Function: - minuend subtrahend1 ...


File: slib.info,  Node: Multi-argument Apply,  Next: Rationalize,  Prev: Multi-argument / and -,  Up: Standards Support

Multi-argument Apply
--------------------

  `(require 'multiarg-apply)'

For the specification of this optional form, *Note Control features:
(r4rs)Control features.

 - Function: two-arg:apply proc l
     The implementation's native `apply'.  Only defined for
     implementations which don't support the many-argument version.

 - Function: apply proc arg1 ...


File: slib.info,  Node: Rationalize,  Next: Promises,  Prev: Multi-argument Apply,  Up: Standards Support

Rationalize
-----------

  `(require 'rationalize)'

  The procedure "rationalize" is interesting because most programming
languages do not provide anything analogous to it.  Thanks to Alan
Bawden for contributing this algorithm.

 - Function: rationalize x y
     Computes the correct result for exact arguments (provided the
     implementation supports exact rational numbers of unlimited
     precision); and produces a reasonable answer for inexact arguments
     when inexact arithmetic is implemented using floating-point.

  `Rationalize' has limited use in implementations lacking exact
(non-integer) rational numbers.  The following procedures return a list
of the numerator and denominator.

 - Function: find-ratio x y
     `find-ratio' returns the list of the _simplest_ numerator and
     denominator whose quotient differs from X by no more than Y.

     (find-ratio 3/97 .0001)             => (3 97)
     (find-ratio 3/97 .001)              => (1 32)

 - Function: find-ratio-between x y
     `find-ratio-between' returns the list of the _simplest_ numerator
     and denominator between X and Y.

     (find-ratio-between 2/7 3/5)        => (1 2)
     (find-ratio-between -3/5 -2/7)      => (-1 2)


File: slib.info,  Node: Promises,  Next: Dynamic-Wind,  Prev: Rationalize,  Up: Standards Support

Promises
--------

  `(require 'promise)'

 - Function: make-promise proc

  Change occurrences of `(delay EXPRESSION)' to `(make-promise (lambda
() EXPRESSION))' and `(define force promise:force)' to implement
promises if your implementation doesn't support them (*note Control
features: (r4rs)Control features.).


File: slib.info,  Node: Dynamic-Wind,  Next: Eval,  Prev: Promises,  Up: Standards Support

Dynamic-Wind
------------

  `(require 'dynamic-wind)'

  This facility is a generalization of Common LISP `unwind-protect',
designed to take into account the fact that continuations produced by
`call-with-current-continuation' may be reentered.

 - Procedure: dynamic-wind thunk1 thunk2 thunk3
     The arguments THUNK1, THUNK2, and THUNK3 must all be procedures of
     no arguments (thunks).

     `dynamic-wind' calls THUNK1, THUNK2, and then THUNK3.  The value
     returned by THUNK2 is returned as the result of `dynamic-wind'.
     THUNK3 is also called just before control leaves the dynamic
     context of THUNK2 by calling a continuation created outside that
     context.  Furthermore, THUNK1 is called before reentering the
     dynamic context of THUNK2 by calling a continuation created inside
     that context.  (Control is inside the context of THUNK2 if THUNK2
     is on the current return stack).

     *Warning:* There is no provision for dealing with errors or
     interrupts.  If an error or interrupt occurs while using
     `dynamic-wind', the dynamic environment will be that in effect at
     the time of the error or interrupt.


File: slib.info,  Node: Eval,  Next: Values,  Prev: Dynamic-Wind,  Up: Standards Support

Eval
----

  `(require 'eval)'

 - Function: eval expression environment-specifier
     Evaluates EXPRESSION in the specified environment and returns its
     value.  EXPRESSION must be a valid Scheme expression represented
     as data, and ENVIRONMENT-SPECIFIER must be a value returned by one
     of the three procedures described below.  Implementations may
     extend `eval' to allow non-expression programs (definitions) as
     the first argument and to allow other values as environments, with
     the restriction that `eval' is not allowed to create new bindings
     in the environments associated with `null-environment' or
     `scheme-report-environment'.

          (eval '(* 7 3) (scheme-report-environment 5))
                                                             =>  21
          
          (let ((f (eval '(lambda (f x) (f x x))
                         (null-environment))))
            (f + 10))
                                                             =>  20

 - Function: scheme-report-environment version
 - Function: null-environment version
 - Function: null-environment
     VERSION must be an exact non-negative integer N corresponding to a
     version of one of the Revised^N Reports on Scheme.
     `Scheme-report-environment' returns a specifier for an environment
     that contains the set of bindings specified in the corresponding
     report that the implementation supports.  `Null-environment'
     returns a specifier for an environment that contains only the
     (syntactic) bindings for all the syntactic keywords defined in the
     given version of the report.

     Not all versions may be available in all implementations at all
     times.  However, an implementation that conforms to version N of
     the Revised^N Reports on Scheme must accept version N.  An error
     is signalled if the specified version is not available.

     The effect of assigning (through the use of `eval') a variable
     bound in a `scheme-report-environment' (for example `car') is
     unspecified. Thus the environments specified by
     `scheme-report-environment' may be immutable.


 - Function: interaction-environment
     This optional procedure returns a specifier for the environment
     that contains implementation-defined bindings, typically a
     superset of those listed in the report.  The intent is that this
     procedure will return the environment in which the implementation
     would evaluate expressions dynamically typed by the user.

Here are some more `eval' examples:

     (require 'eval)
     => #<unspecified>
     (define car 'volvo)
     => #<unspecified>
     car
     => volvo
     (eval 'car (interaction-environment))
     => volvo
     (eval 'car (scheme-report-environment 5))
     => #<primitive-procedure car>
     (eval '(eval 'car (interaction-environment))
           (scheme-report-environment 5))
     => volvo
     (eval '(eval '(set! car 'buick) (interaction-environment))
           (scheme-report-environment 5))
     => #<unspecified>
     car
     => buick
     (eval 'car (scheme-report-environment 5))
     => #<primitive-procedure car>
     (eval '(eval 'car (interaction-environment))
           (scheme-report-environment 5))
     => buick


File: slib.info,  Node: Values,  Next: SRFI,  Prev: Eval,  Up: Standards Support

Values
------

  `(require 'values)'

 - Function: values obj ...
     `values' takes any number of arguments, and passes (returns) them
     to its continuation.

 - Function: call-with-values thunk proc
     THUNK must be a procedure of no arguments, and PROC must be a
     procedure.  `call-with-values' calls THUNK with a continuation
     that, when passed some values, calls PROC with those values as
     arguments.

     Except for continuations created by the `call-with-values'
     procedure, all continuations take exactly one value, as now; the
     effect of passing no value or more than one value to continuations
     that were not created by the `call-with-values' procedure is
     unspecified.


File: slib.info,  Node: SRFI,  Prev: Values,  Up: Standards Support

SRFI
----

  `(require 'srfi)'

Implements "Scheme Request For Implementation" (SRFI) as described at
<http://srfi.schemers.org/>

The Copyright terms of each SRFI states:
     "However, this document itself may not be modified in any way, ..."

Therefore, the specification of SRFI constructs must not be quoted
without including the complete SRFI document containing discussion and
a sample implementation program.

 - Macro: cond-expand <clause1> <clause2> ...
     _Syntax:_ Each <clause> should be of the form

     (<feature> <expression1> ...)

     where <feature> is a boolean expression composed of symbols and
     `and', `or', and `not' of boolean expressions.  The last <clause>
     may be an "else clause," which has the form

     (else <expression1> <expression2> ...).

     The first clause whose feature expression is satisfied is expanded.
     If no feature expression is satisfied and there is no else clause,
     an error is signaled.

     SLIB `cond-expand' is an extension of SRFI-0,
     <http://srfi.schemers.org/srfi-0/srfi-0.html>.

* Menu:

* SRFI-1::                      list-processing


File: slib.info,  Node: SRFI-1,  Prev: SRFI,  Up: SRFI

SRFI-1
......

  `(require 'srfi-1)'

Implements the "SRFI-1" "list-processing library" as described at
<http://srfi.schemers.org/srfi-1/srfi-1.html>

Constructors
------------

 - Function: xcons d a
     `(define (xcons d a) (cons a d))'.

 - Function: list-tabulate len proc
     Returns a list of length LEN.  Element I is `(PROC I)' for 0 <= I
     < LEN.

 - Function: cons* obj1 obj2

 - Function: iota count start step
 - Function: iota count start
 - Function: iota count
     Returns a list of COUNT numbers: (START, START+STEP, ...,
     START+(COUNT-1)*STEP).

 - Function: circular-list obj1 obj2 ...
     Returns a circular list of OBJ1, OBJ2, ....

Predicates
----------

 - Function: proper-list? obj

 - Function: circular-list? x

 - Function: dotted-list? obj

 - Function: null-list? obj

 - Function: not-pair? obj

 - Function: list= =pred list ...

Selectors
---------

 - Function: first pair
 - Function: fifth obj
 - Function: sixth obj
 - Function: seventh obj
 - Function: eighth obj
 - Function: ninth obj
 - Function: tenth obj

 - Function: car+cdr pair

 - Function: take lst k
 - Function: drop lst k

 - Function: take-right lst k

 - Function: split-at lst k

 - Function: last lst
     (car (last-pair lst))

Miscellaneous
-------------

 - Function: length+ obj

 - Function: concatenate lists
 - Function: concatenate! lists

 - Function: reverse! lst

 - Function: append-reverse rev-head tail
 - Function: append-reverse! rev-head tail

 - Function: zip list1 list2 ...

 - Function: unzip1 lst
 - Function: unzip2 lst
 - Function: unzip3 lst
 - Function: unzip4 lst
 - Function: unzip5 lst

 - Function: count pred list1 list2 ...

Fold and Unfold
---------------

Filtering and Partitioning
--------------------------

Searching
---------

 - Function: find pred list

 - Function: find-tail pred list

 - Function: member obj list pred
 - Function: member obj list
     `member' returns the first sublist of LIST whose car is OBJ, where
     the sublists of LIST are the non-empty lists returned by
     (list-tail LIST K) for K less than the length of LIST.  If OBJ
     does not occur in LIST, then #f (not the empty list) is returned.
     The procedure PRED is used for testing equality.  If PRED is not
     provided, `equal?' is used.

Deleting
--------

Association lists
-----------------

 - Function: assoc obj alist pred
 - Function: assoc obj alist
     ALIST (for "association list") must be a list of pairs.  These
     procedures find the first pair in ALIST whose car field is OBJ, and
     returns that pair.  If no pair in ALIST has OBJ as its car, then #f
     (not the empty list) is returned.  The procedure PRED is used for
     testing equality.  If PRED is not provided, `equal?' is used.

Set operations
--------------


File: slib.info,  Node: Session Support,  Next: System Interface,  Prev: Standards Support,  Up: Other Packages

Session Support
===============

* Menu:

* Repl::                        Macros at top-level
* Quick Print::                 Loop-safe Output
* Debug::                       To err is human ...
* Breakpoints::                 Pause execution
* Trace::                       'trace


File: slib.info,  Node: Repl,  Next: Quick Print,  Prev: Session Support,  Up: Session Support

Repl
----

  `(require 'repl)'

  Here is a read-eval-print-loop which, given an eval, evaluates forms.

 - Procedure: repl:top-level repl:eval
     `read's, `repl:eval's and `write's expressions from
     `(current-input-port)' to `(current-output-port)' until an
     end-of-file is encountered.  `load', `slib:eval', `slib:error',
     and `repl:quit' dynamically bound during `repl:top-level'.

 - Procedure: repl:quit
     Exits from the invocation of `repl:top-level'.

  The `repl:' procedures establish, as much as is possible to do
portably, a top level environment supporting macros.  `repl:top-level'
uses `dynamic-wind' to catch error conditions and interrupts.  If your
implementation supports this you are all set.

  Otherwise, if there is some way your implementation can catch error
conditions and interrupts, then have them call `slib:error'.  It will
display its arguments and reenter `repl:top-level'.  `slib:error'
dynamically bound by `repl:top-level'.

  To have your top level loop always use macros, add any interrupt
catching lines and the following lines to your Scheme init file:
     (require 'macro)
     (require 'repl)
     (repl:top-level macro:eval)


File: slib.info,  Node: Quick Print,  Next: Debug,  Prev: Repl,  Up: Session Support

Quick Print
-----------

  `(require 'qp)'

When displaying error messages and warnings, it is paramount that the
output generated for circular lists and large data structures be
limited.  This section supplies a procedure to do this.  It could be
much improved.

     Notice that the neccessity for truncating output eliminates
     Common-Lisp's *Note Format:: from consideration; even when
     variables `*print-level*' and `*print-level*' are set, huge
     strings and bit-vectors are _not_ limited.

 - Procedure: qp arg1 ...
 - Procedure: qpn arg1 ...
 - Procedure: qpr arg1 ...
     `qp' writes its arguments, separated by spaces, to
     `(current-output-port)'.  `qp' compresses printing by substituting
     `...' for substructure it does not have sufficient room to print.
     `qpn' is like `qp' but outputs a newline before returning.  `qpr'
     is like `qpn' except that it returns its last argument.

 - Variable: *qp-width*
     `*qp-width*' is the largest number of characters that `qp' should
     use.


File: slib.info,  Node: Debug,  Next: Breakpoints,  Prev: Quick Print,  Up: Session Support

Debug
-----

  `(require 'debug)'

Requiring `debug' automatically requires `trace' and `break'.

An application with its own datatypes may want to substitute its own
printer for `qp'.  This example shows how to do this:

     (define qpn (lambda args) ...)
     (provide 'qp)
     (require 'debug)

 - Procedure: trace-all file ...
     Traces (*note Trace::) all procedures `define'd at top-level in
     `file' ....

 - Procedure: track-all file ...
     Tracks (*note Trace::) all procedures `define'd at top-level in
     `file' ....

 - Procedure: stack-all file ...
     Stacks (*note Trace::) all procedures `define'd at top-level in
     `file' ....

 - Procedure: break-all file ...
     Breakpoints (*note Breakpoints::) all procedures `define'd at
     top-level in `file' ....


File: slib.info,  Node: Breakpoints,  Next: Trace,  Prev: Debug,  Up: Session Support

Breakpoints
-----------

  `(require 'break)'

 - Function: init-debug
     If your Scheme implementation does not support `break' or `abort',
     a message will appear when you `(require 'break)' or `(require
     'debug)' telling you to type `(init-debug)'.  This is in order to
     establish a top-level continuation.  Typing `(init-debug)' at top
     level sets up a continuation for `break'.

 - Function: breakpoint arg1 ...
     Returns from the top level continuation and pushes the
     continuation from which it was called on a continuation stack.

 - Function: continue
     Pops the topmost continuation off of the continuation stack and
     returns an unspecified value to it.

 - Function: continue arg1 ...
     Pops the topmost continuation off of the continuation stack and
     returns ARG1 ... to it.

 - Macro: break proc1 ...
     Redefines the top-level named procedures given as arguments so that
     `breakpoint' is called before calling PROC1 ....

 - Macro: break
     With no arguments, makes sure that all the currently broken
     identifiers are broken (even if those identifiers have been
     redefined) and returns a list of the broken identifiers.

 - Macro: unbreak proc1 ...
     Turns breakpoints off for its arguments.

 - Macro: unbreak
     With no arguments, unbreaks all currently broken identifiers and
     returns a list of these formerly broken identifiers.

  These are _procedures_ for breaking.  If defmacros are not natively
supported by your implementation, these might be more convenient to use.

 - Function: breakf proc
 - Function: breakf proc name
     To break, type
          (set! SYMBOL (breakf SYMBOL))

     or
          (set! SYMBOL (breakf SYMBOL 'SYMBOL))

     or
          (define SYMBOL (breakf FUNCTION))

     or
          (define SYMBOL (breakf FUNCTION 'SYMBOL))

 - Function: unbreakf proc
     To unbreak, type
          (set! SYMBOL (unbreakf SYMBOL))


File: slib.info,  Node: Trace,  Prev: Breakpoints,  Up: Session Support

Tracing
-------

  `(require 'trace)'

This feature provides three ways to monitor procedure invocations:

stack
     Pushes the procedure-name when the procedure is called; pops when
     it returns.

track
     Pushes the procedure-name and arguments when the procedure is
     called; pops when it returns.

trace
     Pushes the procedure-name and prints `CALL PROCEDURE-NAME ARG1
     ...' when the procdure is called; pops and prints `RETN
     PROCEDURE-NAME VALUE' when the procedure returns.

 - Variable: debug:max-count
     If a traced procedure calls itself or untraced procedures which
     call it, stack, track, and trace will limit the number of stack
     pushes to DEBUG:MAX-COUNT.

 - Function: print-call-stack
 - Function: print-call-stack port
     Prints the call-stack to PORT or the current-error-port.

 - Macro: trace proc1 ...
     Traces the top-level named procedures given as arguments.

 - Macro: trace
     With no arguments, makes sure that all the currently traced
     identifiers are traced (even if those identifiers have been
     redefined) and returns a list of the traced identifiers.

 - Macro: track proc1 ...
     Traces the top-level named procedures given as arguments.

 - Macro: track
     With no arguments, makes sure that all the currently tracked
     identifiers are tracked (even if those identifiers have been
     redefined) and returns a list of the tracked identifiers.

 - Macro: stack proc1 ...
     Traces the top-level named procedures given as arguments.

 - Macro: stack
     With no arguments, makes sure that all the currently stacked
     identifiers are stacked (even if those identifiers have been
     redefined) and returns a list of the stacked identifiers.

 - Macro: untrace proc1 ...
     Turns tracing, tracking, and  off for its arguments.

 - Macro: untrace
     With no arguments, untraces all currently traced identifiers and
     returns a list of these formerly traced identifiers.

 - Macro: untrack proc1 ...
     Turns tracing, tracking, and  off for its arguments.

 - Macro: untrack
     With no arguments, untracks all currently tracked identifiers and
     returns a list of these formerly tracked identifiers.

 - Macro: unstack proc1 ...
     Turns tracing, stacking, and  off for its arguments.

 - Macro: unstack
     With no arguments, unstacks all currently stacked identifiers and
     returns a list of these formerly stacked identifiers.

  These are _procedures_ for tracing.  If defmacros are not natively
supported by your implementation, these might be more convenient to use.

 - Function: tracef proc
 - Function: tracef proc name
     To trace, type
          (set! SYMBOL (tracef SYMBOL))

     or
          (set! SYMBOL (tracef SYMBOL 'SYMBOL))

     or
          (define SYMBOL (tracef FUNCTION))

     or
          (define SYMBOL (tracef FUNCTION 'SYMBOL))

 - Function: untracef proc
     Removes tracing, tracking, or stacking for PROC.  To untrace, type
          (set! SYMBOL (untracef SYMBOL))


File: slib.info,  Node: System Interface,  Next: Extra-SLIB Packages,  Prev: Session Support,  Up: Other Packages

System Interface
================

If `(provided? 'getenv)':

 - Function: getenv name
     Looks up NAME, a string, in the program environment.  If NAME is
     found a string of its value is returned.  Otherwise, `#f' is
     returned.

If `(provided? 'system)':

 - Function: system command-string
     Executes the COMMAND-STRING on the computer and returns the
     integer status code.

* Menu:

* Directories::                                                               |
* Transactions::                                                              |
* CVS::


File: slib.info,  Node: Directories,  Next: Transactions,  Prev: System Interface,  Up: System Interface
                                                                              |
Directories                                                                   |
-----------

  `(require 'directory)'                                                      |

 - Function: current-directory                                                |
     `current-directory' returns a string containing the absolute file        |
     name representing the current working directory.  If this string         |
     cannot be obtained, #f is returned.                                      |
                                                                              |
     If `current-directory' cannot be supported by the platform, then         |
     #f is returned.                                                          |
                                                                              |
 - Function: make-directory name                                              |
     Creates a sub-directory NAME of the current-directory.  If               |
     successful, `make-directory' returns #t; otherwise #f.                   |
                                                                              |
 - Function: directory-for-each proc directory                                |
     PROC must be a procedure taking one argument.                            |
     `Directory-For-Each' applies PROC to the (string) name of each           |
     file in DIRECTORY.  The dynamic order in which PROC is applied to        |
     the filenames is unspecified.  The value returned by                     |
     `directory-for-each' is unspecified.                                     |
                                                                              |
 - Function: directory-for-each proc directory pred                           |
     Applies PROC only to those filenames for which the procedure PRED        |
     returns a non-false value.                                               |
                                                                              |
 - Function: directory-for-each proc directory match                          |
     Applies PROC only to those filenames for which `(filename:match??        |
     MATCH)' would return a non-false value (*note Filenames:                 |
     (slib)Filenames.).                                                       |
                                                                              |
          (require 'directory)                                                |
          (directory-for-each print "." "[A-Z]*.scm")                         |
          -|                                                                  |
          "Bev2slib.scm"                                                      |
          "Template.scm"                                                      |
                                                                              |

File: slib.info,  Node: Transactions,  Next: CVS,  Prev: Directories,  Up: System Interface
                                                                              |
Transactions                                                                  |
------------                                                                  |
                                                                              |
If `system' is provided by the Scheme implementation, the "transact"          |
package provides functions for file-locking and file-replacement              |
transactions.                                                                 |
                                                                              |
  `(require 'transact)'                                                       |
                                                                              |
 - Function: call-with-tmpnam proc k
 - Function: call-with-tmpnam proc                                            |
     Calls PROC with K arguments, strings returned by successive calls
     to `tmpnam'.  If PROC returns, then any files named by the
     arguments to PROC are deleted automatically and the value(s)
     yielded by the PROC is(are) returned.  K may be ommited, in which
     case it defaults to `1'.

 - Function: system->line command tmp                                         |
 - Function: system->line command                                             |
     COMMAND must be a string.  The string TMP, if supplied, is a path        |
     to use as a temporary file.  `system->line' calls `system' with          |
     COMMAND as argument, redirecting stdout to file TMP.                     |
     `system->line' returns a string containing the first line of             |
     output from TMP.                                                         |

 - Function: file=? file1 file2                                               |
     Returns #t if the contents of FILE2 are identical to the contents        |
     of FILE1; returns #f otherwise.                                          |

File Locking                                                                  |
............                                                                  |

Unix file-locking is focussed on write permissions for segments of a          |
existing file.  While this might be employed for (binary) database            |
access, it is not used for everyday contention (between users) for text       |
files.                                                                        |

Microsoft has several file-locking protocols.  Their model denies write       |
access to a file if any reader has it open.  This is too restrictive.         |
Write access is denied even when the reader has reached end-of-file.          |
And tracking read access (which is much more common than write access)        |
causes havoc when remote hosts crash or disconnect.                           |

It is bizarre that the concept of multi-user contention for modifying         |
files has not been adequately addressed by either of the large                |
operating system development efforts.  There is further irony that both       |
camps support contention detection and resolution only through weak           |
conventions of some their document editing programs.                          |

The "file-lock" procedures implement a transaction method for file            |
replacement compatible with the methods used by the GNU "emacs" text          |
editor on Unix systems and the Microsoft "Word" editor.                       |

Both protocols employ what I term a "certificate" containing the user,        |
hostname, time, and (on Unix) process-id.  Intent to replace FILE is          |
indicated by adding to FILE's directory a certificate object whose name       |
is derived from FILE.                                                         |

The Microsoft Word certificate is contained in a 162 byte file named          |
for the visited FILE with a `~$' prefix.  Emacs/Unix creates a symbolic       |
link to a certificate named for the visited FILE prefixed with `.#'.          |
Because Unix systems can import Microsoft file systems, these routines        |
maintain and check both Emacs and Word certificates.                          |

 - Function: file-lock-owner path                                             |
     Returns the string `USER@HOSTNAME' associated with the lock owner        |
     of file PATH if locked; and #f otherwise.                                |

 - Function: file-lock! path email                                            |
 - Function: file-lock! path                                                  |
     PATH must be a string naming the file to be locked.  If supplied,        |
     EMAIL must be a string formatted as `USER@HOSTNAME'.  If absent,         |
     EMAIL defaults to the value returned by `user-email-address'.            |

     If PATH is already locked, then `file-lock!' returns `#f'.  If           |
     PATH is unlocked, then `file-lock!' returns the certificate string       |
     associated with the new lock for file PATH.                              |

 - Function: file-unlock! path certificate                                    |
     PATH must be a string naming the file to be unlocked.  CERTIFICATE       |
     must be the string returned by `file-lock!' for PATH.                    |

     If PATH is locked with CERTIFICATE, then `file-unlock!' removes          |
     the locks and returns `#t'.  Otherwise, `file-unlock!' leaves the        |
     file system unaltered and returns `#f'.                                  |

File Transactions                                                             |
.................                                                             |
                                                                              |
 - Function: emacs:backup-name path backup-style                              |
     PATH must be a string.  BACKUP-STYLE must be a symbol.  Depending        |
     on BACKUP-STYLE, `emacs:backup-name' returns:                            |
    none                                                                      |
          #f                                                                  |
                                                                              |
    simple                                                                    |
          the string "PATH~"                                                  |
                                                                              |
    numbered                                                                  |
          the string "PATH.~N~", where N is one greater than the              |
          highest number appearing in a filename matching "PATH.~*~".  N      |
          defauls to 1 when no filename matches.                              |
                                                                              |
    existing                                                                  |
          the string "PATH.~N~" if a numbered backup already exists in        |
          this directory; otherwise. "PATH~"                                  |
                                                                              |
    orig                                                                      |
          the string "PATH.orig"                                              |
                                                                              |
    bak                                                                       |
          the string "PATH.bak"                                               |
                                                                              |
 - Function: transact-file-replacement proc path backup-style                 |
          certificate                                                         |
 - Function: transact-file-replacement proc path backup-style                 |
 - Function: transact-file-replacement proc path                              |
     PATH must be a string naming an existing file.  BACKUP-STYLE is          |
     one of the symbols none, simple, numbered, existing, orig, bak or        |
     #f; with meanings described above.  BACKUP-STYLE defaults to #f.         |
     If supplied, CERTIFICATE is the certificate with which PATH is           |
     locked.                                                                  |
                                                                              |
     PROC must be a procedure taking two string arguments:                    |
        * PATH, the original filename (to be read); and                       |
                                                                              |
        * a temporary file-name.                                              |
                                                                              |
     If PATH is locked by other than CERTIFICATE, or if CERTIFICATE is        |
     supplied and PATH is not locked, then `transact-file-replacement'        |
     returns #f.  If CERTIFICATE is not supplied, then,                       |
     `transact-file-replacement' creates temporary (Emacs and Word)           |
     locks for PATH during the transaction.  The lock status of PATH          |
     will be restored before `transact-file-replacement' returns.             |
                                                                              |
     `transact-file-replacement' calls PROC with PATH (which should not       |
     be modified) and a temporary file path to be written.  If PROC           |
     returns any value other than #t, then the file named by PATH is          |
     not altered and `transact-file-replacement' returns #f.                  |
     Otherwise, `emacs:backup-name' is called with PATH and                   |
     BACKUP-STYLE.  If it returns a string, then PATH is renamed to it.       |
                                                                              |
     Finally, the temporary file is renamed PATH.                             |
     `transact-file-replacement' returns #t if PATH was successfully          |
     replaced; and #f otherwise.                                              |
                                                                              |
Identification                                                                |
..............                                                                |
                                                                              |
 - Function: user-email-address                                               |
     `user-email-address' returns a string of the form                        |
     `username@hostname'.  If this e-mail address cannot be obtained,         |
     #f is returned.                                                          |


File: slib.info,  Node: CVS,  Prev: Transactions,  Up: System Interface
                                                                              |
CVS
---

  `(require 'cvs)'

 - Function: cvs-files directory/                                             |
     Returns a list of the local pathnames (with prefix DIRECTORY/) of        |
     all CVS controlled files in DIRECTORY/ and in DIRECTORY/'s               |
     subdirectories.                                                          |
                                                                              |
 - Function: cvs-directories directory/                                       |
     Returns a list of all of DIRECTORY/ and all DIRECTORY/'s CVS             |
     controlled subdirectories.                                               |
                                                                              |
 - Function: cvs-root path/                                                   |
     Returns the (string) contents of PATH/CVS/Root; or `(getenv              |
     "CVSROOT")' if Root doesn't exist.                                       |
                                                                              |
 - Function: cvs-repository directory/                                        |
     Returns the (string) contents of DIRECTORY/CVS/Root appended with        |
     DIRECTORY/CVS/Repository; or #f if DIRECTORY/CVS/Repository              |
     doesn't exist.                                                           |
                                                                              |
 - Function: cvs-set-root! new-root directory/                                |
     Writes NEW-ROOT to file CVS/Root of DIRECTORY/ and all its               |
     subdirectories.                                                          |
                                                                              |
 - Function: cvs-vet directory/                                               |
     Signals an error if CVS/Repository or CVS/Root files in DIRECTORY/       |
     or any subdirectory do not match.                                        |


File: slib.info,  Node: Extra-SLIB Packages,  Prev: System Interface,  Up: Other Packages

Extra-SLIB Packages
===================

  Several Scheme packages have been written using SLIB.  There are
several reasons why a package might not be included in the SLIB
distribution:
   * Because it requires special hardware or software which is not
     universal.

   * Because it is large and of limited interest to most Scheme users.

   * Because it has copying terms different enough from the other SLIB
     packages that its inclusion would cause confusion.

   * Because it is an application program, rather than a library module.

   * Because I have been too busy to integrate it.

  Once an optional package is installed (and an entry added to
`*catalog*', the `require' mechanism allows it to be called up and used
as easily as any other SLIB package.  Some optional packages (for which
`*catalog*' already has entries) available from SLIB sites are:

SLIB-PSD
     is a portable debugger for Scheme (requires emacs editor).

     http://swissnet.ai.mit.edu/ftpdir/scm/slib-psd1-3.tar.gz

     swissnet.ai.mit.edu:/pub/scm/slib-psd1-3.tar.gz

     ftp.maths.tcd.ie:pub/bosullvn/jacal/slib-psd1-3.tar.gz

     ftp.cs.indiana.edu:/pub/scheme-repository/utl/slib-psd1-3.tar.gz


     With PSD, you can run a Scheme program in an Emacs buffer, set
     breakpoints, single step evaluation and access and modify the
     program's variables. It works by instrumenting the original source
     code, so it should run with any R4RS compliant Scheme. It has been
     tested with SCM, Elk 1.5, and the sci interpreter in the Scheme->C
     system, but should work with other Schemes with a minimal amount
     of porting, if at all. Includes documentation and user's manual.
     Written by Pertti Kellom\"aki, pk @ cs.tut.fi.  The Lisp Pointers
     article describing PSD (Lisp Pointers VI(1):15-23, January-March
     1993) is available as
     http://www.cs.tut.fi/staff/pk/scheme/psd/article/article.html


SCHELOG
     is an embedding of Prolog in Scheme.
     http://www.cs.rice.edu/CS/PLT/packages/schelog/


JFILTER
     is a Scheme program which converts text among the JIS, EUC, and
     Shift-JIS Japanese character sets.
     http://www.sci.toyama-u.ac.jp/~iwao/Scheme/Jfilter/index.html


File: slib.info,  Node: About SLIB,  Next: Index,  Prev: Other Packages,  Up: Top

About SLIB
**********

More people than I can name have contributed to SLIB.  Thanks to all of
you!

     SLIB 2d5, released November 2002.                                        |
     Aubrey Jaffer <agj @ alum.mit.edu>
     Hyperactive Software - The Maniac Inside!
     <http://swissnet.ai.mit.edu/~jaffer/SLIB.html>

* Menu:

* Installation::                How to install SLIB on your system.
* Porting::                     SLIB to new platforms.
* Coding Guidelines::           How to write modules for SLIB.
* Copyrights::                  Intellectual propery issues.


File: slib.info,  Node: Installation,  Next: Porting,  Prev: About SLIB,  Up: About SLIB

Installation
============

  There are four parts to installation:

   * Unpack the SLIB distribution.

   * Configure the Scheme implementation(s) to locate the SLIB
     directory.

   * Arrange for Scheme implementation to load its SLIB initialization
     file.

   * Build the SLIB catalog for the Scheme implementation.

Unpacking the SLIB Distribution
-------------------------------

  If the SLIB distribution is a Linux RPM, it will create the SLIB
directory `/usr/share/slib'.

  If the SLIB distribution is a ZIP file, unzip the distribution to
create the SLIB directory.  Locate this `slib' directory either in your
home directory (if only you will use this SLIB installation); or put it
in a location where libraries reside on your system.  On unix systems
this might be `/usr/share/slib', `/usr/local/lib/slib', or
`/usr/lib/slib'.  If you know where SLIB should go on other platforms,
please inform agj @ alum.mit.edu.

Configure Scheme Implementation to Locate SLIB
----------------------------------------------

  If the Scheme implementation supports `getenv', then the value of the
shell environment variable SCHEME_LIBRARY_PATH will be used for
`(library-vicinity)' if it is defined.  Currently, Chez, Elk,
MITScheme, scheme->c, VSCM, and SCM support `getenv'.  Scheme48
supports `getenv' but does not use it for determining
`library-vicinity'.  (That is done from the Makefile.)

  The `(library-vicinity)' can also be specified from the SLIB
initialization file or by implementation-specific means.

Loading SLIB Initialization File
--------------------------------

  Check the manifest in `README' to find a configuration file for your
Scheme implementation.  Initialization files for most IEEE P1178
compliant Scheme Implementations are included with this distribution.

  You should check the definitions of `software-type',
`scheme-implementation-version', `implementation-vicinity', and
`library-vicinity' in the initialization file.  There are comments in
the file for how to configure it.

  Once this is done, modify the startup file for your Scheme
implementation to `load' this initialization file.

Build New SLIB Catalog for Implementation
-----------------------------------------

  When SLIB is first used from an implementation, a file named
`slibcat' is written to the `implementation-vicinity' for that
implementation.  Because users may lack permission to write in
`implementation-vicinity', it is good practice to build the new catalog
when installing SLIB.

  To build (or rebuild) the catalog, start the Scheme implementation
(with SLIB), then:

     (require 'new-catalog)

  The catalog also supports color-name dictionaries.  With an
SLIB-installed scheme implementation, type:
     (require 'color-names)
     (make-slib-color-name-db)
     (require 'new-catalog)
     (slib:exit)

Implementation-specific Instructions
------------------------------------

  Multiple implementations of Scheme can all use the same SLIB
directory.  Simply configure each implementation's initialization file
as outlined above.

 - Implementation: SCM
     The SCM implementation does not require any initialization file as
     SLIB support is already built into SCM.  See the documentation
     with SCM for installation instructions.

 - Implementation: VSCM
     From: Matthias Blume <blume @ cs.Princeton.EDU>
     Date: Tue, 1 Mar 1994 11:42:31 -0500

     Disclaimer: The code below is only a quick hack.  If I find some
     time to spare I might get around to make some more things work.

     You have to provide `vscm.init' as an explicit command line
     argument.  Since this is not very nice I would recommend the
     following installation procedure:

       1. run scheme

       2. `(load "vscm.init")'

       3. `(slib:dump "dumpfile")'

       4. mv dumpfile place-where-vscm-standard-bootfile-resides e.g.
          mv dumpfile /usr/local/vscm/lib/scheme-boot (In this case
          vscm should have been compiled with flag
          -DDEFAULT_BOOTFILE='"/usr/local/vscm/lib/scheme-boot"'.  See
          Makefile (definition of DDP) for details.)


 - Implementation: Scheme48
     To make a Scheme48 image for an installation under `<prefix>',

       1. `cd' to the SLIB directory

       2. type `make prefix=<prefix> slib48'.

       3. To install the image, type `make prefix=<prefix> install48'.
          This will also create a shell script with the name `slib48'
          which will invoke the saved image.

 - Implementation: PLT Scheme
 - Implementation: DrScheme
 - Implementation: MzScheme
     The `init.ss' file in the _slibinit_ collection is an SLIB
     initialization file.

     To use SLIB in MzScheme, set the SCHEME_LIBRARY_PATH environment
     variable to the installed SLIB location; then invoke MzScheme thus:

     `mzscheme -f ${SCHEME_LIBRARY_PATH}DrScheme.init'

 - Implementation: MIT Scheme
     `scheme -load ${SCHEME_LIBRARY_PATH}mitscheme.init'

 - Implementation: Guile
     `guile -l ${SCHEME_LIBRARY_PATH}guile.init'


File: slib.info,  Node: Porting,  Next: Coding Guidelines,  Prev: Installation,  Up: About SLIB

Porting
=======

  If there is no initialization file for your Scheme implementation, you
will have to create one.  Your Scheme implementation must be largely
compliant with `IEEE Std 1178-1990', `Revised^4 Report on the
Algorithmic Language Scheme', or `Revised^5 Report on the Algorithmic
Language Scheme' in order to support SLIB.  (1)

  `Template.scm' is an example configuration file.  The comments inside
will direct you on how to customize it to reflect your system.  Give
your new initialization file the implementation's name with `.init'
appended.  For instance, if you were porting `foo-scheme' then the
initialization file might be called `foo.init'.

  Your customized version should then be loaded as part of your scheme
implementation's initialization.  It will load `require.scm' from the
library; this will allow the use of `provide', `provided?', and
`require' along with the "vicinity" functions (these functions are
documented in the section *Note Require::).  The rest of the library
will then be accessible in a system independent fashion.

  Please mail new working configuration files to `agj @ alum.mit.edu'
so that they can be included in the SLIB distribution.

  ---------- Footnotes ----------

  (1) If you are porting a `Revised^3 Report on the Algorithmic
Language Scheme' implementation, then you will need to finish writing
`sc4sc3.scm' and `load' it from your initialization file.


File: slib.info,  Node: Coding Guidelines,  Next: Copyrights,  Prev: Porting,  Up: About SLIB

Coding Guidelines
=================

  All library packages are written in IEEE P1178 Scheme and assume that
a configuration file and `require.scm' package have already been
loaded.  Other versions of Scheme can be supported in library packages
as well by using, for example, `(provided? 'rev3-report)' or `(require
'rev3-report)' (*note Require::).

  The module name and `:' should prefix each symbol defined in the
package.  Definitions for external use should then be exported by having
`(define foo module-name:foo)'.

  Code submitted for inclusion in SLIB should not duplicate routines
already in SLIB files.  Use `require' to force those library routines
to be used by your package.  Care should be taken that there are no
circularities in the `require's and `load's between the library
packages.

  Documentation should be provided in Emacs Texinfo format if possible,
But documentation must be provided.

  Your package will be released sooner with SLIB if you send me a file
which tests your code.  Please run this test _before_ you send me the
code!

Modifications
-------------

  Please document your changes.  A line or two for `ChangeLog' is
sufficient for simple fixes or extensions.  Look at the format of
`ChangeLog' to see what information is desired.  Please send me `diff'
files from the latest SLIB distribution (remember to send `diff's of
`slib.texi' and `ChangeLog').  This makes for less email traffic and
makes it easier for me to integrate when more than one person is
changing a file (this happens a lot with `slib.texi' and `*.init'
files).

  If someone else wrote a package you want to significantly modify,
please try to contact the author, who may be working on a new version.
This will insure against wasting effort on obsolete versions.

  Please _do not_ reformat the source code with your favorite
beautifier, make 10 fixes, and send me the resulting source code.  I do
not have the time to fish through 10000 diffs to find your 10 real
fixes.


File: slib.info,  Node: Copyrights,  Prev: Coding Guidelines,  Up: About SLIB

Copyrights
==========

  This section has instructions for SLIB authors regarding copyrights.

  Each package in SLIB must either be in the public domain, or come
with a statement of terms permitting users to copy, redistribute and
modify it.  The comments at the beginning of `require.scm' and
`macwork.scm' illustrate copyright and appropriate terms.

  If your code or changes amount to less than about 10 lines, you do not
need to add your copyright or send a disclaimer.

Putting code into the Public Domain
-----------------------------------

  In order to put code in the public domain you should sign a copyright
disclaimer and send it to the SLIB maintainer.  Contact agj @
alum.mit.edu for the address to mail the disclaimer to.

     I, NAME, hereby affirm that I have placed the software package
     NAME in the public domain.

     I affirm that I am the sole author and sole copyright holder for
     the software package, that I have the right to place this software
     package in the public domain, and that I will do nothing to
     undermine this status in the future.

                                                     SIGNATURE AND DATE

  This wording assumes that you are the sole author.  If you are not the
sole author, the wording needs to be different.  If you don't want to be
bothered with sending a letter every time you release or modify a
module, make your letter say that it also applies to your future
revisions of that module.

  Make sure no employer has any claim to the copyright on the work you
are submitting.  If there is any doubt, create a copyright disclaimer
and have your employer sign it.  Mail the signed disclaimer to the SLIB
maintainer.  Contact agj @ alum.mit.edu for the address to mail the
disclaimer to.  An example disclaimer follows.

Explicit copying terms
----------------------

If you submit more than about 10 lines of code which you are not placing
into the Public Domain (by sending me a disclaimer) you need to:

   * Arrange that your name appears in a copyright line for the
     appropriate year.   Multiple copyright lines are acceptable.

   * With your copyright line, specify any terms you require to be
     different from those already in the file.

   * Make sure no employer has any claim to the copyright on the work
     you are submitting.  If there is any doubt, create a copyright
     disclaimer and have your employer sign it.  Mail the signed
     disclaim to the SLIB maintainer.  Contact agj @ alum.mit.edu for
     the address to mail the disclaimer to.

Example: Company Copyright Disclaimer
-------------------------------------

  This disclaimer should be signed by a vice president or general
manager of the company.  If you can't get at them, anyone else
authorized to license out software produced there will do.  Here is a
sample wording:

     EMPLOYER Corporation hereby disclaims all copyright interest in
     the program PROGRAM written by NAME.

     EMPLOYER Corporation affirms that it has no other intellectual
     property interest that would undermine this release, and will do
     nothing to undermine it in the future.

     SIGNATURE AND DATE,
     NAME, TITLE, EMPLOYER Corporation


File: slib.info,  Node: Index,  Prev: About SLIB,  Up: Top

Procedure and Macro Index
*************************

  This is an alphabetical list of all the procedures and macros in SLIB.

* Menu:

* -:                                     Multi-argument / and -.
* -1+:                                   Rev2 Procedures.
* /:                                     Multi-argument / and -.
* 1+:                                    Rev2 Procedures.
* <=?:                                   Rev2 Procedures.
* <?:                                    Rev2 Procedures.
* =:                                     Bit-Twiddling.
* =?:                                    Rev2 Procedures.
* >=?:                                   Rev2 Procedures.
* >?:                                    Rev2 Procedures.
* absolute-path?:                        URI.                                 |
* ac32:                                  Arrays.
* ac64:                                  Arrays.
* add-command-tables:                    Database Extension.
* add-domain:                            Command Intrinsics.
* add-process!:                          Multi-Processing.
* add-setter:                            Setters.
* adjoin:                                Lists as sets.
* adjoin-parameters!:                    Parameter lists.
* alarm:                                 Multi-Processing.
* alarm-interrupt:                       Multi-Processing.
* alist->wt-tree:                        Construction of Weight-Balanced Trees.
* alist-associator:                      Association Lists.
* alist-for-each:                        Association Lists.
* alist-inquirer:                        Association Lists.
* alist-map:                             Association Lists.
* alist-remover:                         Association Lists.
* and?:                                  Non-List functions.
* any?:                                  Collections.
* append!:                               Rev2 Procedures.
* append-reverse:                        SRFI-1.
* append-reverse!:                       SRFI-1.
* apply:                                 Multi-argument Apply.
* ar32:                                  Arrays.
* ar64:                                  Arrays.
* array-align:                           Subarrays.
* array-copy!:                           Array Mapping.
* array-dimensions:                      Arrays.
* array-for-each:                        Array Mapping.
* array-in-bounds?:                      Arrays.
* array-index-map!:                      Array Mapping.
* array-indexes:                         Array Mapping.
* array-map!:                            Array Mapping.
* array-rank:                            Arrays.
* array-ref:                             Arrays.
* array-set!:                            Arrays.
* array-shape:                           Arrays.
* array-trim:                            Subarrays.
* array=?:                               Arrays.
* array?:                                Arrays.
* as16:                                  Arrays.
* as32:                                  Arrays.
* as64:                                  Arrays.
* as8:                                   Arrays.
* asctime:                               Posix Time.
* ash:                                   Bit-Twiddling.
* assoc:                                 SRFI-1.
* at1:                                   Arrays.
* atom?:                                 Non-List functions.
* au16:                                  Arrays.
* au32:                                  Arrays.
* au64:                                  Arrays.
* au8:                                   Arrays.
* batch:call-with-output-script:         Batch.
* batch:command:                         Batch.
* batch:comment:                         Batch.
* batch:delete-file:                     Batch.
* batch:initialize!:                     Batch.
* batch:lines->file:                     Batch.
* batch:rename-file:                     Batch.
* batch:run-script:                      Batch.
* batch:try-chopped-command:             Batch.
* batch:try-command:                     Batch.
* bit-extract:                           Bit-Twiddling.
* bit-field:                             Bit-Twiddling.
* bit-reverse:                           Bit-Twiddling.
* bitwise-if:                            Bit-Twiddling.
* bitwise:delaminate:                    Bit-Twiddling.
* bitwise:laminate:                      Bit-Twiddling.
* blackbody-spectrum:                    Spectra.
* booleans->integer:                     Bit-Twiddling.
* break:                                 Breakpoints.
* break-all:                             Debug.
* breakf:                                Breakpoints.
* breakpoint:                            Breakpoints.
* browse:                                Database Browser.
* browse-url:                            System.                              |
* butlast:                               Lists as sequences.
* butnthcdr:                             Lists as sequences.
* byte-ref:                              Byte.
* byte-set!:                             Byte.
* bytes:                                 Byte.
* bytes->list:                           Byte.
* bytes-length:                          Byte.
* call-with-dynamic-binding:             Dynamic Data Type.
* call-with-input-string:                String Ports.
* call-with-open-ports:                  Input/Output.
* call-with-output-string:               String Ports.
* call-with-tmpnam:                      Transactions.                        |
* call-with-values:                      Values.
* capture-syntactic-environment:         Syntactic Closures.
* car+cdr:                               SRFI-1.
* cart-prod-tables:                      Database Operations.
* catalog->html:                         HTML Tables.
* cgi:serve-query:                       HTTP and CGI.
* chap:next-string:                      Chapter Ordering.
* chap:string<=?:                        Chapter Ordering.
* chap:string<?:                         Chapter Ordering.
* chap:string>=?:                        Chapter Ordering.
* chap:string>?:                         Chapter Ordering.
* check-parameters:                      Parameter lists.
* chromaticity->CIEXYZ:                  Spectra.
* chromaticity->whitepoint:              Spectra.
* CIE:DE*:                               Color Difference Metrics.
* CIE:DE*94:                             Color Difference Metrics.
* ciexyz->color:                         Color Spaces.
* CIEXYZ->e-sRGB:                        Color Conversions.
* CIEXYZ->L*a*b*:                        Color Conversions.
* CIEXYZ->L*u*v*:                        Color Conversions.
* CIEXYZ->RGB709:                        Color Conversions.
* CIEXYZ->sRGB:                          Color Conversions.
* circular-list:                         SRFI-1.
* circular-list?:                        SRFI-1.
* cksum:                                 Cyclic Checksum.                     |
* cksum-string:                          Cyclic Checksum.                     |
* clear-sky-color-xyy:                   Daylight.
* close-base:                            Base Table.
* close-database <1>:                    Database Operations.
* close-database:                        Using Databases.
* close-port:                            Input/Output.
* close-table:                           Table Operations.
* CMC-DE:                                Color Conversions.
* CMC:DE*:                               Color Difference Metrics.
* coerce:                                Type Coercion.
* collection?:                           Collections.
* color->ciexyz:                         Color Spaces.
* color->e-srgb:                         Color Spaces.
* color->l*a*b*:                         Color Spaces.
* color->l*c*h:                          Color Spaces.
* color->l*u*v*:                         Color Spaces.
* color->rgb709:                         Color Spaces.
* color->srgb:                           Color Spaces.
* color->string:                         Color Data-Type.
* color->xrgb:                           Color Spaces.
* color-dictionaries->lookup:            Color Names.
* color-dictionary:                      Color Names.
* color-name->color:                     Color Names.
* color-name:canonicalize:               Color Names.
* color-precision:                       Color Data-Type.
* color-space:                           Color Data-Type.
* color-white-point:                     Color Data-Type.
* color:ciexyz:                          Color Spaces.
* color:e-srgb:                          Color Spaces.
* color:l*a*b*:                          Color Spaces.
* color:l*c*h:                           Color Spaces.
* color:l*u*v*:                          Color Spaces.
* color:rgb709:                          Color Spaces.
* color:srgb:                            Color Spaces.
* color?:                                Color Data-Type.
* combined-rulesets:                     Commutative Rings.
* command->p-specs:                      HTML.
* command:make-editable-table:           HTML Tables.
* command:modify-table:                  HTML Tables.
* concatenate:                           SRFI-1.
* concatenate!:                          SRFI-1.
* cond-expand:                           SRFI.
* cons*:                                 SRFI-1.
* continue:                              Breakpoints.
* convert-color:                         Color Data-Type.
* copy-bit:                              Bit-Twiddling.
* copy-bit-field:                        Bit-Twiddling.
* copy-list:                             List construction.
* copy-random-state:                     Random Numbers.
* copy-tree:                             Tree Operations.
* count:                                 SRFI-1.
* crc16:                                 Cyclic Checksum.                     |
* crc5:                                  Cyclic Checksum.                     |
* crc:make-table:                        Cyclic Checksum.                     |
* create-array:                          Arrays.
* create-database <1>:                   Relational Database Objects.
* create-database:                       Using Databases.
* create-report:                         Database Reports.
* create-table:                          Database Operations.
* create-view:                           Database Operations.
* cring:define-rule:                     Commutative Rings.
* ctime:                                 Posix Time.
* current-directory:                     Directories.                         |
* current-error-port:                    Input/Output.
* current-input-port <1>:                Byte.
* current-input-port:                    Ruleset Definition and Use.
* current-output-port:                   Byte.
* current-time:                          Time and Date.
* cvs-directories:                       CVS.                                 |
* cvs-files:                             CVS.
* cvs-repository:                        CVS.                                 |
* cvs-root:                              CVS.                                 |
* cvs-set-root!:                         CVS.                                 |
* cvs-vet:                               CVS.                                 |
* db->html-directory:                    HTML Tables.
* db->html-files:                        HTML Tables.
* db->netscape:                          HTML Tables.
* decode-universal-time:                 Common-Lisp Time.
* define-*commands*:                     Database Extension.                  |
* define-access-operation:               Setters.
* define-command:                        Database Macros.                     |
* define-operation:                      Yasos interface.
* define-predicate:                      Yasos interface.
* define-syntax:                         Macro by Example.
* define-table:                          Database Macros.                     |
* define-tables:                         Using Databases.
* defmacro:                              Defmacro.
* defmacro:eval:                         Defmacro.
* defmacro:expand*:                      Defmacro.
* defmacro:load:                         Defmacro.
* defmacro?:                             Defmacro.
* delete <1>:                            Destructive list operations.
* delete:                                Base Table.
* delete*:                               Base Table.
* delete-domain:                         Command Intrinsics.
* delete-file:                           Input/Output.
* delete-if:                             Destructive list operations.
* delete-if-not:                         Destructive list operations.
* delete-table:                          Database Operations.
* dequeue!:                              Queues.
* determinant:                           Matrix Algebra.
* diff:edit-length:                      Sequence Comparison.
* diff:edits:                            Sequence Comparison.
* diff:longest-common-subsequence:       Sequence Comparison.
* difftime:                              Time and Date.
* directory-for-each:                    Directories.                         |
* display-file:                          Line I/O.
* do-elts:                               Collections.
* do-keys:                               Collections.
* domain-checker:                        Command Intrinsics.
* dotted-list?:                          SRFI-1.
* drop:                                  SRFI-1.
* dynamic-ref:                           Dynamic Data Type.
* dynamic-set!:                          Dynamic Data Type.
* dynamic-wind:                          Dynamic-Wind.
* dynamic?:                              Dynamic Data Type.
* e-sRGB->CIEXYZ:                        Color Conversions.
* e-srgb->color:                         Color Spaces.
* e-sRGB->e-sRGB:                        Color Conversions.
* e-sRGB->sRGB:                          Color Conversions.
* eighth:                                SRFI-1.
* emacs:backup-name:                     Transactions.                        |
* empty?:                                Collections.
* encode-universal-time:                 Common-Lisp Time.
* enquque!:                              Queues.
* equal?:                                Byte.
* eval:                                  Eval.
* every:                                 Lists as sets.
* every?:                                Collections.
* extended-euclid:                       Modular Arithmetic.
* factor:                                Prime Numbers.
* fft:                                   Fast Fourier Transform.
* fft-1:                                 Fast Fourier Transform.
* fifth:                                 SRFI-1.
* file->color-dictionary:                Color Names.
* file-exists?:                          Input/Output.
* file-lock!:                            Transactions.                        |
* file-lock-owner:                       Transactions.                        |
* file-unlock!:                          Transactions.                        |
* file=?:                                Transactions.                        |
* filename:match-ci??:                   Filenames.
* filename:match??:                      Filenames.
* filename:substitute-ci??:              Filenames.
* filename:substitute??:                 Filenames.
* fill-empty-parameters:                 Parameter lists.
* find:                                  SRFI-1.
* find-if:                               Lists as sets.
* find-ratio:                            Rationalize.
* find-ratio-between:                    Rationalize.
* find-string-from-port?:                String Search.
* find-tail:                             SRFI-1.
* first:                                 SRFI-1.
* fluid-let:                             Fluid-Let.
* for-each-elt:                          Collections.
* for-each-key <1>:                      Collections.
* for-each-key:                          Base Table.
* for-each-row:                          Table Operations.
* force-output:                          Input/Output.
* form:delimited:                        HTML.
* form:element:                          HTML.
* form:image:                            HTML.
* form:reset:                            HTML.
* form:submit:                           HTML.
* format:                                Format Interface.
* fprintf:                               Standard Formatted Output.
* fscanf:                                Standard Formatted Input.
* generic-write:                         Generic-Write.
* gentemp:                               Defmacro.
* get:                                   Table Operations.
* get*:                                  Table Operations.
* get-decoded-time:                      Common-Lisp Time.
* get-method:                            Object.
* get-universal-time:                    Common-Lisp Time.
* getenv:                                System Interface.
* getopt:                                Getopt.
* getopt--:                              Getopt.
* getopt->arglist:                       Getopt Parameter lists.
* getopt->parameter-list:                Getopt Parameter lists.
* glob-pattern?:                         URI.                                 |
* gmktime:                               Posix Time.
* gmtime:                                Posix Time.
* golden-section-search:                 Minimizing.
* gray-code->integer:                    Bit-Twiddling.
* gray-code<=?:                          Bit-Twiddling.
* gray-code<?:                           Bit-Twiddling.
* gray-code>=?:                          Bit-Twiddling.
* gray-code>?:                           Bit-Twiddling.
* grey:                                  Color Names.
* gtime:                                 Posix Time.
* has-duplicates?:                       Lists as sets.
* hash:                                  Hashing.
* hash-associator:                       Hash Tables.
* hash-for-each:                         Hash Tables.
* hash-inquirer:                         Hash Tables.
* hash-map:                              Hash Tables.
* hash-remover:                          Hash Tables.
* hashq:                                 Hashing.
* hashv:                                 Hashing.
* heap-extract-max!:                     Priority Queues.
* heap-insert!:                          Priority Queues.
* heap-length:                           Priority Queues.
* histograph:                            Plotting.
* home-vicinity:                         Vicinity.
* html-for-each:                         Parsing HTML.                        |
* html:anchor:                           URI.
* html:atval:                            HTML.
* html:base:                             URI.
* html:body:                             HTML.
* html:buttons:                          HTML.
* html:caption:                          HTML Tables.
* html:checkbox:                         HTML.
* html:comment:                          HTML.
* html:editable-row-converter:           HTML Tables.
* html:form:                             HTML.
* html:head:                             HTML.
* html:heading:                          HTML Tables.
* html:hidden:                           HTML.
* html:href-heading:                     HTML Tables.
* html:http-equiv:                       HTML.
* html:isindex:                          URI.
* html:link:                             URI.
* html:linked-row-converter:             HTML Tables.
* html:meta:                             HTML.
* html:meta-refresh:                     HTML.
* html:plain:                            HTML.
* html:pre:                              HTML.
* html:select:                           HTML.
* html:table:                            HTML Tables.
* html:text:                             HTML.
* html:text-area:                        HTML.
* http:content:                          HTTP and CGI.
* http:error-page:                       HTTP and CGI.
* http:forwarding-page:                  HTTP and CGI.
* http:header:                           HTTP and CGI.
* http:serve-query:                      HTTP and CGI.
* identifier=?:                          Syntactic Closures.
* identifier?:                           Syntactic Closures.
* identity:                              Miscellany.
* implementation-vicinity:               Vicinity.
* in-vicinity:                           Vicinity.
* init-debug:                            Breakpoints.
* integer->gray-code:                    Bit-Twiddling.
* integer->list:                         Bit-Twiddling.
* integer-expt:                          Bit-Twiddling.
* integer-length:                        Bit-Twiddling.
* integer-sqrt:                          Root Finding.
* interaction-environment:               Eval.
* intersection:                          Lists as sets.
* iota:                                  SRFI-1.
* jacobi-symbol:                         Prime Numbers.
* kill-process!:                         Multi-Processing.
* kill-table:                            Base Table.
* L*a*b*->CIEXYZ:                        Color Conversions.
* l*a*b*->color:                         Color Spaces.
* L*a*b*->L*C*h:                         Color Conversions.
* L*a*b*:DE:                             Color Conversions.
* l*c*h->color:                          Color Spaces.
* L*C*h->L*a*b*:                         Color Conversions.
* L*C*h:DE*94:                           Color Conversions.
* L*u*v*->CIEXYZ:                        Color Conversions.
* l*u*v*->color:                         Color Spaces.
* laguerre:find-polynomial-root:         Root Finding.
* laguerre:find-root:                    Root Finding.
* last <1>:                              SRFI-1.
* last:                                  Lists as sequences.
* last-pair:                             Miscellany.
* length+:                               SRFI-1.
* library-vicinity:                      Vicinity.
* light:ambient:                         Solid Modeling.
* light:beam:                            Solid Modeling.
* light:directional:                     Solid Modeling.
* light:point:                           Solid Modeling.
* light:spot:                            Solid Modeling.
* list*:                                 List construction.
* list->bytes:                           Byte.
* list->integer:                         Bit-Twiddling.
* list->string:                          Rev4 Optional Procedures.
* list->vector:                          Rev4 Optional Procedures.
* list-of??:                             Lists as sets.
* list-table-definition:                 Using Databases.
* list-tabulate:                         SRFI-1.
* list-tail:                             Rev4 Optional Procedures.
* list=:                                 SRFI-1.
* load-color-dictionary:                 Color Names.
* load-option:                           Weight-Balanced Trees.
* localtime:                             Posix Time.
* logand:                                Bit-Twiddling.
* logbit?:                               Bit-Twiddling.
* logcount:                              Bit-Twiddling.
* logical:rotate:                        Bit-Twiddling.                       |
* logior:                                Bit-Twiddling.
* lognot:                                Bit-Twiddling.
* logtest:                               Bit-Twiddling.
* logxor:                                Bit-Twiddling.
* macro:eval <1>:                        Syntax-Case Macros.
* macro:eval <2>:                        Syntactic Closures.
* macro:eval <3>:                        Macros That Work.
* macro:eval:                            R4RS Macros.
* macro:expand <1>:                      Syntax-Case Macros.
* macro:expand <2>:                      Syntactic Closures.
* macro:expand <3>:                      Macros That Work.
* macro:expand:                          R4RS Macros.
* macro:load <1>:                        Syntax-Case Macros.
* macro:load <2>:                        Syntactic Closures.
* macro:load <3>:                        Macros That Work.
* macro:load:                            R4RS Macros.
* macroexpand:                           Defmacro.
* macroexpand-1:                         Defmacro.
* macwork:eval:                          Macros That Work.
* macwork:expand:                        Macros That Work.
* macwork:load:                          Macros That Work.
* make-array:                            Arrays.
* make-base:                             Base Table.
* make-bytes:                            Byte.
* make-color:                            Color Data-Type.
* make-command-server:                   Command Service.
* make-directory:                        Directories.                         |
* make-dynamic:                          Dynamic Data Type.
* make-exchanger:                        Miscellany.
* make-generic-method:                   Object.
* make-generic-predicate:                Object.
* make-getter:                           Base Table.
* make-hash-table:                       Hash Tables.
* make-heap:                             Priority Queues.
* make-key->list:                        Base Table.
* make-key-extractor:                    Base Table.
* make-keyifier-1:                       Base Table.
* make-list:                             List construction.
* make-list-keyifier:                    Base Table.
* make-method!:                          Object.
* make-object:                           Object.
* make-parameter-list:                   Parameter lists.                     |
* make-predicate!:                       Object.
* make-promise:                          Promises.
* make-putter:                           Base Table.
* make-query-alist-command-server:       HTTP and CGI.
* make-queue:                            Queues.
* make-random-state:                     Random Numbers.
* make-record-type:                      Records.
* make-relational-system:                Relational Database Objects.
* make-ruleset:                          Commutative Rings.
* make-shared-array:                     Arrays.
* make-sierpinski-indexer:               Space-Filling Curves.                |
* make-slib-color-name-db:               Color Names.
* make-syntactic-closure:                Syntactic Closures.
* make-table:                            Base Table.
* make-uri:                              URI.
* make-vicinity:                         Vicinity.
* make-wt-tree:                          Construction of Weight-Balanced Trees.
* make-wt-tree-type:                     Construction of Weight-Balanced Trees.
* map-elts:                              Collections.
* map-key:                               Base Table.
* map-keys:                              Collections.
* matfile:load:                          MAT-File Format.
* matfile:read:                          MAT-File Format.
* matrix->array:                         Matrix Algebra.
* matrix->lists:                         Matrix Algebra.
* matrix:inverse:                        Matrix Algebra.
* matrix:product:                        Matrix Algebra.
* mdbm:report:                           Using Databases.
* member:                                SRFI-1.
* member-if:                             Lists as sets.
* merge:                                 Sorting.
* merge!:                                Sorting.
* mktime:                                Posix Time.
* mod:                                   Modular Arithmetic.
* modular::                              Modular Arithmetic.
* modular:*:                             Modular Arithmetic.
* modular:+:                             Modular Arithmetic.
* modular:expt:                          Modular Arithmetic.
* modular:invert:                        Modular Arithmetic.
* modular:invertable?:                   Modular Arithmetic.
* modular:negate:                        Modular Arithmetic.
* modular:normalize:                     Modular Arithmetic.
* modulus->integer:                      Modular Arithmetic.
* must-be-first:                         Batch.
* must-be-last:                          Batch.
* nconc:                                 Destructive list operations.
* newton:find-integer-root:              Root Finding.                        |
* newton:find-root:                      Root Finding.                        |
* ninth:                                 SRFI-1.
* not-pair?:                             SRFI-1.
* notany:                                Lists as sets.
* notevery:                              Lists as sets.
* nreverse:                              Destructive list operations.
* nthcdr:                                Lists as sequences.
* null-directory?:                       URI.                                 |
* null-environment:                      Eval.
* null-list?:                            SRFI-1.
* object:                                Yasos interface.
* object->limited-string:                Object-To-String.
* object->string:                        Object-To-String.
* object-with-ancestors:                 Yasos interface.
* object?:                               Object.
* offset-time:                           Time and Date.
* open-base:                             Base Table.
* open-command-database:                 Database Extension.
* open-command-database!:                Database Extension.
* open-database <1>:                     Relational Database Objects.
* open-database:                         Using Databases.
* open-database!:                        Using Databases.
* open-file:                             Input/Output.
* open-table <1>:                        Database Operations.
* open-table:                            Base Table.
* operate-as:                            Yasos interface.
* or?:                                   Non-List functions.
* ordered-for-each-key:                  Base Table.
* os->batch-dialect:                     Batch.
* output-port-height:                    Input/Output.
* output-port-width:                     Input/Output.
* overcast-sky-color-xyy:                Daylight.
* parameter-list->arglist:               Parameter lists.
* parameter-list-expand:                 Parameter lists.
* parameter-list-ref:                    Parameter lists.
* parse-ftp-address:                     URI.                                 |
* path->uri:                             URI.                                 |
* pathname->vicinity:                    Vicinity.                            |
* plot:                                  Plotting.
* pnm:array-write:                       Portable Image Files.
* pnm:image-file->array:                 Portable Image Files.
* pnm:type-dimensions:                   Portable Image Files.
* port?:                                 Input/Output.
* position:                              Lists as sequences.
* pprint-file:                           Pretty-Print.
* pprint-filter-file:                    Pretty-Print.
* prec:commentfix:                       Grammar Rule Definition.
* prec:define-grammar:                   Ruleset Definition and Use.
* prec:delim:                            Grammar Rule Definition.
* prec:infix:                            Grammar Rule Definition.
* prec:inmatchfix:                       Grammar Rule Definition.
* prec:make-led:                         Nud and Led Definition.
* prec:make-nud:                         Nud and Led Definition.
* prec:matchfix:                         Grammar Rule Definition.
* prec:nary:                             Grammar Rule Definition.
* prec:nofix:                            Grammar Rule Definition.
* prec:parse:                            Ruleset Definition and Use.
* prec:postfix:                          Grammar Rule Definition.
* prec:prefix:                           Grammar Rule Definition.
* prec:prestfix:                         Grammar Rule Definition.
* predicate->asso:                       Association Lists.
* predicate->hash:                       Hash Tables.
* predicate->hash-asso:                  Hash Tables.
* present?:                              Base Table.
* pretty-print:                          Pretty-Print.
* pretty-print->string:                  Pretty-Print.
* prime?:                                Prime Numbers.
* primes<:                               Prime Numbers.
* primes>:                               Prime Numbers.
* print:                                 Yasos interface.
* print-call-stack:                      Trace.
* printf:                                Standard Formatted Output.
* process:schedule!:                     Multi-Processing.
* program-vicinity:                      Vicinity.
* project-table:                         Database Operations.
* proper-list?:                          SRFI-1.
* provide <1>:                           Require.
* provide:                               Feature.
* provided? <1>:                         Require.
* provided?:                             Feature.
* qp:                                    Quick Print.
* qpn:                                   Quick Print.
* qpr:                                   Quick Print.
* queue-empty?:                          Queues.
* queue-front:                           Queues.
* queue-pop!:                            Queues.
* queue-push!:                           Queues.
* queue-rear:                            Queues.
* queue?:                                Queues.
* random:                                Random Numbers.
* random:exp:                            Random Numbers.
* random:hollow-sphere!:                 Random Numbers.
* random:normal:                         Random Numbers.
* random:normal-vector!:                 Random Numbers.
* random:solid-sphere!:                  Random Numbers.
* random:uniform:                        Random Numbers.
* rationalize:                           Rationalize.
* read-byte:                             Byte.
* read-command:                          Command Line.
* read-line:                             Line I/O.
* read-line!:                            Line I/O.
* read-options-file:                     Command Line.
* record-accessor:                       Records.
* record-constructor:                    Records.
* record-modifier:                       Records.
* record-predicate:                      Records.
* reduce <1>:                            Lists as sequences.
* reduce:                                Collections.
* reduce-init:                           Lists as sequences.
* rem:                                   Modular Arithmetic.
* remove:                                Lists as sets.
* remove-duplicates:                     Lists as sets.
* remove-if:                             Lists as sets.
* remove-if-not:                         Lists as sets.
* remove-parameter:                      Parameter lists.
* remove-setter-for:                     Setters.
* repl:quit:                             Repl.
* repl:top-level:                        Repl.
* replace-suffix:                        Filenames.
* require <1>:                           Require.
* require <2>:                           Catalog Compilation.
* require:                               Requesting Features.
* require:feature->path <1>:             Require.
* require:feature->path:                 Requesting Features.
* resene:                                Color Names.
* restrict-table:                        Database Operations.
* reverse!:                              SRFI-1.
* RGB709->CIEXYZ:                        Color Conversions.
* rgb709->color:                         Color Spaces.
* row:delete:                            Table Operations.
* row:delete*:                           Table Operations.
* row:insert:                            Table Operations.
* row:insert*:                           Table Operations.
* row:remove:                            Table Operations.
* row:remove*:                           Table Operations.
* row:retrieve:                          Table Operations.
* row:retrieve*:                         Table Operations.
* row:update:                            Table Operations.
* row:update*:                           Table Operations.
* saturate:                              Color Names.
* scanf:                                 Standard Formatted Input.
* scanf-read-list:                       Standard Formatted Input.
* scene:overcast:                        Solid Modeling.
* scene:panorama:                        Solid Modeling.
* scene:sky-and-dirt:                    Solid Modeling.
* scene:sky-and-grass:                   Solid Modeling.
* scene:sphere:                          Solid Modeling.
* scene:sun:                             Solid Modeling.
* scene:viewpoint:                       Solid Modeling.
* scene:viewpoints:                      Solid Modeling.
* scheme-report-environment:             Eval.
* schmooz:                               Schmooz.
* secant:find-bracketed-root:            Root Finding.
* secant:find-root:                      Root Finding.
* seed->random-state:                    Random Numbers.
* set:                                   Setters.
* set-difference:                        Lists as sets.
* Setter:                                Collections.
* setter:                                Setters.
* seventh:                               SRFI-1.
* si:conversion-factor:                  Metric Units.
* singleton-wt-tree:                     Construction of Weight-Balanced Trees.
* sixth:                                 SRFI-1.
* size <1>:                              Collections.
* size:                                  Yasos interface.
* sky-color-xyy:                         Daylight.
* slib:error:                            System.
* slib:eval:                             System.
* slib:eval-load:                        System.
* slib:exit:                             System.
* slib:load:                             System.
* slib:load-compiled:                    System.
* slib:load-source:                      System.
* slib:report:                           Configuration.
* slib:report-version:                   Configuration.
* slib:warn:                             System.
* software-type:                         Configuration.
* solar-declination:                     Daylight.
* solar-hour:                            Daylight.
* solar-polar:                           Daylight.
* solid:arrow:                           Solid Modeling.
* solid:box:                             Solid Modeling.
* solid:center-array-of:                 Solid Modeling.
* solid:center-pile-of:                  Solid Modeling.
* solid:center-row-of:                   Solid Modeling.
* solid:color:                           Solid Modeling.
* solid:cone:                            Solid Modeling.
* solid:cylinder:                        Solid Modeling.
* solid:disk:                            Solid Modeling.
* solid:ellipsoid:                       Solid Modeling.
* solid:pyramid:                         Solid Modeling.
* solid:rotation:                        Solid Modeling.
* solid:scale:                           Solid Modeling.
* solid:sphere:                          Solid Modeling.
* solid:texture:                         Solid Modeling.
* solid:translation:                     Solid Modeling.
* solidify-database <1>:                 Database Operations.
* solidify-database:                     Using Databases.
* some:                                  Lists as sets.
* sort:                                  Sorting.
* sort!:                                 Sorting.
* sorted?:                               Sorting.
* soundex:                               Soundex.                             |
* spectrum->chromaticity:                Spectra.
* spectrum->CIEXYZ:                      Spectra.
* spectrum->XYZ:                         Spectra.
* split-at:                              SRFI-1.
* sprintf:                               Standard Formatted Output.
* sRGB->CIEXYZ:                          Color Conversions.
* srgb->color:                           Color Spaces.
* sRGB->e-sRGB:                          Color Conversions.
* sscanf:                                Standard Formatted Input.
* stack:                                 Trace.
* stack-all:                             Debug.
* string->color:                         Color Data-Type.
* string->list:                          Rev4 Optional Procedures.
* string-capitalize:                     String-Case.
* string-captialize!:                    String-Case.
* string-ci->symbol:                     String-Case.
* string-copy:                           Rev4 Optional Procedures.
* string-downcase:                       String-Case.
* string-downcase!:                      String-Case.
* string-fill!:                          Rev4 Optional Procedures.
* string-index:                          String Search.
* string-index-ci:                       String Search.
* string-join:                           Batch.
* string-null?:                          Rev2 Procedures.
* string-reverse-index:                  String Search.
* string-reverse-index-ci:               String Search.
* string-subst:                          String Search.
* string-upcase:                         String-Case.
* string-upcase!:                        String-Case.
* StudlyCapsExpand:                      String-Case.
* sub-vicinity:                          Vicinity.
* subarray:                              Subarrays.
* subarray0:                             Subarrays.
* subst:                                 Tree Operations.
* substq:                                Tree Operations.
* substring-ci?:                         String Search.
* substring-fill!:                       Rev2 Procedures.
* substring-move-left!:                  Rev2 Procedures.
* substring-move-right!:                 Rev2 Procedures.
* substring?:                            String Search.
* substv:                                Tree Operations.
* sunlight-ciexyz:                       Daylight.
* sunlight-spectrum:                     Daylight.
* sunlight-xyz:                          Daylight.
* supported-key-type?:                   Base Table.
* supported-type?:                       Base Table.
* symbol-append:                         String-Case.
* symmetric:modulus:                     Modular Arithmetic.
* sync-base:                             Base Table.
* sync-database <1>:                     Database Operations.
* sync-database:                         Using Databases.
* syncase:eval:                          Syntax-Case Macros.
* syncase:expand:                        Syntax-Case Macros.
* syncase:load:                          Syntax-Case Macros.
* synclo:eval:                           Syntactic Closures.
* synclo:expand:                         Syntactic Closures.
* synclo:load:                           Syntactic Closures.
* syntax-rules:                          Macro by Example.
* system:                                System Interface.
* system->line:                          Transactions.                        |
* table->linked-html:                    HTML Tables.
* table->linked-page:                    HTML Tables.
* table-exists?:                         Database Operations.
* table-name->filename:                  HTML Tables.
* take:                                  SRFI-1.
* take-right:                            SRFI-1.
* temperature->CIEXYZ:                   Spectra.
* temperature->XYZ:                      Spectra.
* tenth:                                 SRFI-1.
* time-zone:                             Time Zone.
* tmpnam:                                Input/Output.
* tok:char-group:                        Token definition.
* topological-sort:                      Topological Sort.
* trace:                                 Trace.
* trace-all:                             Debug.
* tracef:                                Trace.
* track:                                 Trace.
* track-all:                             Debug.
* transact-file-replacement:             Transactions.                        |
* transcript-off:                        Transcripts.
* transcript-on:                         Transcripts.
* transformer:                           Syntactic Closures.
* transpose:                             Matrix Algebra.
* truncate-up-to:                        Batch.
* tsort:                                 Topological Sort.
* two-arg:-:                             Multi-argument / and -.
* two-arg:/:                             Multi-argument / and -.
* two-arg:apply:                         Multi-argument Apply.
* type-of:                               Type Coercion.
* tz:params:                             Time Zone.
* tzset:                                 Time Zone.
* unbreak:                               Breakpoints.
* unbreakf:                              Breakpoints.
* union:                                 Lists as sets.
* unmake-method!:                        Object.
* unstack:                               Trace.
* untrace:                               Trace.
* untracef:                              Trace.
* untrack:                               Trace.
* unzip1:                                SRFI-1.
* unzip2:                                SRFI-1.
* unzip3:                                SRFI-1.
* unzip4:                                SRFI-1.
* unzip5:                                SRFI-1.
* uri->tree:                             URI.
* uric:decode:                           URI.
* uric:encode:                           URI.
* url->color-dictionary:                 Color Names.
* user-email-address:                    Transactions.                        |
* user-vicinity:                         Vicinity.
* values:                                Values.
* vector->list:                          Rev4 Optional Procedures.
* vector-fill!:                          Rev4 Optional Procedures.
* vrml:                                  Solid Modeling.
* vrml-append:                           Solid Modeling.
* vrml-to-file:                          Solid Modeling.
* wavelength->chromaticity:              Spectra.
* wavelength->CIEXYZ:                    Spectra.
* wavelength->XYZ:                       Spectra.
* with-input-from-file:                  With-File.
* with-output-to-file:                   With-File.
* within-database:                       Database Macros.                     |
* world:info:                            Solid Modeling.
* wrap-command-interface:                Database Extension.
* write-base:                            Base Table.
* write-byte:                            Byte.
* write-database <1>:                    Database Operations.
* write-database:                        Using Databases.
* write-line:                            Line I/O.
* wt-tree/add:                           Basic Operations on Weight-Balanced Trees.
* wt-tree/add!:                          Basic Operations on Weight-Balanced Trees.
* wt-tree/delete:                        Basic Operations on Weight-Balanced Trees.
* wt-tree/delete!:                       Basic Operations on Weight-Balanced Trees.
* wt-tree/delete-min:                    Indexing Operations on Weight-Balanced Trees.
* wt-tree/delete-min!:                   Indexing Operations on Weight-Balanced Trees.
* wt-tree/difference:                    Advanced Operations on Weight-Balanced Trees.
* wt-tree/empty?:                        Basic Operations on Weight-Balanced Trees.
* wt-tree/fold:                          Advanced Operations on Weight-Balanced Trees.
* wt-tree/for-each:                      Advanced Operations on Weight-Balanced Trees.
* wt-tree/index:                         Indexing Operations on Weight-Balanced Trees.
* wt-tree/index-datum:                   Indexing Operations on Weight-Balanced Trees.
* wt-tree/index-pair:                    Indexing Operations on Weight-Balanced Trees.
* wt-tree/intersection:                  Advanced Operations on Weight-Balanced Trees.
* wt-tree/lookup:                        Basic Operations on Weight-Balanced Trees.
* wt-tree/member?:                       Basic Operations on Weight-Balanced Trees.
* wt-tree/min:                           Indexing Operations on Weight-Balanced Trees.
* wt-tree/min-datum:                     Indexing Operations on Weight-Balanced Trees.
* wt-tree/min-pair:                      Indexing Operations on Weight-Balanced Trees.
* wt-tree/rank:                          Indexing Operations on Weight-Balanced Trees.
* wt-tree/set-equal?:                    Advanced Operations on Weight-Balanced Trees.
* wt-tree/size:                          Basic Operations on Weight-Balanced Trees.
* wt-tree/split<:                        Advanced Operations on Weight-Balanced Trees.
* wt-tree/split>:                        Advanced Operations on Weight-Balanced Trees.
* wt-tree/subset?:                       Advanced Operations on Weight-Balanced Trees.
* wt-tree/union:                         Advanced Operations on Weight-Balanced Trees.
* wt-tree?:                              Basic Operations on Weight-Balanced Trees.
* xcons:                                 SRFI-1.
* xrgb->color:                           Color Spaces.
* xyY->XYZ:                              Spectra.
* xyY:normalize-colors:                  Spectra.
* XYZ->chromaticity:                     Spectra.
* XYZ->xyY:                              Spectra.
* XYZ:normalize:                         Spectra.
* XYZ:normalize-colors:                  Spectra.
* zenith-xyy:                            Daylight.
* zip:                                   SRFI-1.

Variable Index
**************

  This is an alphabetical list of all the global variables in SLIB.

* Menu:

* *base-table-implementations*:          Base Table.
* *catalog*:                             Require.
* *features*:                            Require.
* *http:byline*:                         HTTP and CGI.
* *modules*:                             Require.
* *operating-system*:                    Batch.
* *optarg*:                              Getopt.
* *optind*:                              Getopt.
* *qp-width*:                            Quick Print.
* *random-state*:                        Random Numbers.
* *ruleset*:                             Commutative Rings.
* *syn-defs*:                            Ruleset Definition and Use.
* *syn-ignore-whitespace*:               Ruleset Definition and Use.
* *timezone*:                            Time Zone.
* atm-hec-polynomial:                    Cyclic Checksum.                     |
* catalog-id:                            Base Table.
* char-code-limit:                       Configuration.
* charplot:dimensions:                   Plotting.
* CIEXYZ:A:                              Color Conversions.
* CIEXYZ:B:                              Color Conversions.
* CIEXYZ:C:                              Color Conversions.
* CIEXYZ:D50:                            Color Conversions.
* CIEXYZ:D65:                            Color Conversions.
* CIEXYZ:E:                              Color Conversions.
* column-domains:                        Table Operations.
* column-foreigns:                       Table Operations.
* column-names:                          Table Operations.
* column-types:                          Table Operations.
* crc-08-polynomial:                     Cyclic Checksum.                     |
* crc-10-polynomial:                     Cyclic Checksum.                     |
* crc-12-polynomial:                     Cyclic Checksum.                     |
* crc-16-polynomial:                     Cyclic Checksum.                     |
* crc-32-polynomial:                     Cyclic Checksum.                     |
* crc-ccitt-polynomial:                  Cyclic Checksum.                     |
* D50:                                   Color Data-Type.
* D65:                                   Color Data-Type.
* daylight?:                             Time Zone.
* debug:max-count:                       Trace.
* distribute*:                           Commutative Rings.
* distribute/:                           Commutative Rings.
* dowcrc-polynomial:                     Cyclic Checksum.                     |
* most-positive-fixnum:                  Configuration.
* nil:                                   Miscellany.
* number-wt-type:                        Construction of Weight-Balanced Trees.
* primary-limit:                         Table Operations.
* prime:prngs:                           Prime Numbers.
* prime:trials:                          Prime Numbers.
* slib:form-feed:                        Configuration.
* slib:tab:                              Configuration.
* stderr:                                Standard Formatted I/O.
* stdin:                                 Standard Formatted I/O.
* stdout:                                Standard Formatted I/O.
* string-wt-type:                        Construction of Weight-Balanced Trees.
* t:                                     Miscellany.
* tok:decimal-digits:                    Token definition.
* tok:lower-case:                        Token definition.
* tok:upper-case:                        Token definition.
* tok:whitespaces:                       Token definition.
* tzname:                                Time Zone.
* usb-token-polynomial:                  Cyclic Checksum.                     |

Concept and Feature Index
*************************

* Menu:

* alist:                                 Association Lists.
* alist-table <1>:                       Relational Database Objects.
* alist-table:                           Base Table.
* ange-ftp:                              URI.                                 |
* appearance:                            Solid Modeling.
* array:                                 Arrays.
* array-for-each:                        Array Mapping.
* attribute-value:                       HTML.
* Auto-sharing:                          Using Databases.
* balanced binary trees:                 Weight-Balanced Trees.
* base:                                  URI.
* base-table:                            Base Table.
* batch:                                 Batch.
* binary:                                Byte.
* binary trees:                          Weight-Balanced Trees.
* binary trees, as discrete maps:        Weight-Balanced Trees.
* binary trees, as sets:                 Weight-Balanced Trees.
* break:                                 Breakpoints.
* byte:                                  Byte.
* calendar time <1>:                     Posix Time.
* calendar time:                         Time and Date.
* Calendar-Time:                         Posix Time.
* caltime:                               Posix Time.
* canonical:                             Color Names.
* careful:                               Commutative Rings.
* catalog:                               Requesting Features.
* Catalog File:                          Library Catalogs.
* certificate:                           Transactions.                        |
* cgi:                                   HTTP and CGI.
* chapter-order:                         Chapter Ordering.
* charplot:                              Plotting.
* Chroma:                                Color Spaces.
* cie1931:                               Spectra.
* cie1964:                               Spectra.
* ciexyz:                                Spectra.
* CIEXYZ:                                Color Spaces.
* coerce:                                Type Coercion.
* collect:                               Collections.
* command line:                          Command Line.
* commentfix:                            Precedence Parsing Overview.
* common-list-functions <1>:             Common List Functions.
* common-list-functions:                 Collections.
* commutative-ring:                      Commutative Rings.
* Coordinated Universal Time:            Posix Time.
* copyright:                             Copyrights.
* crc:                                   Cyclic Checksum.                     |
* cvs:                                   CVS.
* database-commands:                     Command Example.                     |
* databases <1>:                         Command Example.
* databases <2>:                         Define-tables Example.
* databases <3>:                         Using Databases.
* databases:                             Batch.
* daylight:                              Daylight.
* debug <1>:                             Breakpoints.
* debug:                                 Debug.
* defmacroexpand <1>:                    Pretty-Print.
* defmacroexpand:                        Defmacro.
* delim:                                 Precedence Parsing Overview.
* diff:                                  Sequence Comparison.
* discrete maps, using binary trees:     Weight-Balanced Trees.
* DrScheme:                              Installation.
* dynamic:                               Dynamic Data Type.
* dynamic-wind:                          Dynamic-Wind.
* e-sRGB:                                Color Spaces.
* emacs:                                 Transactions.                        |
* escaped:                               URI.
* Euclidean Domain:                      Commutative Rings.
* eval:                                  Eval.
* exchanger:                             Miscellany.
* factor:                                Prime Numbers.
* feature <1>:                           About this manual.
* feature <2>:                           Requesting Features.
* feature:                               Feature.
* fft:                                   Fast Fourier Transform.
* File Transfer Protocol:                URI.                                 |
* file-lock:                             Transactions.                        |
* filename:                              Filenames.                           |
* fluid-let:                             Fluid-Let.
* form:                                  HTML.
* format:                                Format.
* gamut:                                 Color Spaces.
* generic-write:                         Generic-Write.
* getit:                                 URI.                                 |
* getopt <1>:                            Command Example.
* getopt:                                Getopt.
* getopt-parameters <1>:                 Command Example.                     |
* getopt-parameters:                     Getopt Parameter lists.
* glob <1>:                              Batch.
* glob:                                  Filenames.
* Gray code:                             Bit-Twiddling.
* Guile:                                 Installation.
* hash:                                  Hashing.
* hash-table:                            Hash Tables.
* HOME <1>:                              Vicinity.
* HOME:                                  Library Catalogs.
* homecat:                               Catalog Compilation.
* html-form:                             HTML.
* http:                                  HTTP and CGI.
* Hue:                                   Color Spaces.
* ICC Profile:                           Color Spaces.
* implcat:                               Catalog Compilation.
* infix:                                 Precedence Parsing Overview.
* inmatchfix:                            Precedence Parsing Overview.
* L*a*b*:                                Color Spaces.
* L*C*h:                                 Color Spaces.
* L*u*v*:                                Color Spaces.
* Left Denotation, led:                  Nud and Led Definition.
* Lightness:                             Color Spaces.
* line-i:                                Line I/O.
* list-processing library:               SRFI-1.
* logical:                               Bit-Twiddling.
* macro <1>:                             Repl.
* macro:                                 R4RS Macros.
* macro-by-example:                      Macro by Example.
* macros-that-work:                      Macros That Work.                    |
* match:                                 Base Table.
* match-keys <1>:                        Table Operations.
* match-keys:                            Base Table.
* matchfix:                              Precedence Parsing Overview.
* matfile:                               MAT-File Format.
* metric-units:                          Metric Units.
* minimize:                              Minimizing.
* minimum field width (printf):          Standard Formatted Output.
* MIT Scheme:                            Installation.
* mkimpcat.scm:                          Catalog Compilation.
* mklibcat.scm:                          Catalog Compilation.
* modular:                               Modular Arithmetic.
* multiarg:                              Multi-argument / and -.
* multiarg-apply:                        Multi-argument Apply.
* MzScheme:                              Installation.
* nary:                                  Precedence Parsing Overview.         |
* new-catalog:                           Catalog Compilation.
* nofix:                                 Precedence Parsing Overview.
* null:                                  HTML Tables.
* Null Denotation, nud:                  Nud and Led Definition.
* object:                                Object.
* object->string:                        Object-To-String.
* oop:                                   Yasos.
* option, run-time-loadable:             Weight-Balanced Trees.
* options file:                          Command Line.
* parameters <1>:                        Command Example.
* parameters <2>:                        Batch.
* parameters:                            Parameter lists.
* parse:                                 Precedence Parsing.
* pbm:                                   Portable Image Files.                |
* pbm-raw:                               Portable Image Files.                |
* pgm:                                   Portable Image Files.                |
* pgm-raw:                               Portable Image Files.                |
* plain-text:                            HTML.
* PLT Scheme:                            Installation.
* posix-time:                            Posix Time.
* postfix:                               Precedence Parsing Overview.
* ppm:                                   Portable Image Files.                |
* ppm-raw:                               Portable Image Files.                |
* pprint-file:                           Pretty-Print.
* PRE:                                   HTML.
* precedence:                            Precedence Parsing.
* precision (printf):                    Standard Formatted Output.
* prefix:                                Precedence Parsing Overview.
* prestfix:                              Precedence Parsing Overview.
* pretty-print:                          Pretty-Print.
* primes:                                Prime Numbers.
* printf:                                Standard Formatted Output.
* priority-queue:                        Priority Queues.
* PRNG:                                  Random Numbers.
* process:                               Multi-Processing.
* promise:                               Promises.
* qp <1>:                                Quick Print.
* qp:                                    Getopt.
* query-string:                          HTTP and CGI.
* queue:                                 Queues.
* r2rs:                                  RnRS.
* r3rs:                                  RnRS.
* r4rs:                                  RnRS.
* r5rs:                                  RnRS.
* random:                                Random Numbers.
* rationalize:                           Rationalize.
* read-command:                          Command Line.
* record:                                Records.
* relational-database:                   Relational Database.
* repl <1>:                              Repl.
* repl:                                  Syntax-Case Macros.
* resene:                                Color Names.
* Resene:                                Color Names.
* reset:                                 HTML.
* rev2-procedures:                       Rev2 Procedures.
* rev3-report:                           Coding Guidelines.
* rev4-optional-procedures:              Rev4 Optional Procedures.
* RGB709:                                Color Spaces.
* ring, commutative:                     Commutative Rings.
* RNG:                                   Random Numbers.
* root:                                  Root Finding.
* run-time-loadable option:              Weight-Balanced Trees.
* saturate:                              Color Names.
* scanf:                                 Standard Formatted Input.
* Scheme Request For Implementation:     SRFI.
* Scheme48:                              Installation.
* schmooz:                               Schmooz.
* SCM:                                   Installation.
* self-set:                              Commutative Rings.
* Sequence Comparison:                   Sequence Comparison.
* Server-based Naming Authority:         URI.
* session:                               Feature.
* sets, using binary trees:              Weight-Balanced Trees.
* sierpinski:                            Space-Filling Curves.                |
* sitecat:                               Catalog Compilation.
* sky:                                   Daylight.
* slibcat:                               Catalog Compilation.
* solid:                                 Solid Modeling.
* solid-modeling:                        Solid Modeling.
* solids:                                Solid Modeling.
* sort:                                  Sorting.
* soundex:                               Soundex.                             |
* sparse:                                MAT-File Format.
* Spectral Tristimulus Values:           Spectra.
* spiff:                                 Sequence Comparison.
* srfi:                                  SRFI.
* SRFI-1:                                SRFI-1.
* srfi-1:                                SRFI-1.
* sRGB:                                  Color Spaces.
* stdio:                                 Standard Formatted I/O.
* string-case:                           String-Case.
* string-port:                           String Ports.
* string-search:                         String Search.
* subarray:                              Subarrays.
* sun:                                   Daylight.
* sunlight:                              Daylight.
* syntactic-closures:                    Syntactic Closures.
* syntax-case:                           Syntax-Case Macros.
* time:                                  Time and Date.
* time-zone:                             Time Zone.
* topological-sort:                      Topological Sort.
* trace:                                 Trace.
* transact:                              Transactions.                        |
* transcript:                            Transcripts.
* tree:                                  Tree Operations.
* trees, balanced binary:                Weight-Balanced Trees.
* tristimulus:                           Color Spaces.
* tsort:                                 Topological Sort.
* turbidity:                             Daylight.
* TZ-string:                             Time Zone.
* Uniform Resource Identifiers:          URI.
* Uniform Resource Locator:              URI.                                 |
* Unique Factorization:                  Commutative Rings.
* unsafe:                                URI.
* uri:                                   URI.
* URI:                                   HTTP and CGI.
* usercat:                               Catalog Compilation.
* UTC:                                   Posix Time.
* values:                                Values.
* VSCM:                                  Installation.
* WB:                                    Base Table.
* wb-table:                              Base Table.
* weight-balanced binary trees:          Weight-Balanced Trees.
* wget:                                  Color Names.
* white point:                           Color Data-Type.
* wild-card:                             Base Table.
* with-file:                             With-File.
* Word:                                  Transactions.                        |
* wt-tree:                               Weight-Balanced Trees.
* xRGB:                                  Color Spaces.
* xyY:                                   Spectra.
* yasos:                                 Yasos.



Tag Table:
Node: Top1038
Node: The Library System1752
Node: Feature2066
Node: Requesting Features3016
Node: Library Catalogs4375
Node: Catalog Compilation6914
Node: Built-in Support9723
Node: Require10358
Node: Vicinity12850
Node: Configuration16365
Node: Input/Output19306
Node: System22679
Node: Miscellany26236
Node: About this manual28116
Node: Scheme Syntax Extension Packages28673
Node: Defmacro29332
Node: R4RS Macros31283
Node: Macro by Example32538
Node: Macros That Work35417
Node: Syntactic Closures41473
Node: Syntax-Case Macros58901
Node: Fluid-Let63030
Node: Yasos63971
Node: Yasos terms64764
Node: Yasos interface65788
Node: Setters67863
Node: Yasos examples70504
Node: Textual Conversion Packages73498
Node: Precedence Parsing74307
Node: Precedence Parsing Overview74970
Ref: Precedence Parsing Overview-Footnote-176131
Node: Ruleset Definition and Use77171
Node: Token definition79552
Node: Nud and Led Definition81821
Node: Grammar Rule Definition84270
Node: Format91844
Node: Format Interface92092
Node: Format Specification93829
Node: Standard Formatted I/O104686
Node: Standard Formatted Output105252
Node: Standard Formatted Input114643
Node: Programs and Arguments121303
Node: Getopt121803
Node: Command Line127645
Node: Parameter lists130834
Node: Getopt Parameter lists134721
Node: Filenames137973
Node: Batch141203
Node: HTML149008
Node: HTML Tables155109
Node: HTTP and CGI161587
Node: Parsing HTML166205
Node: URI169351
Node: Printing Scheme174903
Node: Generic-Write175212
Node: Object-To-String176615
Node: Pretty-Print177019
Node: Time and Date179982
Node: Time Zone181001
Node: Posix Time185562
Node: Common-Lisp Time187698
Node: Schmooz189277
Node: Mathematical Packages193511
Node: Bit-Twiddling194232
Node: Modular Arithmetic202476
Node: Prime Numbers205347
Node: Random Numbers207030
Node: Fast Fourier Transform211666
Node: Cyclic Checksum212584
Node: Plotting225237
Node: Solid Modeling231305
Node: Color246297
Node: Color Data-Type247125
Ref: Color Data-Type-Footnote-1239382
Node: Color Spaces251088
Ref: Color Spaces-Footnote-1249316
Node: Spectra260941
Node: Color Difference Metrics268244
Node: Color Conversions270345
Node: Color Names273056
Node: Daylight279912
Node: Root Finding284713
Node: Minimizing288727
Ref: Minimizing-Footnote-1279364
Node: Commutative Rings290767
Node: Matrix Algebra302156
Node: Database Packages303288
Node: Base Table303552
Node: Relational Database315057
Node: Using Databases315987
Node: Relational Database Objects320794
Node: Database Operations323177
Node: Table Operations326369
Node: Catalog Representation334236
Node: Embedded Commands337134
Node: Database Extension338777
Node: Command Intrinsics341636
Node: Define-tables Example343109
Node: The *commands* Table345534
Node: Command Service347793
Node: Command Example349740
Node: Database Macros354593
Node: Within-database Example360152
Node: Database Reports364328
Node: Database Browser367158
Node: Weight-Balanced Trees368219
Node: Construction of Weight-Balanced Trees372090
Node: Basic Operations on Weight-Balanced Trees375540
Node: Advanced Operations on Weight-Balanced Trees378505
Node: Indexing Operations on Weight-Balanced Trees384527
Node: Other Packages388441
Node: Data Structures388936
Node: Arrays389709
Node: Subarrays395406
Node: Array Mapping398762
Node: Association Lists400678
Node: Byte402929
Node: MAT-File Format405382
Node: Portable Image Files406629
Node: Collections408294
Node: Dynamic Data Type414426
Node: Hash Tables415687
Node: Object417872
Node: Priority Queues426191
Node: Queues427034
Node: Records428160
Node: Sorting and Searching431652
Node: Common List Functions432416
Node: List construction432862
Node: Lists as sets434556
Node: Lists as sequences440842
Node: Destructive list operations446096
Node: Non-List functions448771
Node: Tree Operations449841
Node: Chapter Ordering451518
Node: Sorting453149
Node: Topological Sort458937
Node: Hashing460710
Node: Space-Filling Curves463146
Node: Soundex467253
Node: String Search470726
Node: Sequence Comparison473189
Node: Procedures478830
Node: Type Coercion479352
Node: String-Case479771
Node: String Ports481577
Node: Line I/O482336
Node: Multi-Processing483985
Node: Metric Units485089
Node: Standards Support493315
Node: RnRS494105
Node: With-File495312
Node: Transcripts495575
Node: Rev2 Procedures495896
Node: Rev4 Optional Procedures497606
Node: Multi-argument / and -498176
Node: Multi-argument Apply498831
Node: Rationalize499319
Node: Promises500644
Node: Dynamic-Wind501061
Node: Eval502315
Node: Values505652
Node: SRFI506452
Node: SRFI-1507646
Node: Session Support510492
Node: Repl510890
Node: Quick Print512173
Node: Debug513286
Node: Breakpoints514172
Node: Trace516195
Node: System Interface519281
Node: Directories519969
Node: Transactions523050
Node: CVS534139
Node: Extra-SLIB Packages536323
Node: About SLIB538626
Node: Installation539289
Node: Porting544397
Ref: Porting-Footnote-1512396
Node: Coding Guidelines545914
Node: Copyrights547995
Node: Index551277

End Tag Table
